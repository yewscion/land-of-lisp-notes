#+PROPERTY: header-args :results replace verbatim value
These are my notes while working through the LoL book, interpersed
with all of the code I copied during that work.

* Part I - Lisp is Power
** Chapter 1 - Getting Started with Lisp
   I mostly read through this chapter before taking notes. However, it
   mostly focuses on Common Lisp as a concept and the installation
   progress. I may come back at the end and take real notes, but for
   now I am comfortable leaving it as is.
   Here's the example on the second page.

   #+begin_src lisp
     (+ 3 (* 2 4 ))
   #+end_src

   The brief history outlines LISP as coming from a more mathematical
   background than a necessarily compsci background. John McCarthy
   created LISP in 1959. The goal was to make a programming language
   that was completely theoretical, but could produce elegant programs.

   It was apparently a fun project, nothing serious. Haha.


   #+begin_src lisp :results output
     (print "This File Contains")
     (print "Two Lines of Lisp")
   #+end_src
** Chapter 2 - Creating Your First Lisp Program
   We're going to be developing a guess-my-number game.
*** Defining Global Variables
   #+begin_src lisp 
     (defparameter *small* 1)
     (defparameter *big* 100)
   #+end_src
   #+begin_src lisp :results output
     (print *small*)
     (print *big*)
   #+end_src

   The book goes on to talk about global variables, and the differences
   between defparameter (overwrites old value if it exists) and defvar
   (does not overwrite existing values).
*** Defining Global Functions
   #+begin_src lisp
     (defun guess-my-number ()
       (ash (+ *small* *big*) -1))
   #+end_src

   We've defined our first function.

   The ash fuction used here is for (a)rithmetic (s)hifting. We're
   using it because we are limiting our scope to whole numbers, and
   want to take the shortened average of our limits.

   This will take the binary representation of that sum and shift it
   right by one. This, in effect, halves the value: All of the bits
   move right, and we are in base 2.

   More generally, this operation can be mathematically expressed as
   floor(input*2^shift), with input being the first argument and shift
   being the second. (Note that we used a negative value here, and
   therefore took 2^-1, or 1/2: Halving the number.


   #+begin_src lisp
     (guess-my-number)
   #+end_src
*** Subfunctions
   This was the expected output.

   #+begin_src lisp
     (defun smaller ()
       (setf *big* (1- (guess-my-number)))
       (guess-my-number))
    
     (defun bigger ()
       (setf *small* (1+ (guess-my-number)))
       (guess-my-number))
   #+end_src

   Let's finish playing this round, now. My number will be 37.

   #+begin_src lisp
     (guess-my-number)
     (smaller)
     (bigger)
   #+end_src

   Not bad. Now, to reset it, we'll need a function that sets those
   global variables back to their starting values. I'm going to try to
   write it without looking at the book, and then compare.

   #+begin_src lisp
     (defun my-reset (small big)
       (setf *small* small)
       (setf *big* big)
       (guess-my-number))
   #+end_src

   Let's keep playing. New Number: 92.

   #+begin_src lisp
     (my-reset 1 100)
     (bigger)
     (bigger)
     (bigger)
     (smaller)
     (bigger)
    
   #+end_src

   We've done it! Time to review the book; I wonder how different it
   will be?

   #+begin_src lisp
     (defun start-over ()
       (defparameter *small* 1)
       (defparameter *big* 100)
       (guess-my-number))
   #+end_src

   I like mine better, since it lets You pick new bounds. But I
   understand why they kept it simple here.
*** Scope
   To end off this chapter, we are discussing scope. Local variables
   use the `let` function.

   #+begin_src lisp
     (let ((a 5)
	   (b 6))
       (+ a b))
   #+end_src

   Once the let function ends, we can no longer reference those
   variables as they were defined. (+ a b) will no longer work.

   There are two similar functions for local functions, flet and
   labels.
  
   #+begin_src lisp
     (flet ((f (n)
	      (+ n 10))
	    (g (n)
	      (- n 6)))
       (g (f 5)))
    
   #+end_src

   flet is the simpler one, which behaves much the way let does. It's
   big limitation is that it cannot define multiple functions that
   reference each other, or a function that calls itself. For either of
   those, we need to use labels.

   #+begin_src lisp
     (labels ((a (n)
		(+ n 5))
	      (b (n)
		(+ (a n) 6)))
       (b 10))
   #+end_src

   One reason to use flet over labels would be to use a global function
   of the same name: In labels, it would instead refer to itself.
** Chapter 3 - Exploring the Syntax of Lisp Code
   This chapter starts off by explaining the difference (and
   connection) between syntax and semantics in both human and
   programming languages.
*** Syntax and Semantics
   /Syntax/ is the rules a piece of text needs to follow to be valid in
   whatever language it is written in.

   /Semantics/ is the underlying thought or action present in a piece
   of text.

   Two pieces of text can have the /different/ syntax, but /identical/
   semantics, if they are in different languages.
  
   *Having a simple syntax is a defining feature of the Lisp language.*

   A /Reader/ is the part of a Lisp compiler or interpreter that reads
   in the code. In Lisp, this is simpler than in any other major
   programming language.

   #+begin_src lisp
     (defun square (n)
       (* n n))
   #+end_src

   The above function, =square=, is used to examine this further.

   This is a /function declaration/, which creates a new function that
   takes a number and returns its square. It consists of exactly two
   parts: /Parentheses/, and /symbols/. These two parts are arranged in
   a set of /nested lists/ that create the function.

   This is important, because *Lisp only has one way of organizing bits
   of code: it uses /parentheses/ to organize /symbols/ into /lists/.*

   We are going to examine these ideas further.
*** Symbols

    In Lisp, a symbol is any stand alone word.

    They can be made up of letters ([A-Za-z]), numbers([0-9]), and
    symbols (+ - / * = < > ? ! _). They are case insensitive, though
    convention avoids typing in upper case.

    #+begin_src lisp
      (eq 'fooo 'FoOo)
    #+end_src
   
*** Numbers
   
    Lisp supports both integers and floating point numbers.

    #+begin_src lisp :results output
      (print (+ 1 1.0))
      (print (expt 53 53))
      (print (/ 2 3))
    #+end_src

    If You work with both integers and floating point numbers, the
    integers will become "poisoned" and a floating point number will be
    returned.

    Lisp is good with big numbers.

    Lisp also can return ratios (dividing integers) as well as decimal
    numbers (dividing floating point numbers).

*** Strings

    To indicate a string in Lisp, surround it with double quotes (").


    #+begin_src lisp
      (princ "Tutti Frutti")
    #+end_src
   
    (The =princ= function does /not/ output a newline, and is therefore
    less READable than the =print= function.)
   
    You can also include /escaped characters/ using standard backslash
    notation.

*** Code and Data Modes

 There are two modes in Lisp: /Code Mode/ and /Data Mode/.

 In /Code Mode/, lists need to be structured as a /form/: with the
 first item in the list being a /command/ and the rest being the
 /parameters/. For the form =(expt 2 3)=, =expt= is the command, and
 the parameters are the list =(2 3)=. It therefore results in =8=.

 #+begin_src lisp
   (expt 2 3)
 #+end_src

 When lisp reads the parameters, it stays in /Code Mode/. This way, You
 can nest forms indefinitely, as You may need to.

 #+begin_src lisp
   (expt 2 (+ 3 4))
 #+end_src

 *Inner forms are always executed before outer forms.*

 You can engage /Data Mode/ by placing a single quote (') in front of
 the leading parenthesis (like this: ='(expt 2 3)=). This tells Lisp to
 treat the enclosed data as a plain list: do /not/ evaluate any
 functions that may be inside.

*** Cons Cells
 Lists hold the program together, but what is the mortar that ties the
 bricks of symbols into a list? Cons Cells.

 [ ][ ]
  V  V

 Think of a Cons cell as a pair of boxes that can point to other
 things. Cons cells can point to numbers, strings, lists, or other cons
 cells; they are the true building blocks of the language. Everything
 else is an abstraction built on top of them.

 In brief, a cons cell can be thought of as similar to a linked list
 item.

*** Cons Function

 There are three basic functions for interacting with lists in Lisp:
 =cons=, =car=, and =cdr=.

 =cons= is how You link items together. It can link any two
 symbols. The second item is usually a list.

 #+begin_src lisp
   (cons 'chicken 'pork)
 #+end_src

 It returns the Cons cell it creates, printing it in the dotted pair
 notation: =(CHICKEN . CAT)=.

 If the second item is =nil=, then the list is a one-symbol list like
 =(CHICKEN)=. This is really still a cons cell in the form of =(CHICKEN
 . nil)=, but =nil= is used to end lists in Lisp. It's a special use.

 The result is shown as a list because Lisp always goes out of its way
 to hide the Cons cells if it can. Since a Cons cell with =nil= at the
 end is a list, it shows the list.

 The /empty list/, =()= is synonymous with =nil=.

 This is incidently why the second item in a call to =cons= is usually
 a list: This, in effect, adds the first item to the front of the
 already-properly-constructed list.

 #+begin_src lisp :results value list
   (cons 'pork (cons 'beef (cons 'chicken ())))
 #+end_src

 In short: *A chain of cons cells and a list are the same thing in
 Lisp*.

*** Car and Cdr
 Lists are just long chains of two item cells.

 The =car= function returns the first thing, and the =cdr= function
 returns the last thing.

 There are extension functions up to four deep, that allow for pulling
 specific data out of a list.

 #+begin_src lisp
   (cadadr '((perl c cpp) (lisp clojure haskell) scheme)) 
 #+end_src

 In short, we've learned:

 - Parentheses are there to keep syntax down.
 - Lists are just groups of connected cons cells.
 - You can create lists using =cons=.
 - You can inspect parts of a list using =car= and =cdr=.


*** List
    Common Lisp has many functions built on top of the basic three
    (=cons=, =car=, and =cdr=).

    One convenient one is =list=. It does all of the work to build a
    list at once, as that is a common pattern.

    #+begin_src lisp
      (list 'pork 'beef 'chicken)
    #+end_src
*** Nested Lists
    Lists can contain other lists.

    The first two commands are equivalent to each of the last two
    commands, in that they all isolate the first nested list and then
    return a list consisting of the final two elements of the first
    list.
    #+begin_src lisp :results output
      (print (car '((peas carrots tomatoes) (pork beef chicken))))
      (print (cdr '(peas carrots tomatoes)))
      (print (cdr (car '((peas carrots tomatoes) (pork beef chicken)))))
      (print (cdar '((peas carrots tomatoes) (pork beef chicken))))
    #+end_src

    You can also create the initial list from above using /solely/
    =cons=, which is really what the above is doing behind the scenes.

    #+begin_src lisp
      (cons
       (cons 'peas
	     (cons 'carrots
		   (cons 'tomatoes
			 ())))
       (cons
	(cons 'pork
	      (cons 'beef
		    (cons 'chicken
			  ())))
	()))
    #+end_src

    Here are some c*r functions operating on the list: ='((peas carrots
    tomatoes) (pork beef chicken) duck)=. Note that these only go 4
    levels deep: Anything deeper than that will need to be written by
    hand.
    #+begin_src lisp :results output
      (print (cddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (caddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cddar '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cadadr '((peas carrots tomatoes) (pork beef chicken) duck)))
    #+end_src
*** What we've Learned
    We discussed basic Lisp syntax, including the benefits of
    parentheses, lists, and cons/car/cdr.
* Part II - Lisp is Symmetry
** Chapter 4 - Making Decisions with Conditions
   Now we're finally learning some flow control.
*** Symmetry of nil and ()
    *Lisp commands and data structures are imbued with symmetry in
    every conceivable way.*
*** Empty Equals False
    Lisp philosophy strongly emphasizes lists. Empty Lists are treated
    as a false value when evaluating a condition.

    #+begin_src lisp
      (if '()
	  'i-am-true
	  'i-am-false)
    #+end_src

    Any non-empty list will evaluate to true.

    #+begin_src lisp
      (if '(1)
	  'i-am-true
	  'i-am-false)
    #+end_src

    This allows us to process /recursion/ very easily, by taking items
    from the front of a list and sending the rest back to the function
    in the tail call.

    Here's a classic lisp function that returns the length of a list
    using the recursion process above.

    #+begin_src lisp
      (defun my-length (list)
	(if list
	    (1+ (my-length (cdr list)))
	    0))
      
      (my-length '(list with four symbols))
    #+end_src

    Lists in Lisp are recursive to begin with (conses of conses of
    conses) so consuming a list this way is a natural and efficient
    progression. However, calling Yourself recursively can sometime
    impact the speed of a fuction. There is a special kind of
    recursion to mitigate this problem that will be discussed in
    *Chapter 14*.
*** The Four Disguises of ()
    The empty list is not only /something/ that evaluates to
    false. =()= is the *only* false value in Common Lisp. *Any value
    not equivalent to an empty list will be considered a true value.*

    #+begin_src lisp :results output
      (print (eq '() nil))
      (print (eq '() ()))
      (print (eq '() 'nil))
    #+end_src

    ='()=, =()=, ='nil=, and =nil= are all equavalent, and all
    represent an empty list. =()= and =nil= are special forms, because
    they seem to violate the rules of Lisp syntax. However, they are
    all in the Common Lisp spec: ='()= is a basic, empty list. ='nil=
    exists due to the requirements of the Common Lisp spec to provide
    a common target for falsity. =nil= evaluates to itself, or rather
    ='nil=, which is treated as an empty list. =()= evaluates
    evaluates to ='nil= due to a requirement in the spec for =()= and
    =nil= to be treated the same.

    This is different from Scheme. In Scheme, empty lists are simply
    empty lists, and are not treated as values with falsity. However,
    in Common Lisp, they are.
*** The Conditionals: if and Beyond
    The standard =if= command exists in lisp.

    The format of the function is basically:

    (if <condition> <then statement> <else statement>)

    However, the else statement is optional. In the case of an omitted
    else statement being lead to, then nothing is executed and the
    value =nil= is returned.
    #+begin_src lisp :results output
      (if (= (+ 1 2) 3)
	  (print "yup")
	  (print "nope"))
      (if (= (+ 1 2) 4)
	  (print "yup")
	  (print "nope"))
      (if (= (+ 1 2) 3)
	  (print "yup"))
      (if (= (+ 1 2) 4)
	  (print "yup"))
    #+end_src

    As =nil= is equivalent to an empty list, it then becomes obvious
    that testing for an empty list is important. And, because an empty
    list is treated as =false=, it is trivial to test for one.

    #+begin_src lisp :results output
      (if '(1)
	  (print "Not Empty")
	  (print "Empty"))
      (if '()
	  (print "Not Empty")
	  (print "Empty"))
      (if (if (= (+ 1 2) 4)
	      (print "yup"))
	  (print "This won't happen.")
	  (print "The original value was nil."))
    #+end_src

    Usually, when a function is executed in lisp, all of the
    expressions after a function are evaluated before the function
    itself is. However, =if= doesn't follow that rule. This makes
    things like the following possible, which includes an illegal
    command (dividing by zero).

    #+begin_src lisp
      (if (oddp 5)
	  'odd-number
	  (/ 1 0))
    #+end_src

    Since only the chosen expression is evaluated, the =(/ 1 0)= else
    statement is never touched, and therefore does not cause an error.

    This rulebreaking behavior is possible because the =if= function
    is considered a /special form/, which gives it special privileges
    (like not preevaluating all of its arguments). *Conditional
    Statements in Lisp are Typically Special Forms.* Special forms are
    usually commands that are baked into a language.

    Note: /Macros,/ which we'll learn about in Chapter 16, are
    something like user-created special forms.

    The other important thing to note about =if= is that it is only
    capable of doing one thing, since only one expression (either
    =then= or =else=) is ever evaluated. It is impossible to do two
    things with a single =if=.

    This is considered a good thing in Functional Programming, though
    in other paradigms is a limitation that may be fairly prominent.

    Of course, there is a way around it. There's another special form,
    =progn=, that allows You to wedge in more commands to that single
    expression that gets evaluated. Per the definition in the
    [[http://clhs.lisp.se/Body/s_progn.htm][HyperSpec]], as each form is evaluated, all return values are
    ignored aside from the final form's. Per the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/progn.html][Elisp Equivalent]], the
    preceding forms are evaluated primarily for their side effects
    (hence why functional programming may not make much use of
    =progn=.

    #+begin_src lisp :results output
      (defvar *number-was-odd* nil)
      (if (oddp 5)
	  (progn (setf *number-was-odd* t)
		 (print *number-was-odd*)
		 (print "odd number"))
	  'even-number)
    #+end_src
*** Beyond if: when and unless
    There are a number of commands that include an /implicit
    progn/. We'll look at two here, =when= and =unless=.

    With =when=, all enclosed expressions are evaluated /when/ the
    condition is true. With =unless=, all enclosed expressions are
    evaluated /unless/ the condition is true.

    The trade off with these two functions is they will only return
    =nil= and do nothing when the condition is the opposite of their
    expected state: That is, when =when= has a false condition and
    when =unless= has a true condition, nothing will happen and the
    statement will return =nil=.

    #+begin_src lisp :results output
      (when (oddp 5)
	(print "Yup")
	(print "5 is indeed Odd."))
      (unless (oddp 4)
	(print "Yup")
	(print "4 is not Odd."))
      (when (oddp 4)
	(print "Yup")
	(print "5 is indeed Odd."))
      (unless (oddp 5)
	(print "Yup")
	(print "4 is not Odd."))
    #+end_src

*** The Command that Does it All: cond
    If You don't want to compromise, and want the greatest degree of
    control over Your flow, =cond= does not have any
    trade-offs... Aside from its complexity.

    *The =cond= form is the classic way to do branching in Lisp.*

    It allows implicit progns, can handle more than one branch, and
    can even evaluate multiple conditions.

    The body of a =cond= statement uses a layer of parentheses to
    separate its branches. The first expression in each parantesized
    part contains the conditional statement for making that branch
    active. The conditions are always checked from the top down, so
    *the first successful branch defines the behavior of a =cond=
    statement.*

    To define a base case, it is a common idiom to include =t= as the
    final conditional statement, so that if that branch is reached it
    is always executed.

    This reminds me a lot of a switch-case statement from C++. Or
    rather, how I wish the switch-case statement from C++ behaved.

    Here's an example, where the supplied person's name is compared to
    two defined names and a base case before the branch is
    chosen. Note that the branches can contain more than one
    expression, due to the implicit =progn=.
    #+begin_src lisp :results output
      (defvar *arch-enemy* nil)n
      (defun pudding-eater (person)
	(cond
	  (
	   (eq person 'henry)
	   (setf *arch-enemy* 'stupid-lisp-alien)
	   (print "Curse You Lisp alien - You ate my pudding!")
	   )
	  (
	   (eq person 'johnny)
	   (setf *arch-enemy* 'useless-old-johnny)
	   (print "I hope You choked on my Pudding, Johnny.")
	   )
	  (
	   t
	   (print "Why'd You eat my pudding, stranger?")
	   )))
      (pudding-eater 'johnny)
      (print *arch-enemy*)
      (pudding-eater 'george-clooney)
    #+end_src

*** Branching with case
    As I noted myself, the =cond= example reminded me of switch-case
    in C++. It is so commonly used to simply compare a single input to
    a variety of cases, that there is a special form for that specific
    use case: the =case= form.

    The benefits to using the =case= form are mostly to reduce the
    syntactic complexity in a program. There are also (depending on
    the implementation used) a variety of efficiency optimizations
    that may come with using =case= over =cond=.

    *Warning:* Because the =case= command uses =eq= internally to
     compare values, =case= is usually only used for branching on
     symbol values. It cannot be used to branch on string values,
     among other things. The next section goes over this in more
     detail.

     Below is the same program as in the =cond= section, but edited to
     use =case= instead.

     #+begin_src lisp :results output
      (defun pudding-eater-case (person)
	(case person
	  (
	   (henry)
	   (setf *arch-enemy* 'stupid-lisp-alien)
	   (print "Curse You Lisp alien - You ate my pudding!")
	   )
	  (
	   'johnny
	   (setf *arch-enemy* 'useless-old-johnny)
	   (print "I hope You choked on my Pudding, Johnny.")
	   )
	  (
	   otherwise
	   (print "Why'd You eat my pudding, stranger?")
	   )))
      (pudding-eater-case 'johnny)
      (print *arch-enemy*)
      (pudding-eater-case 'george-clooney)
     #+end_src
*** Using the Stealth Conditionals: and and or
    The conditionals =and= and =or= are simple mathematical
    operators. They let You chain conditionals together.

    The =and= form lets You check multiple conditionals at the same
    time, and only returns true if they are all true.

    The =or= form lets You check multiple conditionals at the same
    time, and only returns false if none of them are true.
    
    #+begin_src lisp
      (print (and (oddp 7) (oddp 5) (oddp 3)))
      (print (and (oddp 6) (oddp 5) (oddp 3)))
      (print (or (oddp 8) (oddp 7) (oddp 6)))
      (print (or (oddp 8) (oddp 6) (oddp 4)))
    #+end_src

    However, due to the way Common Lisp handles =true= and =false=, we
    can use =and= and =or= for conditional behavior.

    Here is an example of how we can do this with =or=. We define a
    global variable =*is-it-even*= and =or= the command to set it to
    =t= with the numbers we are checking.

    #+begin_src lisp
      (defparameter *is-it-even* nil)
      (print (or (oddp 4) (setf *is-it-even* t)))
      (print *is-it-even*)
    #+end_src

    However, if we do the same with an odd number, the global variable
    remains unchanged.

    #+begin_src lisp
      (defparameter *is-it-even-2* nil)
      (print (or (oddp 5) (setf *is-it-even-2* t)))
      (print *is-it-even-2*)
    #+end_src

    This is because Common Lisp uses /Shortcut Boolean Evaluation/,
    which basically means that once Lisp determines an earlier
    statement in a list of =or= values is true, it returns and leaves
    the rest unevaluated. In short, *You can use =or= to run a command
    /only/ if all prior conditionals were false.*

    You can use =and= similarly, however the shortcut for =and= is the
    opposite: *You can use =and= to run a command /only/ if all prior
    conditionals were true.*

    It is considered clean code to avoid this, however. If You want
    the cleanest, most maintainable code possible, only use these
    functions on expressions that are designed to return a Boolean
    value.
*** Using Functions that Return More than Just the Truth
    Let's take a look at another function: the =member= command can be
    used to check if an item exists in a list.

    #+begin_src lisp
      (if (member 1 '(3 4 1 5))
		  (print "One is in the List")
		  (print "One is not in the List"))
    #+end_src
    

    However, the /way/ it returns true is unconventional and
    Lisp-driven:

    #+begin_src lisp
      (print (member 1 '(3 4 1 5)))
    #+end_src

    The main question for any Lisper when they write a function that
    returns true or false is: *Is there anything else I could return
    other than just t?*

    This is because *all non-nil values evaluate to true*. Returning
    more than t is essentially free.

    The main reason the function =member= returns the tail of the
    original list and not just the found value on a true result is a
    specific edge case: looking for /nil/ in a list (which would
    evaluate to false if it returned just /nil/.

    There is another notable fuction for how it uses a rich return
    value: =find-if=.

    #+begin_src lisp
      (print (find-if #'oddp '(2 4 5 6)))
      (if (find-if #'oddp '(2 4 5 6))
	  (print "There is an odd number.")
	  (print "There is no odd number."))
      
    #+end_src

    The =find-if= function takes another function as an argument (as
    it is a higher-order function, to be discussed in greater depth in
    chapters 7 and 14) and returns the first (if any) member that
    causes the supplied function to evaluate to true from the supplied
    list.

    Note, however, that the edge case mentioned above (returning
    /nil/) is not accounted for here.

    #+begin_src lisp
      (print (find-if #'null '(2 4 nil 6)))
    #+end_src

    If used as a conditional statement, a true result will evaluate to
    false as well as a false result. This is bad, but a necessary evil
    for =find-if= to work consistently.
*** Comparing Stuff: eq, equal, and More
    Asymmetry is present when comparing things, unfortunately.

    There are a number of functions to compare things; the most
    commonly used ones are: =equal=, =eq=, ===, =string-equal=, and
    =equalp=. Knowing when to use each is important.
**** Conrad's Rule of Thumb for Comparing Stuff
     When in doubt, following these two steps will usually get You by.

     1. Use =eq= when comparing symbols.
     2. Use =equal= for everything else.
**** Eq
     The =eq= function is the simplest comparison function, which
     makes it very fast. However, it struggles with items that are not
     symbols.

     That said, using =eq= is a must if the values being compared are
     known to be symbols.
     
     #+begin_src lisp
       (defparameter *fruit* 'apple)
       (cond ((eq *fruit* 'apple) (print "It's an Apple"))
	     ((eq *fruit* 'orange) (print "It's an Orange")))
     #+end_src

     It's worth noting that =eq= can be used to compare conses as
     well, though it will only return true for the *exact same call*
     to cons. Even if the cons looks similar after the fact, it will
     return /nil/.
**** Equal
     If You aren't dealing with two symbols, or such a case cannot be
     guaranteed by the function You are writing, it is better to use
     =equal=. It tells You when two things are /isomorphic/, meaning
     that they look the same. It works for all basic Lisp datatypes.

     #+begin_src lisp
       (print (equal 'apple 'apple))
       (print (equal (list 1 2 3) (list 1 2 3)))
       (print (equal '(1 2 3) (cons 1 (cons 2 (cons 3 ())))))
       (print (equal 5 5))
       (print (equal 2.5 2.5))
       (print (equal "foo" "foo"))
       (print (equal #\a #\a))
     #+end_src

     The =equal= function can compare most things, so it is a safe
     choice, if an inefficient one.
**** Eql
     The =eql= command is very similar to =eq=, but it also handles
     the comparison of numbers and characters (leaving out things like
     strings and lists).

     #+begin_src lisp
       (print (eql 'foo 'foo))
       (print (eql 3.4 3.4))
       (print (eql #\a #\a))
     #+end_src
**** Equalp
     The =equalp= command is very similar to =equal=, except it can
     handle more difficult comparisons, like strings with varying
     capitalizations or integers to floats.

     #+begin_src lisp
       (print (equalp "Bob Smith" "bob smith"))
       (print (equalp 0 0.0))
     #+end_src
**** Others
     The === function handles numbers only. The =string-equal= handles
     strings only. The =char-equal= function handles characters only.

     There are others as well, but they are not common. There are a
     bunch of different function.
*** What We've Learned
    This chapter was all about branching through conditionals: How
    =nil=, ='nil=, =()=, and ='()= are all the same, and all treated
    as false. List Eaters are really easy to make. Lisp uses lazy
    evaluation. Using =cond= lets You do really cool conditionals. And
    comparing things is complicated.
** Chapter 5 - Building a Text Game Engine
   This is interesting: This chapter begins by stressing that handling
   text is not a computer's strength. As someone who has grown up
   belly-deep in ASCII and UTF, this is an interesting statement to
   wrestle with. I live my life through plaintext, for the most part,
   and yet this chapter considers text to be a necessary evil best
   kept to a minimum.
*** The Wizard's Adventure Game
    As is obvious by the Chapter title, we are making a game here. In
    this game, You are a wizard's apprentice, exploring that wizard's
    house. The game will not be complete until Chapter 17, but when it
    is You will be able to solve puzzles and win a magical donut.
**** Basic Requirements
     
    There is a picture that describes the world we are creating. Three
    areas (rooms): a living room, an attic, and a garden. There is a
    ladder connecting the living room to the attic, and a door
    connecting the garden to the living room. There is no immediate
    path between the garden and the attic.

    We'll need a few actions as well as the world around us: Looking,
    Moving, Taking Objects, and Performing Actions on Objects Held. In
    this chapter, we are going over the first three of these.

    When Looking Around (the first action), there are three kinds of
    things to see in any location:

    - Scenery
    - Exits
    - Objects
*** Describing the Scenery with an Association List
    As our world is simple, we can describe the scenery using one
    global variable.

    Below, we define this variable: =*nodes*=. It contains the list
    and description of our three places. In essence, it gives us a way
    to look up a piece of data (the description) attached to a
    specific /key/ (in this case, the room name). This is called an
    /Association List/, or an /alist/, and will be discussed more in
    Chapter 7.

    One thing to note is the absence of strings. The data below is
    encoded entirely in more fundamental datatypes: Only Symbols and
    Lists. This is to illustrate that *by keeping Your source data
    structures free from assumptions regarding the output format from
    the start, Your coding can take full advantage of Your programming
    language.* We'll be formatting these lists and symbols into text
    in the next chapter.

    Note however that this is not a limitation of Lispâ€”You can work
    directly with strings if You prefer (and will be, in Chapter 11).
    #+begin_src lisp :results value
      (defparameter *nodes* '((living-room (You are in the living-room. A
      wizard is snoring loudly on the couch.))
			     (garden (You are in a beautiful garden. There
			     is a well in front of You.))
			     (attic (You are in the attic. There is a giant
			     welding torch in the corner.))))
    #+end_src
*** Describing the Location
    The way to look up data in an /alist/ is the =assoc= function.

    #+begin_src lisp :results value
      (assoc 'garden *nodes*)
    #+end_src

    We can define a wrapper function around =assoc= that will return
    the requested information only. Note the use of =cadr=.

    #+begin_src lisp :results value
      (defun describe-location (location nodes)
	(cadr (assoc location nodes)))
    #+end_src

    And now we can use it to return /only/ the description.

    Note that this function is /referentially transparent/: With the
    same input, it will produce the same output, and it does nothing
    outside of its scope and does not have side effects.

    This book does not use those words, merely relating this to the
    functional programming style.
    #+begin_src lisp :results value
      (describe-location 'living-room *nodes*)
    #+end_src
*** Describing the Paths
    We're going to store the paths in a separate global variable
    (another /alist/).

    #+begin_src lisp :results value
      (defparameter *edges* '((living-room (garden west door)
			       (attic upstairs ladder))
			      (garden (living-room east door))
			      (attic (living-room downstairs ladder))))
    #+end_src

    With this structure, we can now access things using a standard
    phrase.

    Note the use of a backtick to enable data mode here. This is
    necessary, because we are using something called /quasiquoting/,
    where we can flip back and forth between data mode and code mode.

    I personally think it's cool how it looks like a little lever on
    the outside of the parens, with up (not active) being in data mode
    and down (active) being in code mode.

    This flipping is one of the many benefits to working in symbols
    instead of directly in strings.
    
    #+begin_src lisp :results value
      (defun describe-path (edge)
	`(there is a ,(caddr edge) going ,(cadr edge) from here.))
    #+end_src

    We are then going to compose this function into one that lets us
    describe all the paths in a single location. That function will be
    =describe-paths=.

    It will do the following:

    1. Find the relevant edges.
    2. Convert the edges to descriptions.
    3. Join the descriptions.
       
    #+begin_src lisp :results value
      (defun describe-paths (location edges)
	(apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
    #+end_src

    Let's test that right away.

    #+begin_src lisp :results value
      (describe-paths 'living-room *edges*)
    #+end_src

    Let's step through the above-mentioned steps.
**** Find the Relevant Edges
     The inner part, =(cdr (assoc location edges))=, is the focus
     here.

     Because of our data structure (an /alist/), we can get the full
     list of edges for a specific room using =assoc=. And because of
     the structure of lists and the /way/ we stored the data in our
     /alist/, we can simply call =cdr= to extract the list of edges.
**** Convert the Edges to Descriptions
     Stepping out a bit, we'll now focus on =(mapcar #'describe-path
     result-from-step-1)=.

     The =mapcar= function takes a function and a list, and applies
     that function to each member of the list. According the the
     documentation, it can actually take more than one list, as well.

     #+begin_src lisp :results value
       (mapcar #'sqrt '(1 2 3 4 5))
     #+end_src

     =mapcar= is a /higher-order function/, which is a function that
     can take other functions as parameters.

     The =#'x= notation is a shorthand for =(function x)=. Calling
     functions as values in Common Lisp requires this, as Common Lisp
     is a /Lisp-2/ language: functions are in a different namespace
     than variables, and thus can have the same names. We'll discuss
     this difference, and namespaces in general, in depth in
     Chapter 16. Scheme, in contrast to Common Lisp, is a /Lisp-1/,
     which basically means there is only one namespace, and therefore
     only one instance of each name, function or otherwise.

     We are using =mapcar= to apply our =describe-path= function to
     each list of relevant edges.
**** Join the Descriptions
     Finally, we'll discuss the outmost part of the =describe-paths=
     function: =(apply #'append (result-from-step-2))=.

     We are joining all of the generated lists together, here. The
     =append= function does this, and we use it easily with another
     function, =apply=. The =apply= function passes each item in a
     supplied list to the target function, as opposed to =mapcar=,
     which applies a function to each item in a list in turn.

     Note, however, that for very large lists implementing aggregation
     this way may be inefficient, as =apply= passes each element in a
     separate call.
**** Wrapping Up
     This basic style, passing complicated data through several
     functions in turn, is a very common practice in Common Lisp, and
     Lisp in general. /Composability/ is core to the Lisp mindset.
*** Describing Objects at a Specific Location
    Similarly to above, we are going to use a global list to store the
    objects, and then store the locations of those objects in an
    /alist/.

    #+begin_src lisp :results value
      (defparameter *objects* '(whiskey bucket frog chain))
      (defparameter *object-locations* '((whiskey living-room)
					 (bucket living-room)
					 (chain garden)
					 (frog garden)))
    #+end_src

    To identify the objects in a current location, we are going to
    compose a big function chain again; this one will be called
    =objects-at=.

    Inside =objects-at=, we declare a local function using the
    =labels= function. It seems we've used the =labels= function
    before, but I failed to remember it. =labels= basically allows You
    to define local functions. Declaring functions locally here is
    useful because we will definitely not be using the functions
    outside of that scope, and therefore keep our environment cleaner.

    The =at-loc-p= function is just such a function, and that's why we
    declare it using =labels=. It will take the symbol for an object
    and return =t= or =nil= (using =eq=, as we are comparing symbols)
    regarding the objects presence at a location =loc=.

    The naming of the function =at-loc-p= ends with "-p" due to a
    naming convention in Lisp. Predicates (functions that return true
    or false) are usually named with a "p" suffix to make them easy to
    identify. This is also done in emacs, as I am aware.

    There is another function introduced here: =remove-if-not=. It
    returns a sequence of values without any that do not satisfy a
    specific predicate. Here, we are using our =at-loc-p= predicate on
    all of the objects =objs= supplied to the =objects-at= function.

    It's interesting to me the way that our local function =at-loc-p=
    uses the scope-wide available variable =obj-locs=. I would likely
    not allow this in my own code, as it makes =at-loc-p= less
    /referentially transparent/.

    #+begin_src lisp :results value
      (defun objects-at (loc objs obj-locs)
	(labels ((at-loc-p (obj)
		   (eq (cadr (assoc obj obj-locs)) loc)))
	  (remove-if-not #'at-loc-p objs)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (objects-at 'living-room *objects* *object-locations*)
    #+end_src

    We can then compose =objects-at= into a new function that is not
    dissimilar to the previous function =describe-paths=. This one
    will be called =describe-objects=.

    In this listing, We define a local function using =labels= again
    (kind of like a =let= for functions) called =describe-obj=, which
    forms a sentence describing the object's presence. We use
    /quasiquoting/ again for this. Then we call =objects-at= in the
    exact same way as we called =describe-path= in the other.

    #+begin_src lisp :results value
      (defun describe-objects (loc objs obj-loc)
	(labels ((describe-obj (obj)
		   `(you see a ,obj on the floor.)))
	  (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))
    #+end_src

    Let's test this too.

    #+begin_src lisp :results value
      (describe-objects 'living-room *objects* *object-locations*)
    #+end_src

    Woo!
*** Describing it All
    We're gonna put it all together now, and make a =look= function.

    We're going to track the player's current location using a global
    variable again. This one will be called, creatively, =*location*=.

    We'll initialize it to the living-room, as this will be the
    location of the player at the start of the game.
    
    #+begin_src lisp :results value
      (defparameter *location* 'living-room)
    #+end_src

    Now we can write the =look= function.

    Because of the use of global variables (i.e. variables outside of
    the scope of the function that are changed), this implementation
    is not functional. The choice here was to easily facilitate the
    player simply typing =look=.

    The components of the =look= function (the =describe-= functions,
    for instance) were all written in the functional style. I presume
    this one wasn't because it illustrates the difference between a
    functional approach and a non-functional approach.
    #+begin_src lisp :results value
      (defun look ()
	(append (describe-location *location* *nodes*)
		(describe-paths *location* *edges*)
		(describe-objects *location* *objects* *object-locations*)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (look)
    #+end_src
*** Walking Around in Our World
    We're going to make another non-functional function to walk around
    using our global variables.

    We first look up the available directions in the =*edges*=
    alist. We then feed this to the =find= function to locate the
    matching path. The =find= function searches a list for a matching
    item, and returns that item. This becomes the variable =next= (and
    =next= is =nil= if not found).

    The new part here is a /keyword parameter/, which lets You access
    special features a function can have in Common Lisp by passing in
    parameters to the end of the call. Here, we are using the /keyword
    parameter/ =:key=, which we use to ensure =find= matches the path
    (direction) with the =cadr= of the available paths, which it so
    happens will be our directions.

    We'll discuss the =:= prefix more in Chapter 7, but it seems right
    now to indicate /keyword parameters/. But the syntax for /keyword
    parameters/ is a name with a =:= prefix (like =:key=) followed by
    a value (like =#'cadr=).

    We then check =next= using =if= and Common Lisp's special handling
    of =false= and =nil=. If =next= has a value, then =if= moves the
    player. If not, that means the direction is impossible, and it
    tells the player as much.
    
    #+begin_src lisp :results value
      (defun walk (direction)
	(let ((next (find direction
			  (cdr (assoc *location* *edges*))
			  :key #'cadr)))
	  (if next
	      (progn (setf *location* (car next))
		     (look))
	      '(you cannot go that way.))))
    #+end_src

    Let's test it out.

    #+begin_src lisp :results value
      (walk 'west)
    #+end_src

    Right now, our program has a pretty big wart: You have to enter in
    the direction with a preceding quote. We're going to address this
    in the next chapter, by making a custom REPL specifically for
    playing text adventures.

    We could also use /macros/ to accomplish this in an unflavored
    Lisp REPL. We'll learn about htis approach in Chapter 16.
*** Picking up Objects
    Next, we're gonna enable picking up items.

    Basically, the concept will be that when You pick something up it
    will modify =*object-locations*= by pushing a new item to it,
    which will associate the object with a ='body= symbol. First,
    we'll check to ensure that the object is there to pick up by using
    =member= on the output of =objects-at=. If it isn't, we'll tell
    the user they can't do that. Our if structure will be =cond=,
    since it is the most versatile.

    #+begin_src lisp
      (defun pickup (object)
	(cond ((member object
		       (objects-at *location* *objects* *object-locations*))
	       (push (list object 'body) *object-locations*)
	       `(you are now carrying the ,object))
	      (t '(you cannot get that.))))
    #+end_src

    #+RESULTS:
    : PICKUP

    I'm honestly not a huge fan of this design, at least for now.. The
    global variables are not only a hotbed for unforeseen errors, but
    they seem as though they will only grow over time. Alists are only
    really efficient when small, and also, there is no utility I can
    see added to the program by maintaining a history like this.

    But, I understand the purpose pedagogically. We're using a new
    function, =push=, which inserts an item at the front of an
    existing list. I'm familiar with pushing and popping, so that
    makes sense to me. The interesting thing is that it dives into the
    implementation; =(push x *list*)= is described as identical to
    =(setf *list* (cons x *list*))=. The =setf= function here is like
    =setq=, but works with more structures than simply symbols.

    The growing alist of historical associations is apparently a
    common Lisp idiom. Because the =assoc= function returns the first
    result it finds, so long as You push new items to the front of the
    list it will appear to be a mutable value when it really is
    not. Interesting, and fairly functional, now that I've thought
    through it.

    We're now going to try out our =pickup= function.

    #+begin_src lisp
      (walk 'east)
      (pickup 'whiskey)
    #+end_src

    #+RESULTS:
    : (YOU ARE NOW CARRYING THE WHISKEY)

    It worked!
*** Checking our Inventory
    Checking our inventory is basically going to be a utility function
    to describe "objects at the 'body location".

    #+begin_src lisp
      (defun inventory ()
	(cons 'items- (objects-at 'body *objects* *object-locations*)))
    #+end_src

    #+RESULTS:
    : INVENTORY

    Let's try it out.

    #+begin_src lisp
      (inventory)
    #+end_src

    #+RESULTS:
    : (ITEMS- WHISKEY)

    This ends our exploration of a basic text adventure engine, for
    now. We will be adding a mechanism for actually manipulating
    objects (not just changing their locations) in Chapter 17.

    In the next chapter, we are going to improving the UI by
    implementing an actual parser instead of relying on plain lisp
    code.
*** What I've Learned
    We made a simple game engine.

    We can represent a world as a graph, with nodes and edges. You can
    store these items in an alist, which allows You to look up
    properties of symbols using =assoc=. You can use /Quasiquoting/ to
    insert bits of code into data, as opposed to the other way around
    (Quoting to insert small bits of data in code). We learned about
    /Higher Order Functions/ which accept functions as arguments, like
    =mapcar=. You can simulate mutation in an alist using =push= to
    add a redundant key with a new value, since =assoc= will always
    return the first result it finds.
** Chapter 6 - Interacting with the World: Reading and Printing in Lisp
   We begin by calling out that all of the code we've learned so far
   is self contained. We're specifically going to focus on UI, and
   make a command line for our game engine from Chapter 5. To do that,
   we need to print text to the screen, and read it from the user. The
   functions to accomplish this are =print= and =read=.
*** Printing to the Screen
    The =print= function prints things to the output, usually the
    screen.

    #+begin_src lisp :results output verbatim
      (print "foo")
      (progn (print "this")
	     (print "is")
	     (print "a")
	     (print "test"))
    #+end_src

    #+RESULTS:
    : 
    : "foo" 
    : "this" 
    : "is" 
    : "a" 
    : "test"
    
    They mention that, if You run the =print= command in a REPL, the
    result is shown twice: Once for the return value of the =print=
    command, and once for its side effect, which is printing the text
    that follows it with a newline *before* it and a space *after* it.

    If You don't want these other characters, You can instead use
    =prin1= (which is "prin" followed by the number 1, not the letter
    l) to print the arguments on one line.

    #+begin_src lisp :results output verbatim
      (prin1 "foo")
      (progn (prin1 "this")
	     (prin1 "is")
	     (prin1 "a")
	     (prin1 "test"))
      
    #+end_src

    #+RESULTS:
    : foo""this""is""a""test


    The =prin1= command is used a lot in more serious Lisp code,
    because it is simpler and does less, giving You more control. The
    =print= function is used more in this book due to its more
    intuitive use.
*** Saying Hello to the User
    This is a classic. We're going to greet the user.

    Our =say-hello= function will ask for the user's name and then
    respond by greating them.

    The =print= is executed first, and gives the user a prompt. Then,
    we set up a local variable (=name=) and =read= into it. It waits
    for a Return, and then sets the variable equal to what was
    input. Finally, we use the variable to print a greeting.
    
    #+begin_src lisp :results output
      (defun say-hello ()
	(print "Please type Your name:")
	(let ((name (read)))
	  (print "Nice to meet You, ")
	  (print name)))
    #+end_src

    #+RESULTS:

    Now, because we are asking for user input, =org-babel= doesn't
    actually complete the command for You (since it is waiting to read
    Your input.

    I was able to get this one working by interrupting the execution
    (C-g) and switching to the =*slime-repl sbcl*= buffer to type my
    name.

    This may be a road block w/r/t using =org-babel= for literate
    programming. I'll have to dive this futher in the future.
    #+begin_src lisp :results output
      (say-hello)
    #+end_src

    #+RESULTS:
    : 
    : "Please type Your name:" 
    : "Nice to meet You, " 
    : CHRISTOPHER 

    The above did make me pause for a week or so. However, eventually
    I reasoned out that input (that is, for the purposes of the above)
    is going to be a rare instance in this book outside of actually
    running the finished program. And /that/ I can do from the REPL.

    So, we are good to continue.

    However, we need to address something: Everything is currently
    surrounded by ="=. This is fine for now, but eventually I would
    like that not to be the case.

    I'm advised that, when I have an IO task in Lisp, I should start
    by asking myself if =print= or =read= can do the job. It will save
    a lot of trouble if I can use these two instead of any others.

    I'm also warned that =read= can be *dangerous* if used wrong. I'm
    assuming we'll come to those details soon, though there are some
    hyperlinks here I could follow.

    The following example is given to show how =read= and =print= can
    work almost identically when working with numbers as with strings.

    #+begin_src lisp :results output
      (defun add-five ()
	(print "Enter a Number: ")
	(let ((number (read)))
	  (print "When I add 5 I get:")
	  (print (+ number 5))))
    #+end_src

#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: land-of-lisp-notes
#+date: <2021-08-12 Thu>
#+author: rodnchr
#+email: rodnchr@ua6ff97dd3b1950.ant.amazon.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.50 (Org mode 9.4.6)
#+PROPERTY: header-args :results verbatim value replace
#+PROPERTY: header-args:dot :cmd neato
These are my notes while working through the LoL book, interpersed
with all of the code I copied during that work.

* Part I - Lisp is Power
** Chapter 1 - Getting Started with Lisp
   I mostly read through this chapter before taking notes. However, it
   mostly focuses on Common Lisp as a concept and the installation
   progress. I may come back at the end and take real notes, but for
   now I am comfortable leaving it as is.
   Here's the example on the second page.

   #+begin_src lisp
     (+ 3 (* 2 4 ))
   #+end_src

   The brief history outlines LISP as coming from a more mathematical
   background than a necessarily compsci background. John McCarthy
   created LISP in 1959. The goal was to make a programming language
   that was completely theoretical, but could produce elegant programs.

   It was apparently a fun project, nothing serious. Haha.


   #+begin_src lisp :results output
     (print "This File Contains")
     (print "Two Lines of Lisp")
   #+end_src

** Chapter 2 - Creating Your First Lisp Program
   We're going to be developing a guess-my-number game.
*** Defining Global Variables
   #+begin_src lisp
     (defparameter *small* 1)
     (defparameter *big* 100)
   #+end_src

   #+begin_src lisp :results output
     (print *small*)
     (print *big*)
   #+end_src

   The book goes on to talk about global variables, and the differences
   between defparameter (overwrites old value if it exists) and defvar
   (does not overwrite existing values).
*** Defining Global Functions
   #+begin_src lisp
     (defun guess-my-number ()
       (ash (+ *small* *big*) -1))
   #+end_src

   We've defined our first function.

   The ash fuction used here is for (a)rithmetic (s)hifting. We're
   using it because we are limiting our scope to whole numbers, and
   want to take the shortened average of our limits.

   This will take the binary representation of that sum and shift it
   right by one. This, in effect, halves the value: All of the bits
   move right, and we are in base 2.

   More generally, this operation can be mathematically expressed as
   floor(input*2^shift), with input being the first argument and shift
   being the second. (Note that we used a negative value here, and
   therefore took 2^-1, or 1/2: Halving the number.


   #+begin_src lisp
     (guess-my-number)
   #+end_src

*** Subfunctions
   This was the expected output.

   #+begin_src lisp
     (defun smaller ()
       (setf *big* (1- (guess-my-number)))
       (guess-my-number))

     (defun bigger ()
       (setf *small* (1+ (guess-my-number)))
       (guess-my-number))
   #+end_src

   Let's finish playing this round, now. My number will be 37.

   #+begin_src lisp
     (guess-my-number)
     (smaller)
     (bigger)
   #+end_src

   Not bad. Now, to reset it, we'll need a function that sets those
   global variables back to their starting values. I'm going to try to
   write it without looking at the book, and then compare.

   #+begin_src lisp
     (defun my-reset (small big)
       (setf *small* small)
       (setf *big* big)
       (guess-my-number))
   #+end_src

   Let's keep playing. New Number: 92.

   #+begin_src lisp
     (my-reset 1 100)
     (bigger)
     (bigger)
     (bigger)
     (smaller)
     (bigger)

   #+end_src

   We've done it! Time to review the book; I wonder how different it
   will be?

   #+begin_src lisp
     (defun start-over ()
       (defparameter *small* 1)
       (defparameter *big* 100)
       (guess-my-number))
   #+end_src

   I like mine better, since it lets You pick new bounds. But I
   understand why they kept it simple here.
*** Scope
   To end off this chapter, we are discussing scope. Local variables
   use the `let` function.

   #+begin_src lisp
     (let ((a 5)
           (b 6))
       (+ a b))
   #+end_src

   Once the let function ends, we can no longer reference those
   variables as they were defined. (+ a b) will no longer work.

   There are two similar functions for local functions, flet and
   labels.

   #+begin_src lisp
     (flet ((f (n)
              (+ n 10))
            (g (n)
              (- n 6)))
       (g (f 5)))

   #+end_src

   flet is the simpler one, which behaves much the way let does. It's
   big limitation is that it cannot define multiple functions that
   reference each other, or a function that calls itself. For either of
   those, we need to use labels.

   #+begin_src lisp
     (labels ((a (n)
                (+ n 5))
              (b (n)
                (+ (a n) 6)))
       (b 10))
   #+end_src

   One reason to use flet over labels would be to use a global function
   of the same name: In labels, it would instead refer to itself.
** Chapter 3 - Exploring the Syntax of Lisp Code
   This chapter starts off by explaining the difference (and
   connection) between syntax and semantics in both human and
   programming languages.
*** Syntax and Semantics
   /Syntax/ is the rules a piece of text needs to follow to be valid in
   whatever language it is written in.

   /Semantics/ is the underlying thought or action present in a piece
   of text.

   Two pieces of text can have the /different/ syntax, but /identical/
   semantics, if they are in different languages.

   *Having a simple syntax is a defining feature of the Lisp language.*

   A /Reader/ is the part of a Lisp compiler or interpreter that reads
   in the code. In Lisp, this is simpler than in any other major
   programming language.

   #+begin_src lisp
     (defun square (n)
       (* n n))
   #+end_src

   The above function, =square=, is used to examine this further.

   This is a /function declaration/, which creates a new function that
   takes a number and returns its square. It consists of exactly two
   parts: /Parentheses/, and /symbols/. These two parts are arranged in
   a set of /nested lists/ that create the function.

   This is important, because *Lisp only has one way of organizing bits
   of code: it uses /parentheses/ to organize /symbols/ into /lists/.*

   We are going to examine these ideas further.
*** Symbols

    In Lisp, a symbol is any stand alone word.

    They can be made up of letters ([A-Za-z]), numbers([0-9]), and
    symbols (+ - / * = < > ? ! _). They are case insensitive, though
    convention avoids typing in upper case.

    #+begin_src lisp
      (eq 'fooo 'FoOo)
    #+end_src

*** Numbers

    Lisp supports both integers and floating point numbers.

    #+begin_src lisp :results output
      (print (+ 1 1.0))
      (print (expt 53 53))
      (print (/ 2 3))
    #+end_src

    If You work with both integers and floating point numbers, the
    integers will become "poisoned" and a floating point number will be
    returned.

    Lisp is good with big numbers.

    Lisp also can return ratios (dividing integers) as well as decimal
    numbers (dividing floating point numbers).

*** Strings

    To indicate a string in Lisp, surround it with double quotes (").


    #+begin_src lisp
      (princ "Tutti Frutti")
    #+end_src

    (The =princ= function does /not/ output a newline, and is therefore
    less READable than the =print= function.)

    You can also include /escaped characters/ using standard backslash
    notation.

*** Code and Data Modes

 There are two modes in Lisp: /Code Mode/ and /Data Mode/.

 In /Code Mode/, lists need to be structured as a /form/: with the
 first item in the list being a /command/ and the rest being the
 /parameters/. For the form =(expt 2 3)=, =expt= is the command, and
 the parameters are the list =(2 3)=. It therefore results in =8=.

 #+begin_src lisp
   (expt 2 3)
 #+end_src

 When lisp reads the parameters, it stays in /Code Mode/. This way, You
 can nest forms indefinitely, as You may need to.

 #+begin_src lisp
   (expt 2 (+ 3 4))
 #+end_src

 *Inner forms are always executed before outer forms.*

 You can engage /Data Mode/ by placing a single quote (') in front of
 the leading parenthesis (like this: ='(expt 2 3)=). This tells Lisp to
 treat the enclosed data as a plain list: do /not/ evaluate any
 functions that may be inside.

*** Cons Cells
 Lists hold the program together, but what is the mortar that ties the
 bricks of symbols into a list? Cons Cells.

 [ ][ ]
  V  V

 Think of a Cons cell as a pair of boxes that can point to other
 things. Cons cells can point to numbers, strings, lists, or other cons
 cells; they are the true building blocks of the language. Everything
 else is an abstraction built on top of them.

 In brief, a cons cell can be thought of as similar to a linked list
 item.

*** Cons Function

 There are three basic functions for interacting with lists in Lisp:
 =cons=, =car=, and =cdr=.

 =cons= is how You link items together. It can link any two
 symbols. The second item is usually a list.

 #+begin_src lisp
   (cons 'chicken 'pork)
 #+end_src

 It returns the Cons cell it creates, printing it in the dotted pair
 notation: =(CHICKEN . CAT)=.

 If the second item is =nil=, then the list is a one-symbol list like
 =(CHICKEN)=. This is really still a cons cell in the form of =(CHICKEN
 . nil)=, but =nil= is used to end lists in Lisp. It's a special use.

 The result is shown as a list because Lisp always goes out of its way
 to hide the Cons cells if it can. Since a Cons cell with =nil= at the
 end is a list, it shows the list.

 The /empty list/, =()= is synonymous with =nil=.

 This is incidently why the second item in a call to =cons= is usually
 a list: This, in effect, adds the first item to the front of the
 already-properly-constructed list.

 #+begin_src lisp :results value list
   (cons 'pork (cons 'beef (cons 'chicken ())))
 #+end_src

 In short: *A chain of cons cells and a list are the same thing in
 Lisp*.

*** Car and Cdr
 Lists are just long chains of two item cells.

 The =car= function returns the first thing, and the =cdr= function
 returns the last thing.

 There are extension functions up to four deep, that allow for pulling
 specific data out of a list.

 #+begin_src lisp
   (cadadr '((perl c cpp) (lisp clojure haskell) scheme))
 #+end_src

 In short, we've learned:

 - Parentheses are there to keep syntax down.
 - Lists are just groups of connected cons cells.
 - You can create lists using =cons=.
 - You can inspect parts of a list using =car= and =cdr=.


*** List
    Common Lisp has many functions built on top of the basic three
    (=cons=, =car=, and =cdr=).

    One convenient one is =list=. It does all of the work to build a
    list at once, as that is a common pattern.

    #+begin_src lisp
      (list 'pork 'beef 'chicken)
    #+end_src

*** Nested Lists
    Lists can contain other lists.

    The first two commands are equivalent to each of the last two
    commands, in that they all isolate the first nested list and then
    return a list consisting of the final two elements of the first
    list.
    #+begin_src lisp :results output
      (print (car '((peas carrots tomatoes) (pork beef chicken))))
      (print (cdr '(peas carrots tomatoes)))
      (print (cdr (car '((peas carrots tomatoes) (pork beef chicken)))))
      (print (cdar '((peas carrots tomatoes) (pork beef chicken))))
    #+end_src

    You can also create the initial list from above using /solely/
    =cons=, which is really what the above is doing behind the scenes.

    #+begin_src lisp
      (cons
       (cons 'peas
             (cons 'carrots
                   (cons 'tomatoes
                         ())))
       (cons
        (cons 'pork
              (cons 'beef
                    (cons 'chicken
                          ())))
        ()))
    #+end_src

    Here are some c*r functions operating on the list: ='((peas carrots
    tomatoes) (pork beef chicken) duck)=. Note that these only go 4
    levels deep: Anything deeper than that will need to be written by
    hand.
    #+begin_src lisp :results output
      (print (cddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (caddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cddar '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cadadr '((peas carrots tomatoes) (pork beef chicken) duck)))
    #+end_src

*** What we've Learned
    We discussed basic Lisp syntax, including the benefits of
    parentheses, lists, and cons/car/cdr.
* Part II - Lisp is Symmetry
** Chapter 4 - Making Decisions with Conditions
   Now we're finally learning some flow control.
*** Symmetry of nil and ()
    *Lisp commands and data structures are imbued with symmetry in
    every conceivable way.*
*** Empty Equals False
    Lisp philosophy strongly emphasizes lists. Empty Lists are treated
    as a false value when evaluating a condition.

    #+begin_src lisp
      (if '()
          'i-am-true
          'i-am-false)
    #+end_src

    Any non-empty list will evaluate to true.

    #+begin_src lisp
      (if '(1)
          'i-am-true
          'i-am-false)
    #+end_src

    This allows us to process /recursion/ very easily, by taking items
    from the front of a list and sending the rest back to the function
    in the tail call.

    Here's a classic lisp function that returns the length of a list
    using the recursion process above.

    #+begin_src lisp
      (defun my-length (list)
        (if list
            (1+ (my-length (cdr list)))
            0))

      (my-length '(list with four symbols))
    #+end_src

    Lists in Lisp are recursive to begin with (conses of conses of
    conses) so consuming a list this way is a natural and efficient
    progression. However, calling Yourself recursively can sometime
    impact the speed of a fuction. There is a special kind of
    recursion to mitigate this problem that will be discussed in
    *Chapter 14*.
*** The Four Disguises of ()
    The empty list is not only /something/ that evaluates to
    false. =()= is the *only* false value in Common Lisp. *Any value
    not equivalent to an empty list will be considered a true value.*

    #+begin_src lisp :results output
      (print (eq '() nil))
      (print (eq '() ()))
      (print (eq '() 'nil))
    #+end_src

    ='()=, =()=, ='nil=, and =nil= are all equavalent, and all
    represent an empty list. =()= and =nil= are special forms, because
    they seem to violate the rules of Lisp syntax. However, they are
    all in the Common Lisp spec: ='()= is a basic, empty list. ='nil=
    exists due to the requirements of the Common Lisp spec to provide
    a common target for falsity. =nil= evaluates to itself, or rather
    ='nil=, which is treated as an empty list. =()= evaluates
    evaluates to ='nil= due to a requirement in the spec for =()= and
    =nil= to be treated the same.

    This is different from Scheme. In Scheme, empty lists are simply
    empty lists, and are not treated as values with falsity. However,
    in Common Lisp, they are.
*** The Conditionals: if and Beyond
    The standard =if= command exists in lisp.

    The format of the function is basically:

    (if <condition> <then statement> <else statement>)

    However, the else statement is optional. In the case of an omitted
    else statement being lead to, then nothing is executed and the
    value =nil= is returned.
    #+begin_src lisp :results output
      (if (= (+ 1 2) 3)
          (print "yup")
          (print "nope"))
      (if (= (+ 1 2) 4)
          (print "yup")
          (print "nope"))
      (if (= (+ 1 2) 3)
          (print "yup"))
      (if (= (+ 1 2) 4)
          (print "yup"))
    #+end_src

    As =nil= is equivalent to an empty list, it then becomes obvious
    that testing for an empty list is important. And, because an empty
    list is treated as =false=, it is trivial to test for one.

    #+begin_src lisp :results output
      (if '(1)
          (print "Not Empty")
          (print "Empty"))
      (if '()
          (print "Not Empty")
          (print "Empty"))
      (if (if (= (+ 1 2) 4)
              (print "yup"))
          (print "This won't happen.")
          (print "The original value was nil."))
    #+end_src

    Usually, when a function is executed in lisp, all of the
    expressions after a function are evaluated before the function
    itself is. However, =if= doesn't follow that rule. This makes
    things like the following possible, which includes an illegal
    command (dividing by zero).

    #+begin_src lisp
      (if (oddp 5)
          'odd-number
          (/ 1 0))
    #+end_src

    Since only the chosen expression is evaluated, the =(/ 1 0)= else
    statement is never touched, and therefore does not cause an error.

    This rulebreaking behavior is possible because the =if= function
    is considered a /special form/, which gives it special privileges
    (like not preevaluating all of its arguments). *Conditional
    Statements in Lisp are Typically Special Forms.* Special forms are
    usually commands that are baked into a language.

    Note: /Macros,/ which we'll learn about in Chapter 16, are
    something like user-created special forms.

    The other important thing to note about =if= is that it is only
    capable of doing one thing, since only one expression (either
    =then= or =else=) is ever evaluated. It is impossible to do two
    things with a single =if=.

    This is considered a good thing in Functional Programming, though
    in other paradigms is a limitation that may be fairly prominent.

    Of course, there is a way around it. There's another special form,
    =progn=, that allows You to wedge in more commands to that single
    expression that gets evaluated. Per the definition in the
    [[http://clhs.lisp.se/Body/s_progn.htm][HyperSpec]], as each form is evaluated, all return values are
    ignored aside from the final form's. Per the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/progn.html][Elisp Equivalent]], the
    preceding forms are evaluated primarily for their side effects
    (hence why functional programming may not make much use of
    =progn=.

    #+begin_src lisp :results output
      (defvar *number-was-odd* nil)
      (if (oddp 5)
          (progn (setf *number-was-odd* t)
                 (print *number-was-odd*)
                 (print "odd number"))
          'even-number)
    #+end_src

*** Beyond if: when and unless
    There are a number of commands that include an /implicit
    progn/. We'll look at two here, =when= and =unless=.

    With =when=, all enclosed expressions are evaluated /when/ the
    condition is true. With =unless=, all enclosed expressions are
    evaluated /unless/ the condition is true.

    The trade off with these two functions is they will only return
    =nil= and do nothing when the condition is the opposite of their
    expected state: That is, when =when= has a false condition and
    when =unless= has a true condition, nothing will happen and the
    statement will return =nil=.

    #+begin_src lisp :results output
      (when (oddp 5)
        (print "Yup")
        (print "5 is indeed Odd."))
      (unless (oddp 4)
        (print "Yup")
        (print "4 is not Odd."))
      (when (oddp 4)
        (print "Yup")
        (print "5 is indeed Odd."))
      (unless (oddp 5)
        (print "Yup")
        (print "4 is not Odd."))
    #+end_src

*** The Command that Does it All: cond
    If You don't want to compromise, and want the greatest degree of
    control over Your flow, =cond= does not have any
    trade-offs... Aside from its complexity.

    *The =cond= form is the classic way to do branching in Lisp.*

    It allows implicit progns, can handle more than one branch, and
    can even evaluate multiple conditions.

    The body of a =cond= statement uses a layer of parentheses to
    separate its branches. The first expression in each parantesized
    part contains the conditional statement for making that branch
    active. The conditions are always checked from the top down, so
    *the first successful branch defines the behavior of a =cond=
    statement.*

    To define a base case, it is a common idiom to include =t= as the
    final conditional statement, so that if that branch is reached it
    is always executed.

    This reminds me a lot of a switch-case statement from C++. Or
    rather, how I wish the switch-case statement from C++ behaved.

    Here's an example, where the supplied person's name is compared to
    two defined names and a base case before the branch is
    chosen. Note that the branches can contain more than one
    expression, due to the implicit =progn=.
    #+begin_src lisp :results output
      (defvar *arch-enemy* nil)n
      (defun pudding-eater (person)
        (cond
          (
           (eq person 'henry)
           (setf *arch-enemy* 'stupid-lisp-alien)
           (print "Curse You Lisp alien - You ate my pudding!")
           )
          (
           (eq person 'johnny)
           (setf *arch-enemy* 'useless-old-johnny)
           (print "I hope You choked on my Pudding, Johnny.")
           )
          (
           t
           (print "Why'd You eat my pudding, stranger?")
           )))
      (pudding-eater 'johnny)
      (print *arch-enemy*)
      (pudding-eater 'george-clooney)
    #+end_src

*** Branching with case
    As I noted myself, the =cond= example reminded me of switch-case
    in C++. It is so commonly used to simply compare a single input to
    a variety of cases, that there is a special form for that specific
    use case: the =case= form.

    The benefits to using the =case= form are mostly to reduce the
    syntactic complexity in a program. There are also (depending on
    the implementation used) a variety of efficiency optimizations
    that may come with using =case= over =cond=.

    *Warning:* Because the =case= command uses =eq= internally to
     compare values, =case= is usually only used for branching on
     symbol values. It cannot be used to branch on string values,
     among other things. The next section goes over this in more
     detail.

     Below is the same program as in the =cond= section, but edited to
     use =case= instead.

     #+begin_src lisp :results output
      (defun pudding-eater-case (person)
        (case person
          (
           (henry)
           (setf *arch-enemy* 'stupid-lisp-alien)
           (print "Curse You Lisp alien - You ate my pudding!")
           )
          (
           'johnny
           (setf *arch-enemy* 'useless-old-johnny)
           (print "I hope You choked on my Pudding, Johnny.")
           )
          (
           otherwise
           (print "Why'd You eat my pudding, stranger?")
           )))
      (pudding-eater-case 'johnny)
      (print *arch-enemy*)
      (pudding-eater-case 'george-clooney)
     #+end_src
*** Using the Stealth Conditionals: and and or
    The conditionals =and= and =or= are simple mathematical
    operators. They let You chain conditionals together.

    The =and= form lets You check multiple conditionals at the same
    time, and only returns true if they are all true.

    The =or= form lets You check multiple conditionals at the same
    time, and only returns false if none of them are true.

    #+begin_src lisp
      (print (and (oddp 7) (oddp 5) (oddp 3)))
      (print (and (oddp 6) (oddp 5) (oddp 3)))
      (print (or (oddp 8) (oddp 7) (oddp 6)))
      (print (or (oddp 8) (oddp 6) (oddp 4)))
    #+end_src

    However, due to the way Common Lisp handles =true= and =false=, we
    can use =and= and =or= for conditional behavior.

    Here is an example of how we can do this with =or=. We define a
    global variable =*is-it-even*= and =or= the command to set it to
    =t= with the numbers we are checking.

    #+begin_src lisp
      (defparameter *is-it-even* nil)
      (print (or (oddp 4) (setf *is-it-even* t)))
      (print *is-it-even*)
    #+end_src

    However, if we do the same with an odd number, the global variable
    remains unchanged.

    #+begin_src lisp
      (defparameter *is-it-even-2* nil)
      (print (or (oddp 5) (setf *is-it-even-2* t)))
      (print *is-it-even-2*)
    #+end_src

    This is because Common Lisp uses /Shortcut Boolean Evaluation/,
    which basically means that once Lisp determines an earlier
    statement in a list of =or= values is true, it returns and leaves
    the rest unevaluated. In short, *You can use =or= to run a command
    /only/ if all prior conditionals were false.*

    You can use =and= similarly, however the shortcut for =and= is the
    opposite: *You can use =and= to run a command /only/ if all prior
    conditionals were true.*

    It is considered clean code to avoid this, however. If You want
    the cleanest, most maintainable code possible, only use these
    functions on expressions that are designed to return a Boolean
    value.
*** Using Functions that Return More than Just the Truth
    Let's take a look at another function: the =member= command can be
    used to check if an item exists in a list.

    #+begin_src lisp
      (if (member 1 '(3 4 1 5))
                  (print "One is in the List")
                  (print "One is not in the List"))
    #+end_src


    However, the /way/ it returns true is unconventional and
    Lisp-driven:

    #+begin_src lisp
      (print (member 1 '(3 4 1 5)))
    #+end_src

    The main question for any Lisper when they write a function that
    returns true or false is: *Is there anything else I could return
    other than just t?*

    This is because *all non-nil values evaluate to true*. Returning
    more than t is essentially free.

    The main reason the function =member= returns the tail of the
    original list and not just the found value on a true result is a
    specific edge case: looking for /nil/ in a list (which would
    evaluate to false if it returned just /nil/.

    There is another notable fuction for how it uses a rich return
    value: =find-if=.

    #+begin_src lisp
      (print (find-if #'oddp '(2 4 5 6)))
      (if (find-if #'oddp '(2 4 5 6))
          (print "There is an odd number.")
          (print "There is no odd number."))

    #+end_src

    The =find-if= function takes another function as an argument (as
    it is a higher-order function, to be discussed in greater depth in
    chapters 7 and 14) and returns the first (if any) member that
    causes the supplied function to evaluate to true from the supplied
    list.

    Note, however, that the edge case mentioned above (returning
    /nil/) is not accounted for here.

    #+begin_src lisp
      (print (find-if #'null '(2 4 nil 6)))
    #+end_src

    If used as a conditional statement, a true result will evaluate to
    false as well as a false result. This is bad, but a necessary evil
    for =find-if= to work consistently.
*** Comparing Stuff: eq, equal, and More
    Asymmetry is present when comparing things, unfortunately.

    There are a number of functions to compare things; the most
    commonly used ones are: =equal=, =eq=, ===, =string-equal=, and
    =equalp=. Knowing when to use each is important.
**** Conrad's Rule of Thumb for Comparing Stuff
     When in doubt, following these two steps will usually get You by.

     1. Use =eq= when comparing symbols.
     2. Use =equal= for everything else.
**** Eq
     The =eq= function is the simplest comparison function, which
     makes it very fast. However, it struggles with items that are not
     symbols.

     That said, using =eq= is a must if the values being compared are
     known to be symbols.

     #+begin_src lisp
       (defparameter *fruit* 'apple)
       (cond ((eq *fruit* 'apple) (print "It's an Apple"))
             ((eq *fruit* 'orange) (print "It's an Orange")))
     #+end_src

     It's worth noting that =eq= can be used to compare conses as
     well, though it will only return true for the *exact same call*
     to cons. Even if the cons looks similar after the fact, it will
     return /nil/.
**** Equal
     If You aren't dealing with two symbols, or such a case cannot be
     guaranteed by the function You are writing, it is better to use
     =equal=. It tells You when two things are /isomorphic/, meaning
     that they look the same. It works for all basic Lisp datatypes.

     #+begin_src lisp
       (print (equal 'apple 'apple))
       (print (equal (list 1 2 3) (list 1 2 3)))
       (print (equal '(1 2 3) (cons 1 (cons 2 (cons 3 ())))))
       (print (equal 5 5))
       (print (equal 2.5 2.5))
       (print (equal "foo" "foo"))
       (print (equal #\a #\a))
     #+end_src

     The =equal= function can compare most things, so it is a safe
     choice, if an inefficient one.
**** Eql
     The =eql= command is very similar to =eq=, but it also handles
     the comparison of numbers and characters (leaving out things like
     strings and lists).

     #+begin_src lisp
       (print (eql 'foo 'foo))
       (print (eql 3.4 3.4))
       (print (eql #\a #\a))
     #+end_src
**** Equalp
     The =equalp= command is very similar to =equal=, except it can
     handle more difficult comparisons, like strings with varying
     capitalizations or integers to floats.

     #+begin_src lisp
       (print (equalp "Bob Smith" "bob smith"))
       (print (equalp 0 0.0))
     #+end_src
**** Others
     The === function handles numbers only. The =string-equal= handles
     strings only. The =char-equal= function handles characters only.

     There are others as well, but they are not common. There are a
     bunch of different function.
*** What We've Learned
    This chapter was all about branching through conditionals: How
    =nil=, ='nil=, =()=, and ='()= are all the same, and all treated
    as false. List Eaters are really easy to make. Lisp uses lazy
    evaluation. Using =cond= lets You do really cool conditionals. And
    comparing things is complicated.
** Chapter 5 - Building a Text Game Engine
   This is interesting: This chapter begins by stressing that handling
   text is not a computer's strength. As someone who has grown up
   belly-deep in ASCII and UTF, this is an interesting statement to
   wrestle with. I live my life through plaintext, for the most part,
   and yet this chapter considers text to be a necessary evil best
   kept to a minimum.
*** The Wizard's Adventure Game
    As is obvious by the Chapter title, we are making a game here. In
    this game, You are a wizard's apprentice, exploring that wizard's
    house. The game will not be complete until Chapter 17, but when it
    is You will be able to solve puzzles and win a magical donut.
**** Basic Requirements

    There is a picture that describes the world we are creating. Three
    areas (rooms): a living room, an attic, and a garden. There is a
    ladder connecting the living room to the attic, and a door
    connecting the garden to the living room. There is no immediate
    path between the garden and the attic.

    We'll need a few actions as well as the world around us: Looking,
    Moving, Taking Objects, and Performing Actions on Objects Held. In
    this chapter, we are going over the first three of these.

    When Looking Around (the first action), there are three kinds of
    things to see in any location:

    - Scenery
    - Exits
    - Objects
*** Describing the Scenery with an Association List
    As our world is simple, we can describe the scenery using one
    global variable.

    Below, we define this variable: =*nodes*=. It contains the list
    and description of our three places. In essence, it gives us a way
    to look up a piece of data (the description) attached to a
    specific /key/ (in this case, the room name). This is called an
    /Association List/, or an /alist/, and will be discussed more in
    Chapter 7.

    One thing to note is the absence of strings. The data below is
    encoded entirely in more fundamental datatypes: Only Symbols and
    Lists. This is to illustrate that *by keeping Your source data
    structures free from assumptions regarding the output format from
    the start, Your coding can take full advantage of Your programming
    language.* We'll be formatting these lists and symbols into text
    in the next chapter.

    Note however that this is not a limitation of Lispâ€”You can work
    directly with strings if You prefer (and will be, in Chapter 11).
    #+begin_src lisp
      (defparameter *nodes* '((living-room (You are in the living-room. A
      wizard is snoring loudly on the couch.))
                             (garden (You are in a beautiful garden. There
                             is a well in front of You.))
                             (attic (You are in the attic. There is a giant
                             welding torch in the corner.))))
    #+end_src

*** Describing the Location
    The way to look up data in an /alist/ is the =assoc= function.

    #+begin_src lisp :results value
      (assoc 'garden *nodes*)
    #+end_src

    We can define a wrapper function around =assoc= that will return
    the requested information only. Note the use of =cadr=.

    #+begin_src lisp :results value
      (defun describe-location (location nodes)
        (cadr (assoc location nodes)))
    #+end_src

    And now we can use it to return /only/ the description.

    Note that this function is /referentially transparent/: With the
    same input, it will produce the same output, and it does nothing
    outside of its scope and does not have side effects.

    This book does not use those words, merely relating this to the
    functional programming style.
    #+begin_src lisp :results value
      (describe-location 'living-room *nodes*)
    #+end_src

*** Describing the Paths
    We're going to store the paths in a separate global variable
    (another /alist/).

    #+begin_src lisp :results value
      (defparameter *edges* '((living-room (garden west door)
                               (attic upstairs ladder))
                              (garden (living-room east door))
                              (attic (living-room downstairs ladder))))
    #+end_src

    With this structure, we can now access things using a standard
    phrase.

    Note the use of a backtick to enable data mode here. This is
    necessary, because we are using something called /quasiquoting/,
    where we can flip back and forth between data mode and code mode.

    I personally think it's cool how it looks like a little lever on
    the outside of the parens, with up (not active) being in data mode
    and down (active) being in code mode.

    This flipping is one of the many benefits to working in symbols
    instead of directly in strings.

    #+begin_src lisp :results value
      (defun describe-path (edge)
        `(there is a ,(caddr edge) going ,(cadr edge) from here.))
    #+end_src

    We are then going to compose this function into one that lets us
    describe all the paths in a single location. That function will be
    =describe-paths=.

    It will do the following:

    1. Find the relevant edges.
    2. Convert the edges to descriptions.
    3. Join the descriptions.

    #+begin_src lisp :results value
      (defun describe-paths (location edges)
        (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
    #+end_src

    Let's test that right away.

    #+begin_src lisp :results value
      (describe-paths 'living-room *edges*)
    #+end_src

    Let's step through the above-mentioned steps.
**** Find the Relevant Edges
     The inner part, =(cdr (assoc location edges))=, is the focus
     here.

     Because of our data structure (an /alist/), we can get the full
     list of edges for a specific room using =assoc=. And because of
     the structure of lists and the /way/ we stored the data in our
     /alist/, we can simply call =cdr= to extract the list of edges.
**** Convert the Edges to Descriptions
     Stepping out a bit, we'll now focus on =(mapcar #'describe-path
     result-from-step-1)=.

     The =mapcar= function takes a function and a list, and applies
     that function to each member of the list. According the the
     documentation, it can actually take more than one list, as well.

     #+begin_src lisp :results value
       (mapcar #'sqrt '(1 2 3 4 5))
     #+end_src

     =mapcar= is a /higher-order function/, which is a function that
     can take other functions as parameters.

     The =#'x= notation is a shorthand for =(function x)=. Calling
     functions as values in Common Lisp requires this, as Common Lisp
     is a /Lisp-2/ language: functions are in a different namespace
     than variables, and thus can have the same names. We'll discuss
     this difference, and namespaces in general, in depth in
     Chapter 16. Scheme, in contrast to Common Lisp, is a /Lisp-1/,
     which basically means there is only one namespace, and therefore
     only one instance of each name, function or otherwise.

     We are using =mapcar= to apply our =describe-path= function to
     each list of relevant edges.
**** Join the Descriptions
     Finally, we'll discuss the outmost part of the =describe-paths=
     function: =(apply #'append (result-from-step-2))=.

     We are joining all of the generated lists together, here. The
     =append= function does this, and we use it easily with another
     function, =apply=. The =apply= function passes each item in a
     supplied list to the target function, as opposed to =mapcar=,
     which applies a function to each item in a list in turn.

     Note, however, that for very large lists implementing aggregation
     this way may be inefficient, as =apply= passes each element in a
     separate call.
**** Wrapping Up
     This basic style, passing complicated data through several
     functions in turn, is a very common practice in Common Lisp, and
     Lisp in general. /Composability/ is core to the Lisp mindset.
*** Describing Objects at a Specific Location
    Similarly to above, we are going to use a global list to store the
    objects, and then store the locations of those objects in an
    /alist/.

    #+begin_src lisp :results value
      (defparameter *objects* '(whiskey bucket frog chain))
      (defparameter *object-locations* '((whiskey living-room)
                                         (bucket living-room)
                                         (chain garden)
                                         (frog garden)))
    #+end_src

    To identify the objects in a current location, we are going to
    compose a big function chain again; this one will be called
    =objects-at=.

    Inside =objects-at=, we declare a local function using the
    =labels= function. It seems we've used the =labels= function
    before, but I failed to remember it. =labels= basically allows You
    to define local functions. Declaring functions locally here is
    useful because we will definitely not be using the functions
    outside of that scope, and therefore keep our environment cleaner.

    The =at-loc-p= function is just such a function, and that's why we
    declare it using =labels=. It will take the symbol for an object
    and return =t= or =nil= (using =eq=, as we are comparing symbols)
    regarding the objects presence at a location =loc=.

    The naming of the function =at-loc-p= ends with "-p" due to a
    naming convention in Lisp. Predicates (functions that return true
    or false) are usually named with a "p" suffix to make them easy to
    identify. This is also done in emacs, as I am aware.

    There is another function introduced here: =remove-if-not=. It
    returns a sequence of values without any that do not satisfy a
    specific predicate. Here, we are using our =at-loc-p= predicate on
    all of the objects =objs= supplied to the =objects-at= function.

    It's interesting to me the way that our local function =at-loc-p=
    uses the scope-wide available variable =obj-locs=. I would likely
    not allow this in my own code, as it makes =at-loc-p= less
    /referentially transparent/.

    #+begin_src lisp :results value
      (defun objects-at (loc objs obj-locs)
        (labels ((at-loc-p (obj)
                   (eq (cadr (assoc obj obj-locs)) loc)))
          (remove-if-not #'at-loc-p objs)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (objects-at 'living-room *objects* *object-locations*)
    #+end_src

    We can then compose =objects-at= into a new function that is not
    dissimilar to the previous function =describe-paths=. This one
    will be called =describe-objects=.

    In this listing, We define a local function using =labels= again
    (kind of like a =let= for functions) called =describe-obj=, which
    forms a sentence describing the object's presence. We use
    /quasiquoting/ again for this. Then we call =objects-at= in the
    exact same way as we called =describe-path= in the other.

    #+begin_src lisp :results value
      (defun describe-objects (loc objs obj-loc)
        (labels ((describe-obj (obj)
                   `(you see a ,obj on the floor.)))
          (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))
    #+end_src

    Let's test this too.

    #+begin_src lisp :results value
      (describe-objects 'living-room *objects* *object-locations*)
    #+end_src

    Woo!
*** Describing it All
    We're gonna put it all together now, and make a =look= function.

    We're going to track the player's current location using a global
    variable again. This one will be called, creatively, =*location*=.

    We'll initialize it to the living-room, as this will be the
    location of the player at the start of the game.

    #+begin_src lisp :results value
      (defparameter *location* 'living-room)
    #+end_src

    Now we can write the =look= function.

    Because of the use of global variables (i.e. variables outside of
    the scope of the function that are changed), this implementation
    is not functional. The choice here was to easily facilitate the
    player simply typing =look=.

    The components of the =look= function (the =describe-= functions,
    for instance) were all written in the functional style. I presume
    this one wasn't because it illustrates the difference between a
    functional approach and a non-functional approach.
    #+begin_src lisp :results value
      (defun look ()
        (append (describe-location *location* *nodes*)
                (describe-paths *location* *edges*)
                (describe-objects *location* *objects* *object-locations*)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (look)
    #+end_src

*** Walking Around in Our World
    We're going to make another non-functional function to walk around
    using our global variables.

    We first look up the available directions in the =*edges*=
    alist. We then feed this to the =find= function to locate the
    matching path. The =find= function searches a list for a matching
    item, and returns that item. This becomes the variable =next= (and
    =next= is =nil= if not found).

    The new part here is a /keyword parameter/, which lets You access
    special features a function can have in Common Lisp by passing in
    parameters to the end of the call. Here, we are using the /keyword
    parameter/ =:key=, which we use to ensure =find= matches the path
    (direction) with the =cadr= of the available paths, which it so
    happens will be our directions.

    We'll discuss the =:= prefix more in Chapter 7, but it seems right
    now to indicate /keyword parameters/. But the syntax for /keyword
    parameters/ is a name with a =:= prefix (like =:key=) followed by
    a value (like =#'cadr=).

    We then check =next= using =if= and Common Lisp's special handling
    of =false= and =nil=. If =next= has a value, then =if= moves the
    player. If not, that means the direction is impossible, and it
    tells the player as much.

    #+begin_src lisp :results value
      (defun walk (direction)
        (let ((next (find direction
                          (cdr (assoc *location* *edges*))
                          :key #'cadr)))
          (if next
              (progn (setf *location* (car next))
                     (look))
              '(you cannot go that way.))))
    #+end_src

    Let's test it out.

    #+begin_src lisp :results value
      (walk 'west)
    #+end_src

    Right now, our program has a pretty big wart: You have to enter in
    the direction with a preceding quote. We're going to address this
    in the next chapter, by making a custom REPL specifically for
    playing text adventures.

    We could also use /macros/ to accomplish this in an unflavored
    Lisp REPL. We'll learn about htis approach in Chapter 16.
*** Picking up Objects
    Next, we're gonna enable picking up items.

    Basically, the concept will be that when You pick something up it
    will modify =*object-locations*= by pushing a new item to it,
    which will associate the object with a ='body= symbol. First,
    we'll check to ensure that the object is there to pick up by using
    =member= on the output of =objects-at=. If it isn't, we'll tell
    the user they can't do that. Our if structure will be =cond=,
    since it is the most versatile.

    #+begin_src lisp
      (defun pickup (object)
        (cond ((member object
                       (objects-at *location* *objects* *object-locations*))
               (push (list object 'body) *object-locations*)
               `(you are now carrying the ,object))
              (t '(you cannot get that.))))
    #+end_src

    I'm honestly not a huge fan of this design, at least for now.. The
    global variables are not only a hotbed for unforeseen errors, but
    they seem as though they will only grow over time. Alists are only
    really efficient when small, and also, there is no utility I can
    see added to the program by maintaining a history like this.

    But, I understand the purpose pedagogically. We're using a new
    function, =push=, which inserts an item at the front of an
    existing list. I'm familiar with pushing and popping, so that
    makes sense to me. The interesting thing is that it dives into the
    implementation; =(push x *list*)= is described as identical to
    =(setf *list* (cons x *list*))=. The =setf= function here is like
    =setq=, but works with more structures than simply symbols.

    The growing alist of historical associations is apparently a
    common Lisp idiom. Because the =assoc= function returns the first
    result it finds, so long as You push new items to the front of the
    list it will appear to be a mutable value when it really is
    not. Interesting, and fairly functional, now that I've thought
    through it.

    We're now going to try out our =pickup= function.

    #+begin_src lisp
      (walk 'east)
      (pickup 'whiskey)
    #+end_src

    It worked!
*** Checking our Inventory
    Checking our inventory is basically going to be a utility function
    to describe "objects at the 'body location".

    #+begin_src lisp
      (defun inventory ()
        (cons 'items- (objects-at 'body *objects* *object-locations*)))
    #+end_src

    Let's try it out.

    #+begin_src lisp
      (inventory)
    #+end_src

    This ends our exploration of a basic text adventure engine, for
    now. We will be adding a mechanism for actually manipulating
    objects (not just changing their locations) in Chapter 17.

    In the next chapter, we are going to improving the UI by
    implementing an actual parser instead of relying on plain lisp
    code.
*** What I've Learned
    We made a simple game engine.

    We can represent a world as a graph, with nodes and edges. You can
    store these items in an alist, which allows You to look up
    properties of symbols using =assoc=. You can use /Quasiquoting/ to
    insert bits of code into data, as opposed to the other way around
    (Quoting to insert small bits of data in code). We learned about
    /Higher Order Functions/ which accept functions as arguments, like
    =mapcar=. You can simulate mutation in an alist using =push= to
    add a redundant key with a new value, since =assoc= will always
    return the first result it finds.
** Chapter 6 - Interacting with the World: Reading and Printing in Lisp
   We begin by calling out that all of the code we've learned so far
   is self contained. We're specifically going to focus on UI, and
   make a command line for our game engine from Chapter 5. To do that,
   we need to print text to the screen, and read it from the user. The
   functions to accomplish this are =print= and =read=.
*** Printing to the Screen
    The =print= function prints things to the output, usually the
    screen.

    #+begin_src lisp :results output verbatim
      (print "foo")
      (progn (print "this")
             (print "is")
             (print "a")
             (print "test"))
    #+end_src

    They mention that, if You run the =print= command in a REPL, the
    result is shown twice: Once for the return value of the =print=
    command, and once for its side effect, which is printing the text
    that follows it with a newline *before* it and a space *after* it.

    If You don't want these other characters, You can instead use
    =prin1= (which is "prin" followed by the number 1, not the letter
    l) to print the arguments on one line.

    #+begin_src lisp :results output verbatim
      (prin1 "foo")
      (progn (prin1 "this")
             (prin1 "is")
             (prin1 "a")
             (prin1 "test"))

    #+end_src


    The =prin1= command is used a lot in more serious Lisp code,
    because it is simpler and does less, giving You more control. The
    =print= function is used more in this book due to its more
    intuitive use.
*** Saying Hello to the User
    This is a classic. We're going to greet the user.

    Our =say-hello= function will ask for the user's name and then
    respond by greating them.

    The =print= is executed first, and gives the user a prompt. Then,
    we set up a local variable (=name=) and =read= into it. It waits
    for a Return, and then sets the variable equal to what was
    input. Finally, we use the variable to print a greeting.

    #+begin_src lisp :results output
      (defun say-hello ()
        (print "Please type Your name:")
        (let ((name (read)))
          (print "Nice to meet You, ")
          (print name)))
    #+end_src

    Now, because we are asking for user input, =org-babel= doesn't
    actually complete the command for You (since it is waiting to read
    Your input.

    I was able to get this one working by interrupting the execution
    (C-g) and switching to the =*slime-repl sbcl*= buffer to type my
    name.

    This may be a road block w/r/t using =org-babel= for literate
    programming. I'll have to dive this futher in the future.

    The above did make me pause for a week or so. However, eventually
    I reasoned out that input (that is, for the purposes of the above)
    is going to be a rare instance in this book outside of actually
    running the finished program. And /that/ I can do from the REPL.

    So, we are good to continue.

    However, we need to address something: Everything is currently
    surrounded by ="=. This is fine for now, but eventually I would
    like that not to be the case.
*** Starting with print and read
    I'm advised that, when I have an IO task in Lisp, I should start
    by asking myself if =print= or =read= can do the job. It will save
    a lot of trouble if I can use these two instead of any others.

    I'm also warned that =read= can be *dangerous* if used wrong. I'm
    assuming we'll come to those details soon, though there are some
    hyperlinks here I could follow.

    The following example is given to show how =read= and =print= can
    work almost identically when working with numbers as with strings.

    #+begin_src lisp :results output
      (defun add-five ()
        (print "Enter a Number: ")
        (let ((number (read)))
          (print "When I add 5 I get:")
          (print (+ number 5))))
    #+end_src

    Here are some examples of printing various types of values.

    Note that the types of output are:
    - An Integer
    - A Float
    - A Symbol (all caps due to case-blindness)
    - A String
    - A character

    Also note the quoting. We could omit the quoting in each case
    aside from the symbol (since it could refer to a function or
    value).

    #+begin_src lisp :results output
      (print '3)
      (print '3.4)
      (print 'foo)
      (print '"foo")
      (print '#\a)
    #+end_src

    But there are of course a few special cases here. First, with
    symbols, You can create case sensitive symbols using the =|=
    character, =|LikeThis|=. Piped symbols can even have punctuation
    in them: =|So, this is a VERY valid symbol, too!|= is a good
    example.

    And finally, we can print single characters using the =#\=
    prefix. There are three common non-visible characters mentioned in
    the book: =#\newline=, =#\tab= and =#\space=. They are pretty
    self-explanatory.

    As for =read=, it behaves exactly the same way, except instead of
    printing them, it reads them.
*** Reading and Printing Stuff the Way Humans Like It
    The =say-hello= function defined above is pretty bad at what it
    actually is supposed to do.

    We're shown the following table:

    | For       | Printing | Reading |
    |-----------+----------+---------|
    | Computers | =print=  | =read=  |
    | Humans    | =princ=  | =???=   |

    Remember our problem from earlier: All strings were double-quoted,
    and it looked very stilted when used. The =princ= function behaves
    as humans might expect, as opposed to the more "correct" way a
    computer might prefer it to. Strings are unquoted. Characters are
    unprefixed.

    #+begin_src lisp :results output
      (print '3)
      (princ '3)
      (print '3.4)
      (princ '3.4)
      (print 'foo)
      (princ 'foo)
      (print '"foo")
      (princ '"foo")
      (print '#\a)
      (princ '#\a)
      (progn (princ #\newline)
             (princ "This Sentence will be interrupted")
             (princ #\newline)
             (princ "by an annoying newline character."))
    #+end_src

    The thing to note here is that while =print= prints anything in a
    way unique to its internal representation (and therefore, it can
    be =read= back /into/ that internal representation easily),
    =princ= is a one-way street: It cannot easily be stored again, and
    breaks the symmetry this Part is focusing on.

    The obvious course of action is to come up with arbitrary rules
    for how the computer should interpret input. One (fairly naive,
    but still useful) approach would be: "Let the user type whatever
    they want until they hit enter, then treat everything they typed
    as a string." The function that does this is called =read-line=,
    and we can use it to complete our refinement of the =say-hello=
    function.

    The below =say-hello= implementation allows the user to enter
    /any/ name, including whitespace and punctuation, up to a
    newline. It also doesn't print needless quotes around everything,
    nor does it isolate the name on a line by itself.

    #+begin_src lisp
      (defun say-hello()
        (princ "Please type Your name: ")
        (let ((name (read-line)))
          (princ "Nice to meet You, ")
          (princ name)
          (princ '#\newline)))
    #+end_src
*** The Symmetry Between Code and Data in Lisp
    Lisp can also treat program code and data interchangeablly. A
    language that uses the same data structures to store both data and
    program code is said to be /Homoiconic/.

    We discussed these two modes briefly in Chapter 3. Here's that
    example again.

    #+begin_src lisp :results output
      (princ '(+ 1 2))  ; data mode
      (princ #\newline) ; \n
      (princ (+ 1 2))   ; code mode
    #+end_src

    In Chapter 5, we used a /quasiquote/ when defining the
    =describe-path= function. This was another example.

    But these features are fairly limited in their abilities. If we
    want to execute arbitrarily generated/collected code (as in a
    parser), we need another function. This function is =eval=.

    #+begin_src lisp
      (defparameter *foo* '(+ 1 2))
      (eval *foo*)
    #+end_src

    The =eval= command is powerful and simple, but easy to cause
    problems with, like a vorpal sword or midas ring. Improper use can
    easily pose a security risk. Experienced Lispers will only rarely
    use =eval=; many of the things inexperienced Lispers might use
    =eval= for can be done with Macros instead, which we'll discuss
    further in Chapter 16.

    The bottom line is that *Quoting, Quasiquoting, =eval=, and Macros
    allow You to take advantage of Lisp's Homoiconicity in Your code.*
*** Adding a Custom Interface to Our Game Engine
    Thus far, we've been using the Lisp REPL to enter our game
    commands. It's amazing how well this works for prototyping our
    game.

    Now we are going to make our own interface.
**** Setting up a custom REPL
     Defining a REPL in Lisp is very easy. This will work exactly as
     the standard REPL:

     #+begin_src lisp
       (defun game-repl ()
         (loop (print (eval (read)))))
     #+end_src

     That's not the most useful REPL, though. Let's try harder.

     In this version, we capture the player input using =game-read=
     into a variable called =cmd=. This lets us handle quit. So long
     as the user did not type "quit", it evals and prints using
     =game-eval= and =game-print= the command in =cmd=. Finally, it
     recurses.

     #+begin_src lisp
       (defun game-repl ()
         (let ((cmd (game-read)))
           (unless (eq (car cmd) 'quit)
             (game-print (game-eval cmd))
             (game-repl))))
     #+end_src
**** game-read
     We'll need to define our "game-" prefixed functions. Let's start
     with =game-read=.

     Our =game-read= function starts by using =read-from-string=,
     which is similar to =read= but works from a string instead of
     input, to assign the typed commands to the variable =cmd= as a
     list (so "walk east" becomes "(walk east)" and is assigned to
     =cmd=). Then, we define a simple local function with =flet= (not
     =labels=, since we aren't recursing or anything) that will quote
     all parameters in our new list. It does this by =cons= -ing the
     =car= of =cmd= with a =mapcar= of the =cdr= of =cmd= using
     =quote-it=, our local function.

     #+begin_src lisp
       (defun game-read ()
         (let ((cmd (read-from-string
                     (concatenate 'string "(" (read-line) ")"))))
           (flet ((quote-it (x)
                    (list 'quote x)))
             (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
     #+end_src

     That is a lot of functions, but I understood them all!

     And upon testing, it indeed works.

     It should probably have exception handling, because it is
     accepting input from the user (Mismatched parens is the situation
     referenced in the book). We'll go over that in Chapter 13.
**** game-eval
     Now, we need to define how we're going to actually /run/ the
     input.

     Our main goal here is limiting the functions that the user can
     call with their input. We'll do this by use of a global variable
     =*allowed-commands*=.

     Before reading the explanation, I want to take a crack at
     explaining how this works.

     Basically, it takes an S-Expression in the form of a list. It
     checks the =car= of that list to see if it is an Allowed Command
     (that is, if it is a member of the =*allowed-commands*=
     global). If it is, it runs =eval= on it. Otherwise, it tells the
     user it does not know the command supplied.

     #+begin_src lisp
       (defparameter *allowed-commands* '(look walk pickup inventory))
       (defun game-eval (sexp)
         (if (member (car sexp) *allowed-commands*)
             (eval sexp)
             '(i do not know that command.)))
     #+end_src

     I got the explanation correct!

     This is fairly basic protection. There is more to learn in the
     section called "The Dangers of read and eval".
**** game-print
     Finally, we need a way to print things in a normal,
     human-readable way. The most obvious thing we can do to work
     towards this goal is to print the correct case of each letter
     (uppercase the start of sentances, lowercase everything else).

     The =game-print= function should take a list of symbols, and
     print a properly-formatted string. The same technique used here
     can be used to generate any kind of text, such as HTML Code
     (we'll be doing something similar in Chapter 17).

     These functions are kind of intimidating. Here we go.

     I am not confident enough to parse this on my own, I don't
     think. But I'll try.

     So, first, =tweak-text=. Takes three arguments, =lst=, =caps=,
     and =lit=. So long as =list= is not =nil=, it assigns the =car=
     of =lst= to =item=, and stores the rest of =lst= in =rest=.

     We then enter a =cond= which always ends with us recursing, using
     =rest= as the new =lst= (in other words, popping off =item=).

     The =cond= has a number of branches; I'm not sure what most of
     them do.

     The first takes a " " input and =cons= es it with the
     rest of the text.

     The second checks to see if the text is punctuation, and if so,
     =cons= es it with the rest, but passing =t= to the variable
     =caps= (which would otherwise be =nil=).

     If the text is a double-quote, it does /not/ =cons= it to the
     list and recurses, flipping =lit=, whatever that variable means
     (literal?).

     The next branch checks =lit=. If it is not =nil=, it conses
     whatever the current item is to the list and then recurses,
     turning =caps= nil.

     It then checks both =caps= and =lit=. If either are true, it
     conses the item after upcasing it, recursing with =caps= as nil.

     Finally, the default case =t= will always run if nothing else
     does. It will conse the /downcased/ item with the list, and
     recurse passing =nil= to both =caps= and =lit=.

     Logically, I don't see a case where =lit= can be true for the
     =or= condition, so I don't know why that's included.

     As this is a recursive function, it will continue to recurse
     until there is only an empty list left (which is the same as
     =nil=).

     Now, =game-print=. Takes a list.

     I don't know what =coerce= does. Sounds ominous. Looking it up in
     the Hyperspec, it seems to create a new symbol of a specific type
     from some other symbol.

     Using that definition:

     We start by printing the list out as a string. We then cut off
     the leading and following "(", ")", and " " that might be
     present, giving us just the string itself.

     We then turn /that/ string into a list. Which is odd, since it
     may have started as a list? Maybe this is for safety.

     We feed this list to =tweak-text= as =lst=, with =t= for =caps=
     and =nil= for =lit=. So, =caps= starts as =t=.

     After that, we =coerce= the resulting list into a string, and
     =princ= that for the user.

     Finally, we call =fresh-line=, which is one of the functions that
     will output a '\n'.

     #+begin_src lisp
       (defun tweak-text (lst caps lit)
         (when lst
           (let ((item (car lst))
                 (rest (cdr lst)))
             (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
                   ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
                   ((eq item #\") (tweak-text rest caps (not lit)))
                   (lit (cons item (tweak-text rest nil lit)))
                   ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
                   (t (cons (char-downcase item) (tweak-text rest nil nil)))))))

       (defun game-print (lst)
         (princ (coerce (tweak-text (coerce (string-trim "() "
                                                         (prin1-to-string lst))
                                            'list)
                                    t
                                    nil)
                        'string))
         (fresh-line))
     #+end_src

     Okay, there were a few things I got somewhat wrong, but that's
     because I'm new.

     First, the =lit= flag is so we can /escape/ parts of a string
     with quotes! This lets us use things that Lisp might not like,
     like non-standard caps or commas.

     Next, the list -> string -> list is so we can using =string-trim=
     on the sentence before processing it.

     Finally, we are working /character-by-character/ here. I did not
     realize the delimiter was only a single character; I wonder how
     we got that way. Maybe this is another benefit of =coerce=?
*** Try Out Our Fancy New Game Interface
    Let's try it out. Make sure to run the subtrees for both Chapter 5
    and Chapter 6, then switch to the connected SLIME buffer.

    It's difficult to say how happy it made me to walk around in that
    little world I built.

    And even better, I understood so much of the tools I used to do
    so.

    We'll expand this game out again in Chapter 17. But for now, it
    may be time to move on to something else for a while.
*** The Dangers of read and eval
    Avoid these two commands. You can never be sure that a Lisp
    program using =eval= or =read= is completely safe from a malicious
    hacker. One method of attack we did not even touch on here is
    /reader macros/, which will work and let the user execute
    arbitrary code in our Lisp REPL.

    Just avoid them if You can.
*** What I've Learned
    Created a Custom Text Adventure REPL to use with our engine.

    =print= and =read= let You directly communicate with the user.

    Other IO functions are not as elegant, but are friendlier for
    humans.

    /Homoiconic/ programming languages store program code and data in
    a similar format. In Lisp, the main features that provide
    /Homoiconicity/ are /Quoting/, /Quasiquoting/, =eval=, and
    /Macros/.

    It's easy to write Your own REPL.

    It's simple to transform Your internal Lisp data into new
    forms. This makes it easy to encapsulate presentation from the
    details of the data.
** Chapter 6.5 - Lambda: A Function So Important It Deserves Its Own Chapter
   The =lambda= function is the most important function in Lisp.

   It lets You create functions without giving them a name. This is
   possible since functions are /first class values/ in Lisp, and can
   be passed around the same way values can.
** Chapter 7 - Going Beyond Basic Lists
   In this chapter, we're going to expand our knowledge of Lists and
   List Manipulation passed the basics.
*** Exotic Lists
    Lists are built using /cons cells/, which are small data
    structures that allow You to link together two pieces of data. The
    right slot of the last item in the chain should contain =nil=.

    Here is how to use cons cells to make a list of the numbers 1, 2,
    and 3.

    Note how the =cons= cells are absent from the printed list. This
    is a convenience feature for humans, they are still there.

    #+begin_src lisp
      (cons 1 (cons 2 (cons 3 nil)))
    #+end_src

**** Dotted Lists
    Suppose when we build a list we don't use a consistent string of
    =cons= cells. What happens then?

    This is a /dotted list/, which is a list that does not end with
    the expected =nil=, but instead ends with some other value.

    #+begin_src lisp
      (cons 1 (cons 2 3))
    #+end_src

    /Dotted Lists/ aren't useful in and of themselves, and shouldn't
    be used to store data in a normal program. However, they may
    appear emergently in code, as a side effect of using =cons= cells
    directly.

    The dot notation used in /dotted lists/ is actually an alternative
    syntax for =cons=, but only in /data mode/. We could make lists
    like this if we wanted:

    #+begin_src lisp
      `(1 . (2 . (3 . nil)))
    #+end_src

**** Pairs
     A common use for /dotted lists/ in Lisp is /pairs/. This is
     convenient (because You can now use =car= and =cdr= to interact
     with the pair members) and efficient (only one =cons= cell is
     needed to store the pair). I have heard the term /dotted pair/
     before, but it isn't used in this book, at least yet. It /is/
     mentioned, however, that You can use these for storing x/y
     coordinates or a key/value pair. Here's a pair of numbers:

     #+begin_src lisp
       (cons 2 3)
     #+end_src

     We'll revisit pairs when we discuss /Association Lists/ again.
**** Circular Lists
     What if, instead of =nil=, the last cell in a list pointed to the
     first cell?

     This creates a /Circular List/. It's important to set
     =*print-circle*= to =t= before using a circular list, or You may
     get stuck in an infinite loop during printing.

     We can easily make a circular list using =setf=. The ability to
     do things like this will be explored more in Chapter 9. For now,
     here is a circular list of 1, 2, 3, 1, 2, 3 repeating forever.

     #+begin_src lisp
       (setf *print-circle* t)
       (defparameter foo '(1 2 3))
       (setf (cdddr foo) foo)
     #+end_src

     This notation denotes /self-referential/ values, and is a clever
     but esoteric way to print an infinite loop to screen. However,
     the more complex the notation, the harder it is to grok, so try
     to keep these to a minimum.
**** Association Lists
     There is a particularly useful data structure called an
     /association list/, where key-value pairs are stored in a single
     list. These can be built out of =cons= cells in a simple way:
     Note the use of /dotted pairs/.

     #+begin_src lisp
       (defparameter *drink-order* '((bill . double-espresso)
                                     (lisa . small-drip-coffee)
                                     (john . medium-latte)))
     #+end_src

     This is so common in Lisp that the function =assoc= is named for
     it. Use it to look up information: Alone, it gives the pair. With
     =car=, the key. With =cdr=, the value. It searches the whole
     list, from the beginning, for the first match.

     #+begin_src lisp
       (cdr (assoc 'lisa *drink-order*))
     #+end_src

     The fact that it goes for the first match means that, to update a
     value, it is common to simply push a new value with an identical
     key onto the list. This is beneficial because it gives the full
     histogram of the variable's state over time, and is therefore
     more immutable than simply updating the value would be. The
     drawback is that, as list sizes grow, /alists/ are impractical
     and slow: The more pairs You have, the more items of the list
     need to be processed on each lookup, and the longer it will take
     to do so. The book recommends keeping /alists/ under 12 keys, and
     using them for prototyping (and replacing them once a program
     matures).

     #+begin_src lisp
       (push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
     #+end_src

     #+begin_src lisp
       (cdr (assoc 'lisa *drink-order*))
     #+end_src

     We'll discuss in Chapter 9 the perfomance limitations of
     list-based data structures.
*** Coping with Complicated Data
    =Cons= cells are great for list-like data structures, and are many
    Lispers go-to when performance isn't the main constraint. If
    compiling Your program, structures made of =cons= cells may still
    be a good choice: *Lisp compilers can often reduce a change to a
    cons cell to a single assembly instruction.*
**** Visualizing Tree-Like Data
     *As discussed in Chapter 3, the data and code of a Lisp program
     is represented with syntax expressions.* These are nested lists
     with hierarchical symbols in their =car=.

     Here is how we might use them to represent a house.

     #+begin_src lisp
       (defparameter *house* '((walls
                                (mortar
                                 (cement)
                                 (water)
                                 (sand))
                                (bricks))
                               (windows
                                (glass)
                                (frame)
                                (curtains))
                               (roof
                                (shingles)
                                (chimney))))
     #+end_src

     The fact that it is made up of nested lists makes it easy to
     visualize the hierarchy, here: Walls are made of bricks and
     mortar, which is made up of cement, water, and sand.

     Tree-Like data can naturally be expressed this way. XML is a
     reinvention of this concept, from a Lisp perspective.

     However, non-Tree-Like data is harder to visualize. The example
     specifically given is a Mathematical Graph.
**** Visualizing Graphs
     In mathematics, a graph is nodes connected by edges. Each item
     may have more data involved, too.

     We used something similar to this in Chapter 5: The wizard's
     house was a /directed graph/. We chose to store it in two
     /alists/: one for the nodes, and one for the edges. I believe I
     commented on how this was unmaintainable and sloppy code, which
     is nice to hear that the book agrees. Here they are again,
     renamed to new, unique variables. We're going to use a tool to
     make visualizing this data easier next.

     #+begin_src lisp
       (defparameter *wizard-nodes* '((living-room (you are in the
                                      living-room. a wizard is snoring loudly
                                      on the couch.))
                                      (garden (you are in a beautiful
                                      garden. there is a well in front of
                                      you.))
                                      (attic (you are in the attic. there is
                                      a giant welding torch in the
                                      corner.))))
       (defparameter *wizard-edges* '((living-room (garden west door)
                                       (attic upstairs ladder))
                                       (garden (living-room east door))
                                      (attic (living-room downstairs
                                      ladder))))
     #+end_src

*** Creating a Graph
    We are going to be using =graphviz= [[https://graphviz.org/][Link]] to make graphs from our
    data. I'm warned that =clisp= is the implementation used in this
    book, and therefore I may need to alter the commands used for
    =sbcl=.
**** Testing Graphviz
    The =graphviz= program is one I toyed around with in the past, but
    I'm glad that we are using it here. I always wanted to use it to
    help in planning my software, and I am happy to find that we're
    doing that in Lisp. Yet another things that points me towards this
    wonderful language.

    Below is a /digraph/, or a /directed graph/, that points from a to
    b to c. We're using the =neato= command from graphviz to turn the
    below markup into a visual graph. The =neato= command is described
    as, "the default tool to use if the graph is not too large (about
    100 nodes) and you donâ€™t know anything else about it" on the
    =graphviz= website.

    #+begin_src dot :file ./imgs/example-of-dot.png
      digraph {
              a->b->c;
      }
    #+end_src


    I also note that, due to =org-babel=, my workflow is greatly
    simplified: It will compile the code into a named image in the
    repo and then embed it in the file itself, so long as I have
    =(org-toggle-inline-images)= set to true.
**** Creating Graphs with Lisp
     Now we are going to create graphs with and from Lisp.

     We will need to:

     1. Convert the identifiers of all /nodes/ to dot format.
     2. Convert the /edges/ connecting these /nodes/.
     3. Generate the labels for every /node/ and /edge/.
***** Converting Node Identifiers
      First we need to convert the node identifers into dot
      identifiers. We'll write a function called =dot-name= for this.

      Looking at this before reading the explanation: We are taking an
      expression, substituting all non-alphanumerics characters with
      =#\_=, which I believe is a literal underscore, and then =prin1=
      ing that as a return. On second glance, I think I have the order
      reversed there: We are calling =prin1-to-string= first, to
      convert the symbol into a string, and then subbing out
      non-alphanumeric characters before returning.

      This was correct!

      For the reasoning behind it: DOT format identifiers can only
      contain letters, numbers, and underscores. This is a naive way
      to ensure that the names are created safely. It's brought up
      that this will assume that no nodes will differ only by
      non-alphanumberic characters (e.g. =foo!= and =foo?= would both
      be =foo_= here, causing a collision).

      We are using a few new functions here, =substitute-if=,
      =complement=, and =alphanumericp=.

      The =substitute-if= function substitues values based on the
      result of a test (or /predicate/) function (it also works on
      lists!). The =alphanumericp= function is one such /predicate/
      function (note the -p suffix) that tests for whether a value is
      alphanumeric. However, we want to replace all values that are
      /not/ alphanumeric, which is where the =complement= function
      comes in: it takes a function and returns its opposite (probably
      limited to /predicate/ functions, then).

      NOTE: There is also a =substitute-if-not= function, but all
      =-not= functions are considered deprecated, and should not be
      used.

      #+begin_src lisp :noweb-ref graph-util
        (defun dot-name (exp)
          (substitute-if
           #\_
           (complement #'alphanumericp)
           (prin1-to-string exp)))
      #+end_src

      Here are some examples of how the =dot-name= function works.

      #+begin_src lisp :results output verbatim
        (print (dot-name 'living-room))
        (print (dot-name 'foo!))
        (print (dot-name 24))
      #+end_src
***** Adding Labels to Graph Nodes
      We'll now focus on convering the labels for the nodes.

      The label will consist of two parts:

      1. The name of the /node/.
      2. The data linked to the /node/ from the =*node*= /alist/.


      The main issue here is avoiding label overflow (too much text in
      the label).

      We're going to use a global variable =*max-label-length*= to
      ensure that the text doesn't get too long. If the text /is/ too
      long, we'll display 27 characters of it with a "..."
      suffix. And, if there is no input, we'll return "".

      We're also using a new function, =write-to-string=. It is very
      similar to =prin1-to-string=. The main difference seems to be
      the /keyword parameters/ that =write-to-string= supports.

      /Keyword parameters/ are flags supported by certain Lisp
      functions to let You choose specific parameters to pass in
      (instead of setting them all every time). =:pretty nil= means to
      /not/ clean up the string before writing it. Without that
      /keyword parameter/, =write-to-string= would do things like
      placing new-lines in the string, or indentation.

      #+begin_src lisp :noweb-ref graph-util
        (defparameter *max-label-length* 30)

        (defun dot-label (exp)
          (if exp
              (let ((s (write-to-string exp :pretty nil)))
                (if (> (length s) *max-label-length*)
                    (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
                    s))
              ""))
      #+end_src
***** Generating DOT Information for the Nodes
      Now that we have both identifiers and labels for nodes handled,
      let's compose them into a single function that works with our
      data as it already is.

      Our function will take our /alist/ of nodes, and output the DOT
      information to encode them.

      It uses =mapc= to go through every node in =nodes= and =princ=
      prints the dot format to the screen. The main difference between
      =mapcar= and =mapc= is that =mapc= does /not/ return the
      transformed list.

      We're using the console as an intermediary here, which is a
      common paradigm in Lisp. It lets You easily debug issues in the
      code, as You can see the output on the screen in the REPL (or in
      org-babel).

      #+begin_src lisp :noweb-ref graph-util
        (defun nodes->dot (nodes)
          (mapc (lambda (node)
                  (fresh-line)
                  (princ (dot-name (car node)))
                  (princ "[label=\"")
                  (princ (dot-label node))
                  (princ "\"];"))
                nodes))
      #+end_src


      We can use this function on our =*wizard-nodes*= /alist/, as a
      test.

      Note how we are not interested in the return value of the
      function, here, but only its output. *Lispers would say we are
      only interested in the /side effects/ of this function.*


      #+begin_src lisp :results output verbatim
        (nodes->dot *wizard-nodes*)
      #+end_src

      It works!
***** Converting Edges into DOT Format
      This will be strikingly similar to the former function
      =node->dot=, but for the =edges= data.

      #+begin_src lisp :noweb-ref graph-util
        (defun edges->dot (edges)
          (mapc (lambda (node)
                  (mapc (lambda (edge)
                          (fresh-line)
                          (princ (dot-name (car node)))
                          (princ "->")
                          (princ (dot-name (car edge)))
                          (princ "[label=\"")
                          (princ (dot-label (cdr edge)))
                          (princ "\"];"))
                        (cdr node)))
                edges))
      #+end_src

      And here's an example:

      #+begin_src lisp :results output verbatim
        (edges->dot *wizard-edges*)
      #+end_src

      It's already easier to visualize the data, but let's continue.
***** Tying it all together
      The last step is composing the above functions into a single
      function that will output the DOT info for the entire structure.

      #+begin_src lisp :noweb-ref graph-util
        (defun graph->dot (nodes edges)
          (princ "digraph{")
          (nodes->dot nodes)
          (edges->dot edges)
          (princ "}"))
      #+end_src

      Note how only the most top-level markup is saved for the above
      function. All else is within one of the other functions, which
      are purely functional (aside from outputting their data to the
      screen, I suppose).

      Let's use it on our /alists/!

      #+name: wizard-dot-info
      #+begin_src lisp :results output verbatim
        (graph->dot *wizard-nodes* *wizard-edges*)
      #+end_src

      Woo! This is *amazing*, as my focus is text manipulation. That
      was understandable and easy.
**** Turning the DOT Info Into a Picture
***** Org Babel Aside
      This is an aside, not part of the book.

      My main workflow in Common Lisp will be Emacs and SLIME, using
      Org-Babel as the main way I execute code. I want to test how
      this will work for me before using the example in the book to
      learn about system calls and stuff.

      We can use the =:var= header for this.

      #+begin_src dot :var input=wizard-dot-info :file ./imgs/wizard-info.png
        $input
      #+end_src
***** Using Lisp
      Now we will do it the way the book wants, by saving the output
      to a file and then running the command on that file.

      This is where the differences between [[https://clisp.sourceforge.io/][CLISP]] and [[http://www.sbcl.org/][SBCL]] began. I
      worked around them by looking online; a [[https://www.reddit.com/r/learnlisp/comments/9dxa80/package_ext_doesnt_exist_w_extshell/][Reddit thread]] pointed me
      to a [[https://kofno.github.io/2012/11/20/land-of-lisp-sbcl.html][website]] which pointed to a [[https://github.com/kofno/land-of-lisp][repo]] that had a [[https://github.com/kofno/land-of-lisp/blob/master/chapter-7/graph-util.lisp][file]] with the
      answer.

      The main difference here was the call to =ext:shell=, which had
      to be replaced as it was CLISP-specific. SBCL has a few options
      for this, but as IO is not needed apart from running the
      command, the repo used =sb-ext:run-program=. I think that that
      is a good choice.

      #+begin_src lisp :noweb-ref graph-util
        (defun dot->png (fname thunk)
          (with-open-file (*standard-output*
                           fname
                           :direction :output
                           :if-exists :supersede)
            (funcall thunk))
          (sb-ext:run-program "dot" `("-Tpng" "-O" ,fname) :search T))

      #+end_src

      This is also our introduction to something called /thunks/.
***** Using Thunks
      A /thunk/ or /suspension/ is a /nullary function/ (small
      function with zero arguments) that holds a computations we don't
      want to run until later.

      In =dot->png=, we use the function which will generate our DOT
      info as a /thunk/ that will be run when we are ready.

      This is a common technique in non-functional Lisp: Print stuff
      to the console, wrap it in a /thunk/, and then redirect the
      output from the console to where it needs to be. However, as
      we'll discuss in Chapter 14, this is eschewed by Functional
      Lispers due to it relying on side effects.
***** Writing to a file
      We're using the =with-open-file= function to write data to a
      file.

      The first item passed to =with-open-file= will become the name
      of a /stream/, which is a special datatype in Common Lisp. The
      second is a string, which will be the filename. The others are
      all keyword parameters: We are specifying that it is an output
      stream, and that we don't care if there is already a file,
      overwrite it with only the data specified.

      #+begin_src lisp
        (with-open-file (my-stream
                         "text/testfile.txt"
                         :direction :output
                         :if-exists :supersede)
          (princ "Hello File!" my-stream))
      #+end_src

      And we can see that it worked.

      #+begin_src bash :results output verbatim
        cat text/testfile.txt
      #+end_src
***** Creating a Stream
      All printing functions can accept a stream as an optional
      parameter. If supplied, the functions print to the stream
      instead of the console.

     The scope of the streams created by =with-open-file= is the block
     within =with-open-file=, much like the variables defined with
     =let=.

     We'll be looking at streams more closely in Chapter 12.
***** Understanding Keyword Parameters
      The name of a /keyword parameter/ is always a symbol beginning
      with a colon. This is because they are /keyword symbols/, which
      are symbols which always refer to themselves. In other words,
      they are immutable and self-referential.

      They make a funny reference to a cigar being just a cigar, which
      I appreciated.
***** Capturing the Console Output
      In =dot->png= we send data to the file using
      =*standard-output*=, which is a dynamic variable referring to
      stdout.

      Basically, if anything prints to stdout in the thunk, that
      output is redirected to the file we've opened. It does this by
      overriding the global variable =*standard-output*=, which
      directs output to stdout, to the stream we define /under the
      same name/.

      This is not unlike using =let= to redefine a global variable in
      a smaller scope. We're just doing it with output targets. And
      because we are redefining the target for standard output, /all/
      output is routed to the file by default, with no other changes.
**** Creating a Picture of Our Graph
     We need to finally compose everything into one neat function.

     Our function will take a filename, an /alist/ of nodes, and an
     /alist/ of edges, write the DOT info to a file of that filename,
     and then run =neato= on that file to create the image.

     #+begin_src lisp :noweb-ref graph-util
       (defun graph->png (fname nodes edges)
         (dot->png fname
                   (lambda ()
                     (graph->dot nodes edges))))
     #+end_src


     Calling the =graph-dot= function as a lambda in the thunk is an
     example of /delayed computation/. Such a thing allows us to call
     a function after a stream has been opened, for instance. It
     allows us to ensure everything is set up before we move forward.

     Let's create our file!

     #+begin_src lisp
       (graph->png "imgs/wizard.dot" *wizard-nodes* *wizard-edges*)
     #+end_src

     To see it, I've referenced where the image (wizard.dot.png)
     should have been created here.

     [[./imgs/wizard.dot.png]]


     It worked!

     It's mentioned that this can be very valuable for debugging, but
     it also will be good for data modeling as well as other aspects
     of my programming life.
*** Creating Undirected Graphs
    A graph with arrows on its edges is called a /directed graph/.

    It is useful for visualizing flow and responsibility.

    However, sometimes we need to travel between edges in a
    disorganized way, for instance when back and forth motion is
    common. This is when /undirected graphs/ are better, as they are
    less busy and easier to understand.

    We're going to add undirected versions of each of the above
    functions.

    While these are very similar to the directed functions, there are
    a few key differences:

    1. We only need to establish an edge between two nodes once. So,
       we are using =maplist= (a function like =mapcar=, except it
       acts on the entirety of the list instead of just the =car= of
       the list before popping off the first element and repeating) to
       check if the edge's destination appears later in the list. If
       so, it skips the first connection, and just writes the last
       one. It checks this using =(assoc (car edge) (cdr lst))=.

    2. In =ugraph->dot=, we use "graph" instead of "digraph", as this
       is not a directional graph. Otherwise it is identical to
       =graph->dot=.

    3. Because we designed =dot->png= to accept different functions as
       the /thunk/, we don't need to rewrite it for this change. So,
       we'll just make a new wrapper function that automatically plugs
       our new function in as the /thunk/.

    #+begin_src lisp :noweb-ref graph-util
      (defun uedges->dot (edges)
        (maplist (lambda (lst)
                   (mapc (lambda (edge)
                           (unless (assoc (car edge) (cdr lst))
                             (fresh-line)
                             (princ (dot-name (caar lst)))
                             (princ "--")
                             (princ (dot-name (car edge)))
                             (princ "[label=\"")
                             (princ (dot-label (cdr edge)))
                             (princ "\"];")))
                         (cdar lst)))
                 edges))
      (defun ugraph->dot (nodes edges)
        (princ "graph{")
        (nodes->dot nodes)
        (uedges->dot edges)
        (princ "}"))
      (defun ugraph->png (fname nodes edges)
        (dot->png fname
                  (lambda ()
                    (ugraph->dot nodes edges))))
    #+end_src

    Finally, let's use it to generate our undirected graph!

    #+begin_src lisp
      (ugraph->png "./imgs/uwizard.dot" *wizard-nodes* *wizard-edges*)
    #+end_src

    [[./imgs/uwizard.dot.png]]
*** What I've Learned

    We've discussed odd lists and created a drawing library for
    mathematical graphs.

    - Lists can end in other things than =nil= (dotted lists).
    - Pairs are what You get when You cons two non-lists (dotted
      pair).
    - Circular Lists are possible, where the last cell points to the
      first.
    - Association Lists are lists of pairs, and are good for small
      amounts of data and for prototyping (alists).
    - Lisp syntax expression are great at list or tree like data, but
      are opaque for more complex data.
    - If Your data is in the form of a mathematical graph, visualize
      it with =graphviz=.
    - Common Technique: Print output to console, wrap in thunk,
      redirect =*standard-output*=.

** Chapter 8 - This Ain't Your Daddy's Wumpus
*** Concept of Grand Theft Wumpus
   We're reminded that we've just built a simple game with
   mathematical graphs.

   Then, we're reminded of "Hunt the Wumpus", which is a game I've
   played before. It was in the =bsd-games= package on Slackware back
   when I used it as my main OS.

   That said, we are not making "Hunt the Wumpus". Instead we're going
   to make something the author calls "Grand Theft Wumpus".

   The premise is quite different: You are the Lisp Alien, and You've
   just robbed a liquor store with the Wumpus. The Wumpus, of course,
   double crosses You and makes off with the money in Your car. You
   shot him in the kidney as he got away, though, which will
   presumably leave a trail for us to follow.

   Nope, instead we are hoping it makes him lay low in the current
   city (Congestion City) long enough for us to find him. Of course,
   much like the original game, the roads in Congestion City are very
   convoluted, and it will be difficult to get around. However, we
   have a pocket computer and our graphing utilities with which to
   conquer this maze.

   The Wumpus will always scout out a new hiding place before he uses
   it. And, since he is injured, any location 1 or 2 blocks away with
   have blood stains. We have a single bullet with which to kill him,
   so we need to be very sure he is in the spot we will target before
   shooting.

   Of course, if it were just You two in the city, it would be too
   easy. So, there are also three other teams (The Gruesome Glowworm
   Gang) hunting around, that will kidnap You and drop You off
   somewhere else in the town if they catch You. However, they are
   Glowbugs: So, if You see blinking lights, You know that they are
   one street away.

   And of course of course, the cops have set up some roadblocks
   (edges where they will catch You if You travel that way), but You
   don't know how many or where they are.

*** Defining the Edges of Congestion City
**** The =load= Function
    First thing's first: We have to actually make the file
    =graph-util.lisp= that it expects us to have made in a previous
    chapter.

    Not too difficult; Let's just pull each block into a new source
    block (which will make unexecutable but exportable) using /noweb
    style/ references. We'll go back and assign some names to the
    needed code blocks.

    Actually, per the [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][manual]], we can just assign all the relevant
    codeblocks the same =:noweb-ref= header argument, and it will pull
    them all (in order) into the same reference.

    #+begin_src lisp :eval never :noweb yes :tangle ./lib/graph-util.lisp
      <<graph-util>>
    #+end_src

    It worked!

    Now, let's see if it lets us load it.

    #+begin_src lisp
      (load "./lib/graph-util.lisp")
    #+end_src

    It does!

**** Preamble and explanation
     We're obviously going to be calling a new function here: =load=
     takes the location of a file on disk that is full of Lisp code,
     and evaluates it all in the current session (basically allowing
     You to load libraries and packages, etc). This allows us to
     ensure that our graphing utilities are available without having
     to manually go back and rerun previous code blocks.

     As for the other declarations:

     - **node-num** is the number of locations (nodes) in the city.
     - **edge-num** is the number of streets connecting those
       locations (edges).
     - **worm-num** is the number of glowworm teams.
     - **cop-odds** is used for the roadblocks (odds of 1 in
       **cop-odds**).

     #+begin_src lisp :tangle wumpus.lisp
       (load "./lib/graph-util.lisp")
       (defparameter *congestion-city-nodes* nil)
       (defparameter *congestion-city-edges* nil)
       (defparameter *visited-nodes* nil)
       (defparameter *node-num* 30)
       (defparameter *edge-num* 45)
       (defparameter *worm-num* 3)
       (defparameter *cop-odds* 15)
     #+end_src

     Now, we're going to make a random list of edges to connect all of
     the nodes.

     We'll start with the =random-node= function, which simply returns
     a random number between 1 and *node-num* inclusive (we are using
     the =1+= function here to achieve this; normally it's 0 and
     target exclusive).

     Then we create the =edge-pair= function, which will take two
     numbers as input. Unless the two numbers are equal, it will
     return a list connecting them to one another (and back
     again!). This is because we're using an /undirected graph/ for
     our city, as opposed to a /directed graph/.

     Finally, we compose these two functions into a bigger function
     called =make-edge-list= that will create our final list of
     edges. It does this using a new function, =loop=, which we'll
     look at closer in the next section.

     Reading from the inside out, we have our =edge-pair= function
     being collected on repeat, up until we've done so the same number
     of times as *edge-num*.

     We are them applying the =append= function (using /sharp-quoting/
     and =apply=).

     #+begin_src lisp :tangle wumpus.lisp
       (defun random-node ()
         (1+ (random *node-num*)))
       (defun edge-pair (a b)
         (unless (eql a b)
           (list (cons a b) (cons b a))))
       (defun make-edge-list ()
         (apply #'append (loop repeat *edge-num*
                               collect (edge-pair (random-node) (random-node)))))
     #+end_src

     Let's give this function a try.

     #+begin_src lisp
       (make-edge-list)
     #+end_src

**** Looping with the =loop= Command
     The =loop= function loops over data, and is fairly powerful.

     We'll be examining it in greater detail in Chapter 10, but we're
     introducing it now. Here's a simple example.

     #+begin_src lisp
       (loop repeat 10
             collect 1)
     #+end_src

     We can also keep a running count with a different form.

     #+begin_src lisp
       (loop for n from 1 to 10
             collect n)
     #+end_src

     You can put any Lisp code in the =collect= part of the loop.

     #+begin_src lisp
       (loop for n from 1 to 10
             collect (+ 100 n))
     #+end_src

**** Preventing Islands
     If a node doesn't receive at least one edge, it is an island (and
     inaccessible to the rest of the map.)

     Instead of fixing our algorithm above to prevent this, we are
     going to simply find all islands at the end of generation and
     connect them somewhere.

     We start with the function =direct-edges=, which takes a node and
     an edge-list and finds all edges in that list that start from
     that node. We use the =remove-if-not= function for this, which
     creates a new list only including those members that satisfy the
     predicate function supplied (we check to see if the node given is
     in the /car/ of the edge from the list).

     Next, the =get-connected= function, which takes the same
     arguments: A node and an edge-list. This function builds a list
     of all nodes connected to the given node in the edge-list, but
     including those connected through multiple steps.

     The idiomatic way to do this is to create a list of /visited/
     nodes, and search along all connected nodes. We then continue to
     search on all of the children of those nodes, etc, etc, until we
     are done.

     I find myself forgetting that the =labels= function defines local
     functions. So, we are creating a function inside of
     =get-connected=. This one is called =traverse=, and it takes a
     node, and then recurses down as above.

     When this is complete, we'll have a complete list of all
     connected nodes.

     The =find-islands= function creates another local function using
     =labels=, with the confusingly similar name of
     =find-island=. This local function takes a list of nodes, and
     checks for all nodes connected to the first one in the list,
     pushing it onto the collector list =islands=.

     It then uses =set-difference= to remove those nodes from the
     original list of nodes, in a local variable called =unconnected=
     It recurses until there are no more unconnected, at which point
     it returns the list =islands=, which is now /a list of the
     land-masses/, which is something I struggled to conceptualize at
     first.

     The reason we are pushing all of the /connected/ nodes onto
     =islands= is so we can figure out how many disparate land masses
     we have, and connect them.

     Anyway, we use the =let*= function for this, which is like =let=,
     but for when arguments depend on one another (it does not eval
     LtR like =let= does).

     Moving on, we need to actually connect these land masses.

     We'll use the =connect-with-bridges= function for this. It takes
     that list of land masses as its only argument. It first checks to
     see of there is a =cdr= (meaning more than one land mass). Then
     it connects the first two land masses together at their first
     elements (=caar= for the first mass, =caadr= for the second) and
     calls itself with the =cdr= of the list as its argument (until
     there isn't one), at whcih point it will return the new list of
     land masses.

     Finally, we want to compose this into a neat, easy-to-use
     function, which we'll call =connect-all-islands=. It takes two
     arguments, a list of nodes and a list of edges, and returns a
     list with all nodes connected in a single land mass.

     #+begin_src lisp :tangle wumpus.lisp
       (defun direct-edges (node edge-list)
         (remove-if-not (lambda (x)
                          (eql (car x) node))
                        edge-list))
       (defun get-connected (node edge-list)
         (let ((visited nil))
           (labels ((traverse (node)
                      (unless (member node visited)
                        (push node visited)
                        (mapc (lambda (edge)
                                (traverse (cdr edge)))
                              (direct-edges node edge-list)))))
             (traverse node))
           visited))
       (defun find-islands (nodes edge-list)
         (let ((islands nil))
           (labels ((find-island (nodes)
                      (let* ((connected (get-connected (car nodes) edge-list))
                             (unconnected (set-difference nodes connected)))
                        (push connected islands)
                        (when unconnected
                          (find-island unconnected)))))
             (find-island nodes))
           islands))
       (defun connect-with-bridges (islands)
         (when (cdr islands)
           (append (edge-pair (caar islands) (caadr islands))
                   (connect-with-bridges (cdr islands)))))
       (defun connect-all-islands (nodes edge-list)
         (append (connect-with-bridges (find-islands nodes edge-list))
         edge-list))
     #+end_src

**** Building the Final Edges for Congestion City
     We have a few more notes to hit for edges:

     1. Police Roadblocks.
     2. Storing Edges as an /alist/.
     3. Compose into one big function.


     By the author's own admission, these are the most cumbersome
     functions in the game. It's interesting that they were introduced
     in a block like this, knowing that.

     One interesting thing I immediately note is that the final
     function (#3 above) is defined first. I was worrying this whole
     time that this wouldn't be possible, and that my code would have
     to follow the flow of execution. It seems that is not the case.

     Let's see how well I can walk through this code:

***** =make-city-edges= Analysis
      The =make-city-edges= function creates three local variables:
      =nodes=, which is a list of numbers based on our original global
      variable =*node-num*=. =edge-list=, which is an already-processed
      list of fully-connected edges. And =cops=, which uses the
      edge-list and =remove-if-not= again, this time creating a
      function that tests if a random number based on the global
      variable =*cop-odds*= comes out to be 0 for each member of
      =edge-list=. If not, it is removed from the list. Presumably this
      is why the "1 in X" format was used for the concept of
      =*cop-odds*=.

      Anyway, with these variables defined, we call both of our
      yet-to-be-defined functions (=edges-to-alist= and =add-cops=) on
      the local variable =edge-list=, using =cops= as an additional
      argument for =add-cops=. This resulting list is returned, as our
      city's final edges.

***** =edges-to-alist= Analysis
      Moving on to =edges-to-alist=. It takes one argument, which is
      the =edge-list= we've been working on up until this point. We
      then make a few interwoven calls to =mapcar=.

      Let's work from the inside out!

      We use the =direct-edges= function from above to return the list
      of edges connected to a given node =node1=. This is passed to
      =remove-duplicates= which ensures each edge only occurs once in
      the list. We specify that it should use the =equal= function to
      determine if there is a duplicate.

      This cleaned-up list is the one that will be passed to the first
      =mapcar= call, which takes each edge pair and turns it into a
      list of its own, but just containing the node to which the given
      node =node1= is connected. It returns a list of these
      single-element lists, like =((20) (23) (28) (25) (5))=. This is
      passed up the chain to a call to =cons=, which conses it with
      =node1=. Our list now looks like =(4 (20) (23) (28) (25)
      (5))=. This is repeated for each edge, using =(car edge)= as
      =node1= (so, in our example, this is where =4= comes from.

      I have to mention, I only have such detail above because I needed
      to dive into the repl to figure out what was going on. However,
      I feel as though I understand all of the above, and I've yet to
      read the explanation. This is a great sign.

***** =add-cops= Analysis
      Let's move on to the final function, =add-cops=. Inside-out,
      again.

      We start by using one of our own functions again, =edge-pair=, on
      two nodes, =node1= and =node2=. Looking back at the above,
      =edge-pair= gives us a bi-directional link by returning a list of
      =((node1 . node2) (node2 . node1))=. We then call a function call
      =intersection= with that as the first argument, and the =cops=
      list from =make-city-edges= as the second (so, finding an
      intersection (?) between the pair and the streets with cops on
      them.

      Looking up =intersection=, it will return a list of the
      /intersection/ between the two listsâ€”that is, the parts that
      occur in both lists.

      So, we are creating all possible edges between the two nodes, and
      comparing them to the list of edges with cops on them.

      If this isn't =nil= (meaning there /is/ an intersection) we then
      create a list which is =(node2 'cops)=, presumably an indicator
      that there are cops on that edge. Otherwise, we return the
      original value supplied by itself (in this case, it would simply
      be =(node2)=).

      These results are then passed up the chain to the first =mapcar=,
      where they are consed with =node1= in an alist. So we can expect
      something like =(4 (20) (11 'cops) (23))=. That makes sense.

      The rest of the code that I haven't mentioned breaks down each
      individual pair of the /alist/ given and assigned =node1= to the
      =car= and =node1-edges= to the =cdr=. So straightforward I almost
      didn't mention it!

***** Check with the book
      I'll read through the explanation now, and note anything above
      that is wrong (and anything I didn't notice)!

      Using =let*= instead of =let= allowed us, in =make-city-edges=,
      to define local variables based on the values of other local
      variables.

      Part of the reason the above /alist/ looked odd to me is that it
      is a /nested alist/. This isn't discussed further here, though I
      feel it will be elsewhere.

      It seems like my analysis was correct! Woo Hoo!

***** Code and final thoughts
      #+begin_src lisp :tangle wumpus.lisp
        (defun make-city-edges ()
          (let* ((nodes (loop for i from 1 to *node-num*
                              collect i))
                 (edge-list (connect-all-islands nodes (make-edge-list)))
                 (cops (remove-if-not (lambda (x)
                                        (zerop (random *cop-odds*)))
                                      edge-list)))
            (add-cops (edges-to-alist edge-list) cops)))
        (defun edges-to-alist (edge-list)
          (mapcar (lambda (node1)
                    (cons node1
                          (mapcar (lambda (edge)
                                    (list (cdr edge)))
                                  (remove-duplicates (direct-edges node1 edge-list)
                                                     :test #'equal))))
                  (remove-duplicates (mapcar #'car edge-list))))
        (defun add-cops (edge-alist edges-with-cops)
          (mapcar (lambda (x)
                    (let ((node1 (car x))
                          (node1-edges (cdr x)))
                      (cons node1
                            (mapcar (lambda (edge)
                                             (let ((node2 (car edge)))
                                               (if (intersection (edge-pair node1 node2)
                                                                 edges-with-cops
                                                                 :test #'equal)
                                                   (list node2 'cops)
                                                   edge)))
                                      node1-edges))))
                    edge-alist))
      #+end_src


      The resulting structure should be something like =((1 (2)) (2 (1)
      (3 COPS)) (3 (2 COPS)))=. We can therefore get a list of all
      edges for a node by calling =(cdr (assoc node edges))=. We can
      check for cops using =(cdr (assoc node2 (cdr (assoc node1
      edges))))=. We're reminded of our graphing libraries again, which
      we're told will be used shortly. I'm excited.

*** Building the Nodes for Congestion City
    We can now work on the actual places (nodes) in our city, which
    can contain:

    - Nothing
    - The Wumpus
    - A Glowworm
    - Blood (clue)
    - Lights (clue)
    - Sirens (clue)


    Clues are mostly proximity-based, and therefore we need some
    functions to determine proximity between two nodes. We'll define
    two nodes as /neighbors/ if they are one node apart. Here's a
    function that returns a node's neighbors (=neighbors=) and a
    function that determines whether two nodes are within one node of
    each other (=within-one=) by seeing if a second node is within
    that returned list of neighbors.

    #+begin_src lisp :tangle wumpus.lisp
      (defun neighbors (node edge-alist)
        (mapcar #'car (cdr (assoc node edge-alist))))
      (defun within-one (a b edge-alist)
        (member b (neighbors a edge-alist)))
    #+end_src

    However, we have a clue that works from up to two nodes away (The
    Blood). So, we need a function that will indicate that, too. That
    we'll call =within-two=.

    First, it will take two nodes and an edge alist. If =within-one=
    returns true, we know we are within two (because we are within
    one) and therefore we return =t=. If not, then we use the =some=
    function on a =lambda= that compares each of the first node's
    neighbors to the second node, to see if /they/ are within one node
    of the second node. The =some= function returns the first value
    that satisfies the given predicate, and =nil= if otherwise.

    #+begin_src lisp :tangle wumpus.lisp
      (defun within-two (a b edge-alist)
        (or (within-one a b edge-alist)
            (some (lambda (x)
                    (within-one x b edge-alist))
                  (neighbors a edge-alist))))
    #+end_src

    These are the full set of utility functions we're going to use to
    determine clues.

    Time for another huuuuuge function. I'm going to write it out and
    try to parse it myself before I read anything, as above.

    Okay, so: The only argument is the =edge-alist= from above.

    We then randomly determine where the wumpus is (with no bound) and
    where the glow worms are (looping up to the number of worms we
    want, using =*worm-num*=).

    Then, we enter the main construction loop.

    For every node (from 1 to the number of nodes we specified in
    =*node-num*=) we create a list starting with the node
    number.

    Then, if the node is where the wumpus is, we put the ='(wumpus)=
    list in the /cdr/. If it is not the node with the wumpus, but it
    is within two nodes of the wumpus, we put the ='(blood!)= list in
    the /cdr/.

    As a separate condition tree, if the node has a glow worm, we put
    the ='(glow-worm)= list in the /cdr/. If not, but a glow worm is
    in a neighboring node, we put the ='(lights!)= list instead.

    Finally, as a separate condition, we check to see if there were
    cops previously places along an edge connecting to the node. If
    so, we put the ='(sirens!)= list in the /cdr/.

    After looping through all of the nodes, we return the resulting
    /nested alist/ of nodes and their clues.

    #+begin_src lisp :tangle wumpus.lisp
      (defun make-city-nodes (edge-alist)
        (let ((wumpus (random-node))
              (glow-worms (loop for i below *worm-num*
                                collect (random-node))))
          (loop for n from 1 to *node-num*
                collect (append (list n)
                                (cond ((eql n wumpus) '(wumpus))
                                      ((within-two n wumpus edge-alist) '(blood!)))
                                (cond ((member n glow-worms) '(glow-worm))
                                      ((some (lambda (worm)
                                               (within-one n worm edge-alist))
                                             glow-worms)
                                       '(lights!)))
                                (when (some #'cdr (cdr (assoc n edge-alist)))
                                  '(sirens!))))))
    #+end_src

    Let's see how I did. I'll again only note things I didn't realize
    myself, and things I got wrong.

    I got everything right! Woo hoo!

*** Initializing a New Game
    We're going to write a function now that will start a new game by
    placing all of our elements in the randomized city we generate.

    The process is fairly simple. Store our edges in a global
    variable, store our nodes (using the generated edges to define
    them) in another global. Put the player in an empty node. And make
    that node the only node the player has visited. Then draw the map.

    #+begin_src lisp :tangle wumpus.lisp
      (defun new-game ()
        (setf *congestion-city-edges* (make-city-edges))
        (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
        (setf *player-pos* (find-empty-node))
        (setf *visited-nodes* (list *player-pos*))
        (draw-city))
    #+end_src

    Two functions above have yet to be defined: =find-empty-node= and
    =draw-city=. We'll take care of the former here.

    Our =find-empty-node= function will pick a node and random. Then
    it will check to see if anything is in that node. If something's
    there, it recurses until it finds a node that has nothing. And
    then it returns that.

    #+begin_src lisp :tangle wumpus.lisp
      (defun find-empty-node ()
        (let ((x (random-node)))
          (if (cdr (assoc x *congestion-city-nodes*))
              (find-empty-node)
              x)))
    #+end_src

    It's worth mentioning that there is *no check* to prevent an
    inifite loop here. If there are no empty nodes in the city, it
    will loop forever.

*** Drawing a Map of Our City
    Drawing a map is easy because of our graphing library!

    #+begin_src lisp :tangle wumpus.lisp
      (defun draw-city ()
        (ugraph->png "city" *congestion-city-nodes* *congestion-city-edges*))
    #+end_src

    Now, to start a new game!

    #+begin_src lisp
      (new-game)
    #+end_src

    [[./city.png]]

**** Drawing a City from Partial Knowledge
     Right now, we can see absolutely everything in our city. We need
     a way to only show the player what they already know, so the game
     is actually fun.

     We're going to accomplish this by using a global variable named
     =*visited-nodes*= to track where the player has been.

     First, we'll need a function to build an alist of the known
     nodes. We'll call that function =known-city-nodes=.

     #+begin_src lisp :tangle wumpus.lisp
       (defun known-city-nodes ()
         (mapcar (lambda (node)
                   (if (member node *visited-nodes*)
                       (let ((n (assoc node *congestion-city-nodes*)))
                         (if (eql node *player-pos*)
                             (append n '(*))
                             n))
                       (list node '?)))
                 (remove-duplicates
                  (append *visited-nodes*
                          (mapcan (lambda (node)
                                    (mapcar #'car
                                            (cdr (assoc node
                                                        ,*congestion-city-edges*))))
                                  ,*visited-nodes*)))))
     #+end_src

     The most notable part of the above function is the use of
     =mapcan=, which is a very similar function to =mapcar= but
     assumes that we are taking a bunch of lists and appending them
     together for the result, irrespective of their original length(s).

     And then, we need a function to do the same to the edges
     (=known-city-edges=).

     #+begin_src lisp :tangle wumpus.lisp
       (defun known-city-edges ()
         (mapcar (lambda (node)
                   (cons node (mapcar (lambda (x)
                                        (if (member (car x) *visited-nodes*)
                                            x
                                            (list (car x))))
                                      (cdr (assoc node *congestion-city-edges*)))))
                 *visited-nodes*))
     #+end_src

     #+begin_src lisp :tangle wumpus.lisp
       (defun draw-known-city()
         (ugraph->png "known-city" (known-city-nodes) (known-city-edges)))
     #+end_src

     #+begin_src lisp :tangle wumpus.lisp
       (defun new-game()
         (setf *congestion-city-edges* (make-city-edges))
         (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
         (setf *player-pos* (find-empty-node))
         (setf *visited-nodes* (list *player-pos*))
         (draw-city)
         (draw-known-city))
     #+end_src

     #+begin_src lisp
       (new-game)
     #+end_src

     [[file:known-city.png]]


*** Walking Around Town

     There are two ways we can walk between parts of our city:
     Normally, or with the intent to shoot the wumpus. Since these are
     very similar functions, most of the work will be done in a shared
     function, called =handle-direction=.

     #+begin_src lisp :tangle wumpus.lisp
       (defun walk (pos)
         (handle-direction pos nil))
       (defun charge (pos)
         (handle-direction pos t))
     #+end_src

     =handle-direction= will take two arguments: a position to move to
     and a flag stating whether this is a =charge=. It will make sure
     the move is a legal move, and then delegate the actual move to a
     lower function.

     #+begin_src lisp :tangle wumpus.lisp
       (defun handle-direction (pos charging)
         (let ((edge (assoc pos
                            (cdr (assoc *player-pos* *congestion-city-edges*)))))
         (if edge
             (handle-new-place edge pos charging)
             (princ "That location does not exist!"))))
     #+end_src

     The lower function that will handle the actual move is going to
     =handle-new-place=. It's job is to move You to the new location
     and see what surprises may have befallen You during Your move.

     #+begin_src lisp :tangle wumpus.lisp
       (defun handle-new-place (edge pos charging)
         (let* ((node (assoc pos *congestion-city-nodes*))
                (has-worm (and (member 'glow-worm node)
                               (not (member pos *visited-nodes*)))))
           (pushnew pos *visited-nodes*)
           (setf *player-pos* pos)
           (draw-known-city)
           (cond ((member 'cops edge) (princ "You ran into the cops. Game Over."))
                 ((member 'wumpus node) (if charging
                                            (princ "You found the Wumpus!")
                                            (princ "You ran into the Wumpus. Game Over.")))
                 (charging (princ "You wasted Your last bullet. Game Over."))
                 (has-worm (let ((new-pos (random-node)))
                             (princ "You ran into a Glow Worm Gang! You're now at ")
                             (princ new-pos)
                             (handle-new-place nil new-pos nil))))))

     #+end_src


*** Let's Hunt Some Wumpus!
    Our game is complete enough to play, now.

    #+begin_src lisp :tangle wumpus.lisp
      (new-game)
    #+end_src

    [[file:known-city.png]]

    #+begin_src lisp
      (charge 19)
    #+end_src

*** What I've Learned
    - =loop= can loop across many types of data (discussed more in
      Chapter 10).
    - The =set-difference= function compares two lists, telling You
      the exclusive items.
    - The =intersection= function does the opposite, telling You the
      items two lists have in common.
    - The =remove-duplicates= function removes duplicates from a list.

** Chapter 9 - Advanced Datatypes and Generic Programming
   While many things can be accomplished in Lisp simply through the
   use of =cons= cells, symbols, strings, and numbers, there are many
   more datatypes in Lisp.
*** Arrays
    An /Array/ in Common Lisp is very similar to a list, but allows
    You to access any specific location's value using a constant
    amount of time.

    Creating an array is done through =make-array=. Note the syntax
    =#()=; The leading =#= indicates this is not just a list, but an
    array.

    #+begin_src lisp
      (make-array 3)
    #+end_src

    #+RESULTS:
    : #(0 0 0)


    It's not super-useful to declare an empty array, though, nor one
    that can't be used. More typical usage would be the following:

    #+begin_src lisp
      (defparameter x (make-array 3))
      (setf (aref x 0) 'fiz)
      (setf (aref x 1) 'foo)
      (setf (aref x 2) 'bar)
      (aref x 1)
    #+end_src

    #+RESULTS:
    : FOO

    The thing to take away here is the =aref= function: Though it
    usually /gets/ the value from an array, when used with =setf= in
    this way it actually /sets/ the value of the array. This is called
    a /Generic Setter/.
*** Using a Generic Setter
    Basically, a /Generic Setter/ is when the code for /getting/ the
    value of a variable is the same as the code for /setting/ the
    value of a variable. Lisp /supports Generic Setters/ through tools
    like =setf=.
    
    #+begin_src lisp
      (setf foo '(a b c))
      (second foo)
    #+end_src

    #+RESULTS:
    : B

    So, normally, the =second= function returns the second element
    from a list, as above. But if You feed that =second= call to
    =setf=, it figures out /where that value is stored/, and will
    update it for You.

    #+begin_src lisp
      (setf (second foo) 'z)
      (second foo)
    #+end_src

    #+RESULTS:
    : Z

    This is possible because the first argument of =setf= is a
    /Generalized Reference/.

*** Hash Tables
    /Hash Tables/ are to /alists/ as /arrays/ are to /lists/.

    They are so efficient that they can seem magical. Most languages
    outside of the lisp world now offer hash tables in some way, too.
*** Working with Hash Tables
    You can create a new hash table with =make-hash-table=. Note the
    =#S= prefix; that indicates that it is a hash table. Actually,
    don't note that, because I got different output.

    #+begin_src lisp
      (make-hash-table)
    #+end_src

    #+RESULTS:
    : #<HASH-TABLE :TEST EQL :COUNT 0 {100478CB23}>

    Let's set up a variable hash table; maybe then it will show the
    =#S= marking.

    #+begin_src lisp
      (defparameter x (make-hash-table))
      (print x)
    #+end_src

    #+RESULTS:
    : #<HASH-TABLE :TEST EQL :COUNT 0 {10047F2E03}>

    Nope, it seems as though that is not in =sbcl=. Let's move on, see
    if it changes as we learn more.

    If we try to get the value of a key that is not present in the
    table, we instead get =NIL=. We actually get two =NIL= values: one
    for the value found (which, nothing was) and one for whether the
    /key/ was found (it was not).

    #+begin_src lisp
      (gethash 'yup x)
    #+end_src

    #+RESULTS:
    : NIL
    : NIL

    We can use the =gethash= command as a generalized reference to add
    items to our table, as well.

    #+begin_src lisp
      (setf (gethash 'yup x) 25)
      (gethash 'yup x)
    #+end_src

    #+RESULTS:
    : 25
    : T

    Note the 25 (the value found) and the =T= (whether the key was
    found).

    We can easily make a hash table of arbitrary size, this way.

    #+begin_src lisp
      (defparameter *drink-order* (make-hash-table))
      (setf (gethash 'bill *drink-order*) 'double-espresso)
      (setf (gethash 'lisa *drink-order*) 'small-drip-coffee)
      (setf (gethash 'john *drink-order*) 'medium-latte)
      (gethash 'lisa *drink-order*)
    #+end_src

    #+RESULTS:
    : SMALL-DRIP-COFFEE
    : T
*** Returning Multiple Values
    *Common Lisp allows you to return more than one value as a
    result*. We've seen =gethash= above. =round= is another function
    that does this; It rounds a number and returns it, and then
    returns the remainder of the rounding operation.

    #+begin_src lisp
      (round 2.4)
    #+end_src

    #+RESULTS:
    : 2
    : 0.4000001

    You can do the same thing in Your own code with the =values=
    function.

    #+begin_src lisp
      (defun foo ()
        (values 3 7))
      (foo)
    #+end_src

    #+RESULTS:
    : 3
    : 7

    The second value will be ignored by a lot of the functions You
    use; It will not impact the functionality of things at all from
    that perspective. Note that the following results in 8, because
    the 3 is used, and the 7 is ignored.

    #+begin_src lisp
      (+ (foo) 5)
    #+end_src

    #+RESULTS:
    : 8

    Of course, there's a way to get around this as well, with the
    function =multiple-value-bind=. It allows You to bind the values
    of

    #+begin_src lisp
      (multiple-value-bind (a b) (foo)
        (* a b))
    #+end_src

    #+RESULTS:
    : 21

    Many more recent Lisp Dialects don't support this
    feature. However, it can lead to more optimized, cleaner code, and
    is something You should remember is a possible alternative to
    simply returning a list of results.
*** Hash Table Performance    Just like arrays, accessing/modifying a hash table value happens
    with a constant time, no matter how big the hash table is.

    However, there are some features of hash tables and situations
    where the performance of hash tables might be less than optimal.
**** Virtual Memory Paging and Cache Misses
     Large Hash Tables or Arrays can cause Your system to start
     swapping, which is not great for performance. Similarly, Cache
     Misses (and thus, main-memory calls with greater latency) can be
     increased with large arrays or hash-tables.
**** Hash Collisions
     I'm familiar with these. The hash that lets a hash-table work
     comes from a function, and that function can sometimes produce
     the same result for two values. If this happens, performance is
     impacted. If it happens /enough/, the lookup with fail.
**** Inefficiency with Small Tables
     Smaller sets of data actually /benefit/ from the use of an
     alist. The overhead introduced by using the much more complex
     hash table is too much to make it worth it.
**** Varying Speed for Operations
     While /lookups/ are constant, /insertions/ are optimized for
     small tables. Occasionally there will be a laggy insertion if the
     table is big enough.
**** Final Reason
     Hash tables are not Lispy. They are an optimization choice, not
     something to use when debugging a concept or hacking. Same goes
     for arrays: Use them to make Your program better, not to write
     Your program from the offset.
*** TODO A Faster Grand Theft Wumpus with Hash Tables
    :LOGBOOK:
    - State "TODO"       from              [2021-10-08 Fri 00:58]
    :END:
    I am so tired of this project that I am skipping this for now.
*** Common Lisp Structures
    A /structure/ is an object with one or more /slots/, which allows
    for a uniform structure to the data You are working with.

    #+begin_src lisp
      (defstruct person
        name
        age
        waist-size
        favorite-color)
    #+end_src

    #+RESULTS:
    : PERSON

    The =defstruct= command has a few nice benefits to manually
    building something like it by hand, or without an object: First,
    it creates some of the otherwise repetetive functions for You:
    =make-object= is the constructor, =object-slot= are the
    getters/setters, etc.

    #+begin_src lisp
      (defparameter *bob* (make-person :name "Bob"
                                       :age 35
                                       :waist-size 32
                                       :favorite-color "blue"))
      (person-age *bob*)
      (setf (person-age *bob*) 36)
      (person-age *bob*)
      *bob*
    #+end_src

    #+RESULTS:
    : #S(PERSON :NAME "Bob" :AGE 36 :WAIST-SIZE 32 :FAVORITE-COLOR "blue")

    Note the =#S= prefix; this indicates a structure.

    Also note that we do not /need/ to use the constructor function;
    We can specify a structure in the form of the printed
    representation, too:

    #+begin_src lisp
      (defparameter *george* #S(person :name "George"
                                       :age 38
                                       :waist-size 36
                                       :favorite-color "black"))
      (person-age *george*)
    #+end_src

    #+RESULTS:
    : 38
*** When to Use Structures
    OOP is very popular, but not as ubiquitous in the Lisp
    world. Higher-order Functional and Domain Specific Language
    programming are alternative styles that are common in Lisp.

    That said, using structures is not limited to programming in an
    OOP style. While You /can/ get by without them (by using lists),
    there are drawbacks:

    1. You'll need to write a lot of otherwise-standard functions for
       manipulating Your data.
    2. Looking at the raw data is not as understandable, since the
       slot names are absent.
    3. /Mutation/ (making data change over time) is much more
       difficult and error prone without a structure to lean on.
*** CLOS
    There is a Common Lisp Object System in Common Lisp, which is
    touted as being very sophisticated, and is mentioned here. I doubt
    we'll go into it much in this book, but it's worth noting it was
    mentioned.
*** Handling Data in a Generic Way
    With all of these datatypes (and more) available, it's easy to
    write ugly, repetitive code when haphazardly dealing with
    them. The Common Lisp solution for this is handling data in a
    generic way, using /generic library functions/, /type predicates/,
    /defmethod/, and /generic accessors/.
*** Working with Sequences
    The /Sequence Functions/ work generically across the three main
    ways of sequencing data in Lisp (lists, arrays, and
    strings). Without the generic =length= function, we would need 3
    functions to determine the length of these three structures.

    #+begin_src lisp :results output
      (print (length '(a b c)))
      (print (length "blub"))
      (print (length (make-array 5)))
    #+end_src

    #+RESULTS:
    : 
    : 3 
    : 4 
    : 5 

    It's worth noting we have =list-length=, which is a =length=
    function that only works on lists. This is a performance-related
    function, that takes out the code that checks for the other
    structures of data. It's unneeded outside of optimization;
    =length= will work everywhere it will work.
*** Sequence Functions for Searching
    Some of the /sequence functions/ search sequences:

    - =find-if= finds the first value in a sequence that satisfies a
      predicate.
    - =count= determines the number of times an object appears in a
      sequence.
    - =position= tells where a specific item is stored (presumably the
      first instance).
    - =some= determines whether any value in a sequence satisfies a
      predicate.
    - =every= determines whether every value in a sequence satisfies a
      predicate.
*** Sequence Functions for Iterating
    I am familiar with both of these, as they are used extensively in
    clojure.
**** =reduce=
     The =reduce= function iterates through a sequence and returns a
     single result.

     #+begin_src lisp
       (reduce #'+ '(3 4 6 5 2))
     #+end_src

     #+RESULTS:
     : 20

     Here's a more complex example, using an anonymous function and a
     parameter, =:initial-value=. Setting an explicit initial value
     like this is important, because otherwise =reduce= will use the
     first items in our sequence to fill all the arguments in our
     function. In this case, it would return 7â€”the largest number in
     our sequence, and the first number (so it would be used as the
     initial value for our =best= argument, and never be checked
     itselfâ€”instead of 6.

     #+begin_src lisp
       (reduce (lambda (best item)
                 (if (and (evenp item)
                          (> item best))
                     item
                     best))
               '(7 4 6 5 2)
               :initial-value 0)
     #+end_src

     #+RESULTS:
     : 6

     While =reduce= is generic across all sequences, the functions
     handed to =reduce= do not have to be:

     #+begin_src lisp
       (defun sum (lst)
         (reduce #'+ lst))
     #+end_src

     #+RESULTS:
     : SUM

     This =sum= function will work for all sequences that have numbers
     in them. However, it will give You a type error if any characters
     are in the sequence. This means strings don't work at all, and
     some arrays and lists won't either.

     #+begin_src lisp :results output
       (print (sum '(1 2 3)))
       (print (sum (make-array 5 :initial-contents '(1 2 3 4 5))))
     #+end_src

     #+RESULTS:
     : 
     : 6 
     : 15 

**** =map=
     Map works as I expect it to, with the wrinkle that the return
     type be specified as the first argument.

     #+begin_src lisp
       (map 'string (lambda (x)
                      (if (eq x #\c)
                          #\C
                          x))
            "My name is christopher.")
     #+end_src

     #+RESULTS:
     : My name is Christopher.

*** Two More Important Sequence Functions
    The =subseq= function slices the sequence using start and end
    points. And the =sort= function lets You pass a function to sort
    the sequence by.

    #+begin_src lisp
      (subseq "Tarot" 0 3)
    #+end_src

    #+RESULTS:
    : Tar

    #+begin_src lisp
      (sort '(5 8 2 4 9 3 6) #'<)
    #+end_src

    #+RESULTS:
    : (2 3 4 5 6 8 9)

    There are many more /sequence functions/, but these are a good
    starting point.

*** Creating Your Own Generic Functions with Type Predicates
    As Common Lisp (and most others) are dynamically typed, any
    variable or parameter can hold any kind of data, and the type of
    data might change over time.

    This is why we have /type predicates/, which are predicates that
    check the type of data referenced somewhere.

    #+begin_src lisp
      (numberp 5)
    #+end_src

    #+RESULTS:
    : T

    You can use these to create functions that handle many types of
    data generically. We'll do that now, creating an =add= function
    that takes two arguments. It will append one to the other if they
    are lists, and it will add them together if they are numbers.

    #+begin_src lisp :results output
      (defun add (a b)
        (cond ((and (numberp a) (numberp b)) (+ a b))
              ((and (listp a) (listp b)) (append a b))))
      (print (add 3 4))
      (print (add '(a b) '(c d)))
    #+end_src

    #+RESULTS:
    : 
    : 7 
    : (A B C D) 

    While this works, it is not the way most Lispers would write this
    function this way. There are four reasons.

**** A Single, Monolithic Function for All Types
     This is fine for two types, but how about two hundred? It would
     turn to spaghetti very quickly, especially when You consider the
     possibility of mismatched types.
**** Modifications Required to Accommodate New Cases
     If You need to support a new type, You need to edit the
     originally defined function, possibly breaking old code. The
     chance for this goes up with complexity.
**** Hard to Understand
     As everything relies on a single =cond= statement, it is easy to
     misunderstand what the code is doing. As the =cond= grows, this
     confusion will too.
**** Performance
     The interpreter (or compiler) cannot optimize the code at all, as
     it is unknown what types of data will be used and in what way to
     it.
*** Creating Your Own Generic Functions with =defmethod=
    As an alternative to the above, consider this:

    #+begin_src lisp :results output
      (defmethod ad ((a number) (b number))
        (+ a b))
      (defmethod ad ((a list) (b list))
        (append a b))
      (print (add 3 4))
      (print (add '(a b) '(c d)))
    #+end_src

    #+RESULTS:
    : 
    : 7 
    : (A B C D) 

    This addresses nearly all of the points above using something
    called /type dispatching/: Having the compiler or interpreter
    choose different versions of a function based on argument
    types. It keeps each version of a function totally separate,
    allows the optimization to occur as it would for simple functions,
    is very readable and even more so extendableâ€”all without touching
    working code!

    The biggest differences between =defmethod= and =defun= are that
    =defmethod= supports /type dispatching/ and it allows You to
    specify which types of data Your function expects in its
    arguments.

    We're going to approach our next game from a more OOP point of
    view, apparently.
*** Orc Battle
**** Concept
     In /Orc Battle/, You are a knight surrounded by 12 monsters. You
     must kill them all before You are worn down by their superior
     numbers.
**** Global Variables for the Player and Monsters
     We need to track three stats for the player: health, agility, and
     strength. If a player's health reaches zero, the player
     dies. Agility controls the number of attacks a player gets each
     round. And strength controls the damage of those attacks. They
     will change as the game progresses.

     #+begin_src lisp :tangle orc-battle.lisp
       (defparameter *player-health* nil)
       (defparameter *player-agility* nil)
       (defparameter *player-strength* nil)
     #+end_src

     #+RESULTS:
     : *PLAYER-STRENGTH*

     As for monsters: We'll store all of our monsters in a global
     array. We'll also make builder functions for each monster, to aid
     in generating random monsters. And we'll control the difficulty
     by specifying the number of monsters.

     #+begin_src lisp :tangle orc-battle.lisp
       (defparameter *monsters* nil)
       (defparameter *monster-builders* nil)
       (defparameter *monster-num* 12)
     #+end_src

     #+RESULTS:
     : *MONSTER-NUM*
**** Main Game Functions
     We're starting with the big picture this time, instead of working
     up from a small feature.

     When we start our game, we need to initialize both the monsters
     and the player, and then We're going to enter a game loop. When
     that game loop terminates, either the player or the monsters will
     be dead (or the game will have been interrupted, in which case it
     doesn't matter). We'll display appropriate messages in each case.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun orc-battle ()
         (init-monsters)
         (init-player)
         (game-loop)
         (when (player-dead)
           (princ "You have been killed. Game Over."))
         (when (monsters-dead)
           (princ "Congratulations! You have vanquished all of Your foes!")))
     #+end_src

     #+RESULTS:
     : ORC-BATTLE

     Next, we need to define the =game-loop= function. It will
     terminate only when either the player is dead or the monsters are
     dead. First, we want it to update the player. Then, we will
     repeat a loop of "update monsters and let the player attack" a
     number of times based on their agility.

     After that, we will ensure we are on a new line, and all the
     alive monsters will attack (and the dead ones will be marked as
     dead). Then, we will recurse, and start the whole thing over.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun game-loop()
         (unless (or (player-dead) (monsters-dead))
           (show-player)
           (dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))
             (unless (monsters-dead)
               (show-monsters)
               (player-attack)))
           (fresh-line)
           (map 'list
                (lambda (m)
                  (or (monster-dead m) (monster-attack m)))
                ,*monsters*)
           (game-loop)))
     #+end_src

     #+RESULTS:
     : GAME-LOOP
**** Player Management Functions
     First, some simple functions: =init-player= initialized the
     player at the default starting stats. =player-dead= checks if the
     player has died. And =show-player= prints out the player's
     current status.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun init-player ()
         (setf *player-health* 30)
         (setf *player-agility* 30)
         (setf *player-strength* 30))
       (defun player-dead ()
         (<= *player-health* 0))
       (defun show-player ()
         (fresh-line)
         (princ "You are a valiant knight with a health of ")
         (princ *player-health*)
         (princ ", an agility of ")
         (princ *player-agility*)
         (princ ", and a strength of ")
         (princ *player-strength*)
         (princ "."))
     #+end_src

     #+RESULTS:
     : SHOW-PLAYER

     We then need a function to manage the player's attack. It will go
     to a fresh line, and ask the player for the type of attack
     (expecting a single letter response). It will then let the player
     pick a monster, and apply the damage to them. If I were writing
     this myself, I would separate out each attack into its own
     function, and probably not default to a specific type (choosing
     instead to re-ask the player). But I am not, this is for
     learning.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun player-attack ()
         (fresh-line)
         (princ "Attack Style: [s]tab [d]ouble-swing [r]oundhouse:")
         (case (read)
           (s (monster-hit (pick-monster)
                          (+ 2 (randval (ash *player-strength* -1)))))
           (d (let ((x (randval (truncate (/ *player-strength* 6)))))
                (princ "Your double-swing has a strength of ")
                (princ x)
                (princ ".")
                (fresh-line)
                (monster-hit (pick-monster) x)
                (unless (monsters-dead)
                  (monster-hit (pick-monster) x))))
           (otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))
                        (unless (monsters-dead)
                          (monster-hit (random-monster) 1))))))
     #+end_src

     #+RESULTS:
     : PLAYER-ATTACK
**** Helper Functions for Player Attacks
     We need a few functions to support our player attacks. =randval=
     will pick a random number of at least 1 and return
     it. =random-monster= will select a random, alive monster to
     attack (for the roundhouse). And =pick-monster= will let the
     player pick a monster instead.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun randval (n)
         (1+ (random (max 1 n))))
       (defun random-monster ()
         (let ((m (aref *monsters* (random (length *monsters*)))))
           (if (monster-dead m)
               (random-monster)
               m)))
       (defun pick-monster ()
         (fresh-line)
         (princ "Monster #:")
         (let ((x (read)))
           (if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))
               (progn (princ "That is not a valid monster number.")
                      (pick-monster))
               (let ((m (aref *monsters* (1- x))))
                 (if (monster-dead m)
                     (progn (princ "That monster is already dead.")
                            (pick-monster))
                     m)))))
     #+end_src

     #+RESULTS:
     : PICK-MONSTER
**** Monster Management Functions
     Initializing the monsters is simple: We will pull =*monster-num*=
     functions out of =*monster-builders*= and call them, putting the
     results into an array of size =*monster-num*= and then storing
     that array in =*monsters*=.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun init-monsters ()
         (setf *monsters*
               (map 'vector
                    (lambda (x)
                      (funcall (nth (random (length *monster-builders*))
                                    ,*monster-builders*)))
                    (make-array *monster-num*))))
     #+end_src

     #+RESULTS:
     : INIT-MONSTERS

     Next, we need our simple helper functions: =monster-dead= will
     tell if a monster is dead, =monsters-dead= will then use that
     function to check if /all/ monsters are dead, and =show-monsters=
     will print a listing of all of the monsters.

     #+begin_src lisp :tangle orc-battle.lisp
       (defun monster-dead (m)
         (<= (monster-health m) 0))
       (defun monsters-dead ()
         (every #'monster-dead *monsters*))
       (defun show-monsters ()
         (fresh-line)
         (princ "Your foes:")
         (let ((x 0))
           (map 'list
                (lambda (m)
                  (fresh-line)
                  (princ "   ")
                  (princ (incf x))
                  (princ ". ")
                  (if (monster-dead m)
                      (princ "**dead**")
                      (progn (princ "(Health=")
                             (princ (monster-health m))
                             (princ ") ")
                             (monster-show m))))
                *monsters*)))
     #+end_src

     #+RESULTS:
     : SHOW-MONSTERS
**** The Monsters
***** The Generic Monster
      We're going to start with a generic monster, and work our way
      out from there.

      The LCD for monsters is the health meter. Every Monster will
      have one. We're going to take advantage of a special feature: We
      can define default values for /slots/ using arbitrary forms!

      #+begin_src lisp :tangle orc-battle.lisp
        (defstruct monster (health (randval 10)))
      #+end_src

      #+RESULTS:
      : MONSTER

      If we try using the constructor =make-monster=, we see that the
      health is different every time.

      #+begin_src lisp
        (make-monster)
      #+end_src

      #+RESULTS:
      : #S(MONSTER :HEALTH 5)

      We also need a function to decrease a monster's health when
      attacked. We'll call that function =monster-hit=. It'll print a
      message, too, but we'll define it with =defmethod= so that we
      can print specific messages for various monsters.

      #+begin_src lisp :tangle orc-battle.lisp
        (defmethod monster-hit (m x)
          (decf (monster-health m) x)
          (if (monster-dead m)
              (progn (princ "You killed the ")
                     (princ (type-of m))
                     (princ "! "))
              (progn (princ "You hit the ")
                     (princ (type-of m))
                     (princ ", knocking off ")
                     (princ x)
                     (princ " health points! "))))
      #+end_src

      #+RESULTS:
      : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-HIT (T T) {10071DDFA3}>

      We also need two more smaller functions: =monster-show= and
      =monster-attack=. The former will be very simple, since it might
      be written over by a future (real) monster. The latter is empty;
      simply a placeholder since each monster will have a unique
      attack.

      #+begin_src lisp :tangle orc-battle.lisp
        (defmethod monster-show (m)
          (princ "A fierce ")
          (princ (type-of m))
          (princ ". "))
        (defmethod monster-attack (m))
      #+end_src

      #+RESULTS:
      : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-ATTACK (T) {1007286303}>
***** The Wicked Orc
      Orcs are simple: Strong, variable-strength club attack.

      We make the orc type using =defstruct=, using a feature that
      includes all of the fields of another type (our generic monster
      class. We just need to add a club-level, which will be
      orc-specific. And then we'll push the constructor onto
      =*monster-builders*=.

      #+begin_src lisp :tangle orc-battle.lisp
        (defstruct (orc (:include monster)) (club-level (randval 8)))
        (push #'make-orc *monster-builders*)
      #+end_src

      #+RESULTS:
      : (#<FUNCTION MAKE-ORC>)

      Note how simple the approach is: No matter how many monsters we
      add, we will never need to change our basic Orc Battle
      code. This is only possible in languages like Lisp, with
      dynamically typed variables and first-class functions.

      We'll now specialize =monster-show= and =monster-attack= for use
      with orcs.

      #+begin_src lisp :tangle orc-battle.lisp
        (defmethod monster-show ((m orc))
          (princ "A wicked orc with a level ")
          (princ (orc-club-level m))
          (princ " club."))
        (defmethod monster-attack ((m orc))
          (let ((x (randval (orc-club-level m))))
            (princ "An orc swings at You and knocks off ")
            (princ x)
            (princ " of Your health points. ")
            (decf *player-health* x)))
      #+end_src

      #+RESULTS:
      : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-ATTACK (ORC) {100404D743}>
***** The Malicious Hydra
      The hydra attacks with its heads, grows heads back each round,
      and should be dealt with quickly.

      #+begin_src lisp :tangle orc-battle.lisp
        (defstruct (hydra (:include monster)))
        (push #'make-hydra *monster-builders*)
      #+end_src

      #+RESULTS:
      : (#<FUNCTION MAKE-HYDRA> #<FUNCTION MAKE-ORC>)

     The hydra's health /is/ its number of heads. So, the healthier it
     is, the more damage it does. And it heals 1 HP each turn.

     #+begin_src lisp :tangle orc-battle.lisp
       (defmethod monster-show ((m hydra))
         (princ "A malicious hydra with ")
         (princ (monster-health m))
         (princ " heads."))
       (defmethod monster-hit ((m hydra) x)
         (decf (monster-health m) x)
         (if (monster-dead m)
             (princ "The corpse of the fully decapitated and decapacitated hydra falls to the floor!")
             (progn (princ "You lop off ")
                    (princ x)
                    (princ " of the hydra's heads! "))))
       (defmethod monster-attack ((m hydra))
         (let ((x (randval (ash (monster-health m) -1))))
           (princ "A hydra attacks You with ")
           (princ x)
           (princ " of its heads! It also grows back one more head! ")
           (incf (monster-health m))
           (decf *player-health* x)))
     #+end_src

     #+RESULTS:
     : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-ATTACK (HYDRA) {100434AA83}>
***** The Slimy Slime Mold
      This monster attacks Your agility by wrapping around Your legs
      and squirting goo in Your face.

      #+begin_src lisp :tangle orc-battle.lisp
        (defstruct (slime-mold (:include monster)) (sliminess (randval 5)))
        (push #'make-slime-mold *monster-builders*)
      #+end_src

      #+RESULTS:
      : (#<FUNCTION MAKE-SLIME-MOLD> #<FUNCTION MAKE-HYDRA> #<FUNCTION MAKE-ORC>)

      The main feature is the agility damage, but there is also a 50%
      chance it will do 1 HP of damage (squirting goo) to the player
      as well, to prevent softlocking.

      #+begin_src lisp :tangle orc-battle.lisp
        (defmethod monster-show ((m slime-mold))
          (princ "A slime mold with a sliminess of ")
          (princ (slime-mold-sliminess m))
          (princ ". "))
        (defmethod monster-attack ((m slime-mold))
          (let ((x (randval (slime-mold-sliminess m))))
            (princ "A slime mold wraps around Your legs and decreases Your agility by ")
            (princ x)
            (princ "! ")
            (decf *player-agility* x)
            (when (zerop (random 2))
              (princ "It also squirts in Your face, taking away a health point! ")
              (decf *player-health*))))
      #+end_src

      #+RESULTS:
      : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-ATTACK (SLIME-MOLD) {1004687213}>
***** The Cunning Brigand
      The smartest monster who attacks Your currently-best attribute.

      #+begin_src lisp :tangle orc-battle.lisp
        (defstruct (brigand (:include monster)))
        (push #'make-brigand *monster-builders*)
      #+end_src

      #+RESULTS:
      : (#<FUNCTION MAKE-BRIGAND> #<FUNCTION MAKE-SLIME-MOLD> #<FUNCTION MAKE-HYDRA>
      :  #<FUNCTION MAKE-ORC>)

      The brigand won't get a special show or hit function, but will
      have a fairly complex attack function.

      #+begin_src lisp :tangle orc-battle.lisp
        (defmethod monster-attack ((m brigand))
          (let ((x (max *player-health* *player-agility* *player-strength*)))
            (cond ((= x *player-health*)
                   (princ "A brigand hits You with their slingshot, taking off 2 health points! ")
                   (decf *player-health* 2))
                  ((= x *player-agility*)
                   (princ "A brigand catches Your leg with their whip, taking off 2 agility points! ")
                   (decf *player-agility* 2))
                  ((= x *player-strength*)
                   (princ "A brigand cuts Your arm with their whip, taking off 2 strength points! ")
                   (decf *player-strength* 2)))))
      #+end_src

      #+RESULTS:
      : #<STANDARD-METHOD COMMON-LISP-USER::MONSTER-ATTACK (BRIGAND) {10049022D3}>
**** To Battle!
     The game is now playable! But needs to be played in a REPL. Just
     call the =(orc-battle)= function.
*** What I've Learned
    - Arrays are similar to lists, but more efficient and less Lispy.
    - Hash Tables are ditto to alists.
    - Both will make Your code faster.
    - The =time= command will tell You if it made a difference.
    - Common Lisp a Generic Functions. We learned about the Sequence ones.
    - You can use =defstruct= to make objects with slots.
* Part III - Lisp is Hacking
** =loop= and =format=: The Seedy Underbelly of Lisp
*** Intro
    =loop= and =format= are extensions to the much purer Lisp Core,
    but they are two extensions that have stood the test of time and
    can confer great power in their use. However, some Lispers feel
    You should not use them in any really serious code due to their
    complexity.
** Chapter 10: Looping with the =loop= command
   Though most of the functionality =loop= and =format= offer is
   available elsewhere, they are both good for writing terse code.
*** The =loop= macro
    The first macro we are going over in this section is =loop=. It
    can do basically any kind of looping You could want.

    #+begin_src lisp
      (loop for i
            below 5
            sum i)
    #+end_src

    #+RESULTS:
    : 10

    This is, obviously, not a very lispy way to do such a thing,
    however. There are 7 tokens in a row, and 3 of them have special
    rules that break the symmetry expected in lisp forms:

    - =for= declares a variable that changes each iteration.
    - =below= is a constraint for that variable (stop at 5,
      exclusively).
    - =sum= adds together the number from each iteration, the sum of
      which will be returned by =loop=.
*** Some =loop= Tricks
    There are a /lot/ of possibilities in =loop=.
**** Counting from a Starting Point to an Ending Point
     The =from= and =to= clauses control starting and ending points.

     #+begin_src lisp
       (loop for i
             from 5
             to 10
             sum i)
     #+end_src

     #+RESULTS:
     : 45

**** Iterating Through Values in a List
     The =in= token lets You specify the data set.

     #+begin_src lisp
       (loop for i
             in '(100 20 3)
             sum i)
     #+end_src

     #+RESULTS:
     : 123

**** =doing= Stuff in a Loop
     The =do= token takes an arbitrary form any executes it within the
     loop.

     #+begin_src lisp :results output
       (loop for i
             below 5
             do (print i))
     #+end_src

     #+RESULTS:
     : 
     : 0 
     : 1 
     : 2 
     : 3 
     : 4 
**** Doing Stuff Under Certain Conditions
     The =when= token only runs when a predicate is true.

     #+begin_src lisp
       (loop for i
             below 10
             when (oddp i)
               sum i)
     #+end_src

     #+RESULTS:
     : 25

**** Breaking Out of a Loop Early
     Notice we have no upper bound here, only a condition =when= that
     leads to a =return=.

     #+begin_src lisp
       (loop for i
             from 0
             do (print i)
                when (= i 5)
                  return 'falafel)
     #+end_src

     #+RESULTS:
     : FALAFEL

**** Collecting a List of Values
     The =collect= token builds a list from the results of a function
     in each iteration. Useful for transforming each member of a list.

     #+begin_src lisp
       (loop for i
             in '(2 3 4 5 6)
             collect (* i i))
     #+end_src

     #+RESULTS:
     : (4 9 16 25 36)

**** Using Multiple =for= Clauses
     You can use more than one =for= token, too. Note, however, that
     the variables iterate in tandem, not separately.

     #+begin_src lisp
       (loop for x below 10
             for y below 10
             collect (+ x y))
     #+end_src

     #+RESULTS:
     : (0 2 4 6 8 10 12 14 16 18)

     To get the other kind of result, called a /Cartesian Product/, we
     need to use /nested =loop= statements/.

     #+begin_src lisp
       (loop for x below 10
             collect (loop for y below 10
                           collect (+ x y)))
     #+end_src

     #+RESULTS:
     : ((0 1 2 3 4 5 6 7 8 9) (1 2 3 4 5 6 7 8 9 10) (2 3 4 5 6 7 8 9 10 11)
     :  (3 4 5 6 7 8 9 10 11 12) (4 5 6 7 8 9 10 11 12 13) (5 6 7 8 9 10 11 12 13 14)
     :  (6 7 8 9 10 11 12 13 14 15) (7 8 9 10 11 12 13 14 15 16)
     :  (8 9 10 11 12 13 14 15 16 17) (9 10 11 12 13 14 15 16 17 18))

     Also note how easy tracking the index of a list is since the
     default for =for= variables is to start at zero:

     #+begin_src lisp
       (loop for i
             from 0
             for day
             in '(monday tuesday wednesday thursday friday saturday sunday)
             collect (cons i day))
     #+end_src

     #+RESULTS:
     : ((0 . MONDAY) (1 . TUESDAY) (2 . WEDNESDAY) (3 . THURSDAY) (4 . FRIDAY)
     :  (5 . SATURDAY) (6 . SUNDAY))

*** Everything You've Ever Wanted to Know About =loop=
**** Periodic Table of the Loop Macro
     I am not going to type all of these out right now, but there are
     a total of *48* examples given in this image. Something I'll come
     back to do at the end, maybe.
*** Using =loop= to Evolve!
    We're going to create another game, making full use of =loop=.
**** Overview
    /Evolution/ will be more like Conway's /Game of Life/ in that it
    will be more of a game You watch than a game You play.
**** Game World
     There will be a rectangular plane that wraps around its sides
     (toroid) where our creatures live. Most of the plane is covered
     in /steppes/, which have little vegetation. The center will have
     a /jungle/, with many more plants that grow faster. Our creatures
     will be herbavores, so they will be looking for plants to eat.

     We'll store the game world in a few global variables, as
     before. =*width*= and =*height*= will store the plane's
     measurements, =jungle= will be the coordinates of a rectangle
     that will be the jungle, and =*plant-energy*= is the amount (in
     days/cycles) of energy a creature gets for finding a plant.

     #+begin_src lisp :tangle evolution.lisp
       (defparameter *width* 100)
       (defparameter *height* 30)
       (defparameter *jungle* '(45 10 10 10))
       (defparameter *plant-energy* 80)
     #+end_src

     #+RESULTS:
     : *PLANT-ENERGY*

**** Growing Plants in Our World
     We're going to store our plants in a hash-table, indexed by x/y
     coordinates.

     By default, hash-tables use =eq=. However, we need to use =equal=
     instead since we'll be comparing cons cells.

     #+begin_src lisp :tangle evolution.lisp
       (defparameter *plants* (make-hash-table :test #'equal))
     #+end_src

     #+RESULTS:
     : *PLANTS*

     Plants will grow randomly across the world, in higher numbers in
     the jungle and lower numbers in the steppes.

     The =random-plant= function will make a plant grow (really just
     updating the coordinates key in the hash-table) somewhere
     randomly within a rectangle whose coordinates are passed in.

     The =add-plants= function will apply the =random-plant= function
     twice: Once for the jungle area, and once for the entire map.

     #+begin_src lisp :tangle evolution.lisp
       (defun random-plant (left top width height)
         (let ((pos (cons (+ left (random width)) (+ top (random height)))))
           (setf (gethash pos *plants*) t)))
       (defun add-plants ()
         (apply #'random-plant *jungle*)
         (random-plant 0 0 *width* *height*))
     #+end_src

     #+RESULTS:
     : ADD-PLANTS

     It's interesting to note what we are doing here: A hash-table
     where the /keys/ are important, and the /values/ are all just
     =t=. Since =nil= is returned when nothing is found, it allows us
     to fake having a set operator if we simply store the present
     values in the hash-table with =t= as the value.

     Other Lisp Dialects (more recent ones, like Clojure) have a built
     in set structure, making this unnecessary. That said, it would
     still work.
**** Creating Animals
     Animals are going to be complicated enough we'll need a structure
     to support them. The structure will have the following slots:

     - *x* and *y*: The coordinates of the animal. Where it is in
       physical space.
     - *energy*: How much stored energy it has (from eating plants).
     - *dir*: Its current heading. Can be Diagonal or Orthogonal, like
       a num-pad.
     - *genes*: This will be the animal's propensity for making
       changes to its heading. It will be a plain list with 8 members,
       each holding an integer (which will be the weight for the given
       heading change).


     #+begin_src lisp :tangle evolution.lisp
       (defstruct animal x y energy dir genes)
     #+end_src

     #+RESULTS:
     : ANIMAL

     Now, we will store our population of animals in the global
     variable =*animals*=, and create our first creature. We can use a
     list for this instead of a hash-table because we will only very
     rarely need to search through =*animals*=â€”most of the time, we
     will update all of our animals at once!

     #+begin_src lisp :tangle evolution.lisp
       (defparameter *animals*
         (list (make-animal :x (ash *width* -1)
                            :y (ash *height* -1)
                            :energy 1000
                            :dir 0
                            :genes (loop repeat 8
                                         collecting (1+ (random 10))))))
     #+end_src

     #+RESULTS:
     : *ANIMALS*

**** Handling Animal Motion
     We are going to move our animals using the function =move=, which
     takes an animal and updates its position (=x= and =y= slots).

     The reason this isn't just a simple increment/decrement is the
     /wrapping/ of the edges of the map: Since we want that, we need
     to update the position if it goes over the width or height of our
     plane, back to 0 (so we take the modulus of the resulting number
     and the appropriate bound each time, and set the value to that
     instead).

     #+begin_src lisp :tangle evolution.lisp
       (defun move (animal)
         (let ((dir (animal-dir animal))
               (x (animal-x animal))
               (y (animal-y animal)))
           (setf (animal-x animal) (mod (+ x
                                           (cond ((and (>= dir 2) (< dir 5)) 1)
                                                 ((or (= dir 1) (= dir 5)) 0)
                                                 (t -1))
                                           ,*width*)
                                        ,*width*))
           (setf (animal-y animal) (mod (+ y
                                           (cond ((and (>= dir 0) (< dir 3)) -1)
                                                 ((and (>= dir 4) (< dir 7)) 1)
                                                 (t 0))
                                           ,*height*)
                                        ,*height*))
           (decf (animal-energy animal))))

     #+end_src

     #+RESULTS:
     : MOVE

**** Handling Animal Turning
     This function will use the genes in each creature to decide if it
     turns or not.

     It's worth noting here that we are using =labels= to make and use
     the local recursive function =angle=, which will subtract the
     gene-values, in order, from a random number between 0 and the
     total sum of all of the gene values (exclusive). Once it equals
     zero, it returns the count of how many times it recursed, which
     is the index for the appropriate gene. This is added to the
     current direction the animal is facing, and then modulused with
     the number of directions (8) to ensure it is a valid heading.

     #+begin_src lisp :tangle evolution.lisp
       (defun turn (animal)
         (let ((x (random (apply #'+ (animal-genes animal)))))
           (labels ((angle (genes x)
                      (let ((xnu (- x (car genes))))
                        (if (< xnu 0)
                            0
                            (1+ (angle (cdr genes) xnu))))))
             (setf (animal-dir animal)
                   (mod (+ (animal-dir animal) (angle (animal-genes animal) x))
                        8)))))
     #+end_src

     #+RESULTS:
     : TURN

**** Handling Animal Eating
     We are just going to check if there is an intersection between an
     animal's current location and the location of a plant. If so,
     we'll consume the plant and give the appropriate energy to the
     animal.

     #+begin_src lisp :tangle evolution.lisp
       (defun eat (animal)
         (let ((pos (cons (animal-x animal) (animal-y animal))))
           (when (gethash pos *plants*)
             (incf (animal-energy animal) *plant-energy*)
             (remhash pos *plants*))))
     #+end_src

     #+RESULTS:
     : EAT

**** Handling Animal Reproduction
     This is the most interesting part, apparently. We are going to
     copy things imperfectly, simulating (genetic) mutation.

     #+begin_src lisp :tangle evolution.lisp
       (defparameter *reproduction-energy* 200)
       (defun reproduce (animal)
         (let ((e (animal-energy animal)))
           (when (>= e *reproduction-energy*)
             (setf (animal-energy animal) (ash e -1))
             (let ((animal-nu (copy-structure animal))
                   (genes (copy-list (animal-genes animal)))
                   (mutation (random 8)))
               (setf (nth mutation genes) (max 1 (+ (nth mutation genes) (random 3) -1)))
               (setf (animal-genes animal-nu) genes)
               (push animal-nu *animals*)))))
     #+end_src

     #+RESULTS:
     : REPRODUCE

**** Simulating a Day in Our World
     To simulate our world, we're going to define an update function
     named =update-world=. It will first check to see if any animals
     have run out of energy, and if so, remove them. Then it will have
     each remaining animal turn, move, eat, and reproduce according to
     the functions above. Then, we will grow new plants.

     We are using all of these functions for their side effects, so we
     don't care much about their results. Therefore, we can use =mapc=
     to make things more efficient.

     #+begin_src lisp :tangle evolution.lisp
       (defun update-world ()
         (setf *animals* (remove-if (lambda (animal)
                                      (<= (animal-energy animal) 0))
                                    ,*animals*))
         (mapc (lambda (animal)
                 (turn animal)
                 (move animal)
                 (eat animal)
                 (reproduce animal))
               ,*animals*)
         (add-plants))
     #+end_src

     #+RESULTS:
     : UPDATE-WORLD

**** Drawing Our World
     We need to show the user the current state of the world. We'll
     make a draw function for that called =draw-world=. It will loop
     on the y axis first, drawing borders before the first x cell and
     after the last x cell with =|=. Then it will loop through the x
     cells of each row. If there are any animals in a cell (using
     =some= because we care if the x/y coordinates match on /any/
     animal), then we will draw an =M= there. Otherwise, we will see
     if there are any plants there, and if so, draw a =*=. If not,
     we'll just draw a space.

     We don't care too much about the efficiency of this function
     because we are not merely updating the screen after each call to
     =update-world=.

     #+begin_src lisp
       (defun draw-world ()
         (loop for y
               below *height*
               do (progn (fresh-line)
                         (princ "|")
                         (loop for x
                               below *width*
                               do (princ (cond ((some (lambda (animal)
                                                        (and (= (animal-x animal) x)
                                                             (= (animal-y animal) y)))
                                                      ,*animals*)
                                                #\M)
                                               ((gethash (cons x y) *plants*) #\*)
                                               (t #\space))))
                  (princ "|"))))

     #+end_src

     #+RESULTS:
     : DRAW-WORLD

**** Creating a User Interface
     Our final function is the UI for our game. We'll let the user see
     the world at the start. Then we'll get some input from the
     user. If the user types "quit", we will end the simulation. If
     not, we'll see if they entered an integer. If so, we will run the
     world for that many days/steps, drawing a =.= to the screen for
     each 1000 years that passes. If not, we will simply update
     once. Either way, we will show the world to the user, and
     recurse.

     #+begin_src lisp :tangle evolution.lisp
       (defun evolution ()
         (draw-world)
         (fresh-line)
         (let ((str (read-line)))
           (cond ((equal str "quit") ())
                 (t (let ((x (parse-integer str :junk-allowed t)))
                      (if x
                          (loop for i
                                below x
                                do (update-world)
                                if (zerop (mod i 1000))
                                  do (princ #\.))
                          (update-world))
                      (evolution))))))
     #+end_src

     #+RESULTS:
     : EVOLUTION

**** Ready for Play
     It works!

     As an exercise, the book says, we can use different letters to
     represent different genes. I like this idea, so I am going to try
     it.

     I am going to use a [[https://en.wikipedia.org/wiki/Schwartzian_transform][Schwartzian Transform]] to make a list of the
     largest to smallest genes, as per [[https://stackoverflow.com/a/38450427][this answer]] on Stack Overflow.

     #+begin_src lisp :tangle evolution.lisp
       (defun rank-genes (genes)
         (mapcar #'second
                 (stable-sort
                  (loop for index from 0
                        for element in genes
                        collect (list index element))
                  #'>
                  :key #'first)))
       (defun draw-animal (animal)
         (let* ((genes (animal-genes animal))
                (gene-index (rank-genes genes)))
           (case (car gene-index)
             (0 #\A)
             (1 #\B)
             (2 #\C)
             (3 #\D)
             (4 #\E)
             (5 #\F)
             (6 #\G)
             (7 #\H)
             (t #\I))))
     #+end_src

     #+RESULTS:
     : DRAW-ANIMAL

     Then, we need to rewrite our =draw-world= function to use this
     new =draw-animal= function instead.

     #+begin_src lisp :tangle evolution.lisp
       (defun find-animal (animals x y)
         (loop for animal in animals
               when (and (= (animal-x animal) x)
                         (= (animal-y animal) y))
                 return animal))
       (defun draw-world ()
         (loop for y
               below *height*
               do (progn (fresh-line)
                         (princ "|")
                         (loop for x
                               below *width*
                               do (princ (cond ((some (lambda (animal)
                                                        (and (= (animal-x animal) x)
                                                             (= (animal-y animal) y)))
                                                      ,*animals*)
                                                (draw-animal (find-animal *animals* x y)))
                                               ((gethash (cons x y) *plants*) #\*)
                                               (t #\space))))
                  (princ "|"))))


     #+end_src

     #+RESULTS:
     : DRAW-WORLD

*** What You've Learned
    I've learned a lot about the =loop= macro.

    - The =loop= can do any kind of loop needed.
    - You easily loop upwards from 0 using the =for= token.
    - You can use =for= with =in= for iterating over a list.
    - You can collect the result of an operation on each of the items
      in a list using the =collect= token.
    - I have homework for the future in the Periodic Table of the Loop Macro.
** Chapter 11: Printing Text with the =format= function
   Manipulating Text is one of my focii, so I am excited to learn
   about =format=.
*** Anatomy of the =format= function
    Here is an example.

    #+begin_src lisp :results output
      (format t "Add onion rings for only ~$ dollars more!" 1.5)
    #+end_src

    #+RESULTS:
    : Add onion rings for only 1.50 dollars more!
**** The Destination Parameter
     The first argument to =format= is the /destination/
     parameter. Possible values:

     - =nil=: Don't print anything, just return the string.
     - =t=: Print the value to stdout, returning =nil=.
     - =stream=: Write data to specific /Output Stream/, which is
       something we'll learn about in Chapter 12.


     In the example above, we have this set to =t= so it will spit the
     formatted string back to us on the console.

     In the following example, it is set to =nil= so we can manipulate
     the string more before =princ= ing it.

     #+begin_src lisp :results output
       (princ
        (reverse
         (format nil "Add onion rings for only ~$ dollars more!" 1.5)))
     #+end_src

     #+RESULTS:
     : !erom srallod 05.1 ylno rof sgnir noino ddA
**** The Control String Parameter
     The second argument to =format= is the /control string/
     parameter. It is a string with some number of control sequences
     embedded in it. Control Sequences all start with a =~=, and
     format the data before printing it (a la =printf=).

     The =~$= control sequence indicates a /monetary floating-point/
     value.
**** Value Parameters
     The actual data we are printing in a formatted way.
*** Control Sequences for Printing Lisp Values
    Any Lisp value can be printed with the =print= or =prin1=
    functions, and for humans with the =princ= command.

    The =format= function has control sequences for these effects, as
    well. =~s= causes the value to be printed as in =print=, with
    appropriate delimiters. And =~a= causes the value to be printed as
    appropriate for humans to read, like =princ=.

    #+begin_src lisp :results output
      (format t "I am printing ~s in the middle of this sentence." "foo")
      (fresh-line)
      (format t "I am printing ~a in the middle of this sentence." "foo")
    #+end_src

    #+RESULTS:
    : I am printing "foo" in the middle of this sentence.
    : I am printing foo in the middle of this sentence.

    You can adjust control sequence behavior with parameters embedded
    within the control sequence itself. For instance, adding a number
    to =~a= we can pad the value, ensuring it is a specific width. To
    add on the left instead of the right, add an =@= at the end of the
    parameter list. And to specify how many spaces should be the
    minimum group used for padding (if You want to pad with a multiple
    of 3 spaces only, for instance), that is the job of the second
    parameter of =~a=, and comes after a comma, but before the =@= if
    using.

    #+begin_src lisp :results output
      (format t "I am printing ~10a within 10 spaces of room." "foo")
      (fresh-line)
      (format t "I am printing ~10@a within 10 spaces of room." "foo")
      (fresh-line)
      (format t "I am printing ~10,3@a within a multiple of 3 spaces of room." "foo")
    #+end_src

    #+RESULTS:
    : I am printing foo        within 10 spaces of room.
    : I am printing        foo within 10 spaces of room.
    : I am printing          foo within a multiple of 3 spaces of room.

    The third parameter specifies the amount of padding we want at the
    end of the term, explicitly. And the fourth specifies the
    character to use for padding.

    #+begin_src lisp :results output
      (format t "I am printing ~,,4a in the middle of this sentence." "foo")
      (fresh-line)
      (format t "The world ~,,4,'!a feels very important, too." "foo")
    #+end_src

    #+RESULTS:
    : I am printing foo     in the middle of this sentence.
    : The world foo!!!! feels very important, too.
*** Control Sequences for Formatting Numbers
**** Control Sequences for Formatting Integers
     You can display numbers in hexidecimal =~x=, binary =~b=, and
     decimal =~d=.

     #+begin_src lisp :results output
       (format t "The number ~d is ~x in hexadecimal and ~b in binary." 1464 1464 1464)
     #+end_src

     #+RESULTS:
     : The number 1464 is 5B8 in hexadecimal and 10110111000 in binary

     You can pad like with =~a=, though the /second/ parameter is the
     padding character. And You can turn on commas for separation with
     the finale character =:=.

     #+begin_src lisp :results output
       (format t "Numbers with commas in them are ~10,',:d times better." 10000)
     #+end_src

     #+RESULTS:
     : Numbers with commas in them are ,,,,10,000 times better.
**** Control Sequences for Formatting Floating-Point Numbers
     All floating point numbers can be handled with =~f=. The first
     parameter is the number of characters to display. The second is
     the number /after the decimal/. The third multiplies the result
     by powers of 10 (letting us use E notation easily). And as we saw
     above, =~$= handles money-style numbers (with exactly two digits
     after the decimal).

     #+begin_src lisp :results output
       (defparameter lightspeed 299792458)
       (format t "PI Can be estimated as ~4f for speed and ~,4f for accuracy." pi pi)
       (fresh-line)
       (format t "The speed of light is ~,,-8f x 10^8 m/s in scientific notation, but ~,,-6f m/s in engineering notation." lightspeed lightspeed)
     #+end_src

     #+RESULTS:
     : PI Can be estimated as 3.14 for speed and 3.1416 for accuracy.
     : The speed of light is 2.9979245 x 10^8 m/s in scientific notation, but 299.79245 m/s in engineering notation.

*** Printing Multiple Lines of Output
    There are two functions for inserting newlines in stdout: =terpri=
    and =fresh-line=.

    The difference is that =terpri= will always insert a
    newline. =fresh-line= will only do so if You aren't already at the
    beginning of a line.

    =format= has similar control sequences: =~%= is like =terpri=, and
    =~&= is like =fresh-line=.

    #+begin_src lisp :results output
      (format t "This is on one line~%")
      (format t "~%This is on another line, after two terpri.")
      (fresh-line)
      (format t "This is on one line~&")
      (format t "~&This is on another line, after two fresh-line.")
    #+end_src

    #+RESULTS:
    : This is on one line
    : 
    : This is on another line, after two terpri.
    : This is on one line
    : This is on another line, after two fresh-line.

    There is only one parameter for these, and that is the number of
    newlines that should be inserted. There is no difference in this
    use-case.

    #+begin_src lisp :results output
      (format t "This will Print~5%On a Few~5&Lines I Think.")
    #+end_src

    #+RESULTS:
    #+begin_example
    This will Print




    On a Few




    Lines I Think.
    #+end_example

*** Justifying Output
    We're going to return some random text to illustrate the
    justification rules.

    #+begin_src lisp
      (defun random-animal ()
        (nth (random 5) '("dog" "tick" "tiger" "walrus" "kangaroo")))
    #+end_src

    #+RESULTS:
    : RANDOM-ANIMAL

    We can use the =~t= control sequence to display data in a uniform
    table-line format. It takes a parameter that will specify which
    character column the info should be placed in. The following
    example works because our longest value, "kangaroo", is shorter
    than the space between our columns (it is 8 characters, the space
    is 10).

    #+begin_src lisp :results output
      (loop repeat 10
            do (format t "~5t~a ~15t~a ~25t~a~%"
                        (random-animal)
                        (random-animal)
                        (random-animal)))
    #+end_src

    #+RESULTS:
    #+begin_example
         tick      tick      tiger
         walrus    kangaroo  tiger
         walrus    tick      dog
         walrus    tiger     tick
         walrus    tiger     tiger
         dog       walrus    tick
         tick      tiger     dog
         tick      tick      walrus
         dog       tick      tick
         tiger     tick      walrus
    #+end_example

    We can do this differently using the =~<= and =~>= control
    sequences.

    Deconstructing the full control string of =~30<~a~;~a~;~a~>~%=:

    - =~30<=: Start Justifying =~<=. Parameter 30 means it should be
      30 character wide in total.
    - =~a=: Place a Value Here.
    - =~;=: Start a New Item to Justify.
    - =~>=: Stop Justifying.
    - =~%=: =terpri=.

    #+begin_src lisp :results output
      (loop repeat 10
            do (format t "~30<~a~;~a~;~a~>~%"
                       (random-animal)
                       (random-animal)
                       (random-animal)))
    #+end_src

    #+RESULTS:
    #+begin_example
    tick         dog         tiger
    walrus    kangaroo    kangaroo
    kangaroo       dog        tick
    walrus     kangaroo     walrus
    dog         dog          tiger
    tiger      tick       kangaroo
    tiger        tick         tick
    walrus    kangaroo    kangaroo
    tick      kangaroo       tiger
    tiger        tick         tick
    #+end_example

    We can center values by appending the finale character =:@= to the
    original Justify control sequence.

    #+begin_src lisp :results output
      (loop repeat 10 do (format t "~30:@<~a~>~%" (random-animal)))
    #+end_src

    #+RESULTS:
    #+begin_example
                 tick             
                tiger             
                tiger             
                 tick             
                walrus            
                 tick             
                 dog              
                walrus            
                 dog              
                 tick             
    #+end_example

    This also works for mutiple values in a line.

    #+begin_src lisp :results output
      (loop repeat 10
            do (format t "~30:@<~a~;~a~;~a~>~%"
                       (random-animal)
                       (random-animal)
                       (random-animal)))

    #+end_src

    #+RESULTS:
    #+begin_example
       kangaroo   walrus   dog    
       walrus   walrus   tiger    
        dog    dog     walrus     
       walrus   walrus   tiger    
        walrus    dog     dog     
      kangaroo  kangaroo  walrus  
        tiger     dog     dog     
       walrus    tick    tiger    
        walrus    dog    tick     
         tick     dog     dog     
    #+end_example

    To get nicely-centered columns, we need to justify the columns
    separately. Dividing our original 30 character space into three
    separate 10 character spaces should nicely do the trick.

    #+begin_src lisp :results output
      (loop repeat 10
            do (format t "~10:@<~a~>~10:@<~a~>~10:@<~a~>~%"
                       (random-animal)
                       (random-animal)
                       (random-animal)))

    #+end_src

    #+RESULTS:
    #+begin_example
      walrus     dog       dog    
       dog       dog     kangaroo 
      walrus     tick     tiger   
      walrus     dog       dog    
     kangaroo  kangaroo   walrus  
     kangaroo  kangaroo    dog    
       dog      walrus   kangaroo 
     kangaroo  kangaroo    dog    
     kangaroo    tick     walrus  
       dog      tiger      tick   
    #+end_example

    There we go.

    Let's say we wanted the left column left justified, the right
    right-justified, and the center centered? Well, =:= does things on
    the right, and =@= on the left. Together, they center. Easy
    enough.

    #+begin_src lisp :results output
      (loop repeat 10
            do (format t "~10@<~a~>~10:@<~a~>~10:<~a~>~%"
                       (random-animal)
                       (random-animal)
                       (random-animal)))
    #+end_src

    #+RESULTS:
    #+begin_example
    kangaroo   kangaroo     walrus
    tick         tick         tick
    kangaroo     tick         tick
    kangaroo     tick         tick
    kangaroo     tick          dog
    dog          tick     kangaroo
    kangaroo    walrus      walrus
    walrus       tick          dog
    kangaroo   kangaroo        dog
    walrus      walrus       tiger
    #+end_example

*** Iterating Through Lists Using Control Sequences
    The =format= function has so many features some people consider it
    to be a DSL. We'll go over DSLs more in Chapter 17.

    Like most programming languages, =format= can loop through
    data. This is done with =~{= and =~}=.

    #+begin_src lisp
      (defparameter *zoo* (loop repeat 10 collect (random-animal)))
    #+end_src

    #+RESULTS:
    : *ZOO*

    To go to the =*zoo*=, we can loop over the =*zoo*= using our
    control sequences.

    #+begin_src lisp :results output
      (format t "~{I see a ~a!~&~}" *zoo*)
    #+end_src

    #+RESULTS:
    #+begin_example
    I see a kangaroo!
    I see a tick!
    I see a walrus!
    I see a tick!
    I see a kangaroo!
    I see a dog!
    I see a kangaroo!
    I see a tick!
    I see a tick!
    I see a dog!
    #+end_example

    We can also do more than one item from the list per iteration.

    #+begin_src lisp :results output
      (format t "~{I see a ~a... or was it a ~a?~&~}" *zoo*)
    #+end_src

    #+RESULTS:
    : I see a kangaroo... or was it a tick?
    : I see a walrus... or was it a tick?
    : I see a kangaroo... or was it a dog?
    : I see a kangaroo... or was it a tick?
    : I see a tick... or was it a dog?

    However, there need to be enough items in the list to fully
    satisfy all of the control structures in an iteration. So, the
    above wouldn't work with an odd number in our =*zoo*=.

*** A Crazy Formatting Sequence for Creating Pretty Tables of Data
    As one last example, we're going to dissect a long control string
    to show 100 numbers in a pretty-printed table.

    Deconstructing the full control string of =|~{~<|~%|~,33:;~2d
    ~>~}|=:

    - =|=: We start by drawing our first pipe.
    - =~{=: Begin loop.
    - =~<=: Begin justification.
    - =|~%|=: A piece of the control string to be applied after a
      limit is reached.
    - =~,33:;=: The limit is 33 characters.
    - =~2d=: Display numbers, padding with space up to two digits.
    - =~>=: End Justification.
    - =~}=: End Loop.
    - =|=: Final Pipe.


    It's worth noting how this adapts to changes in the =~,33:;=
    sequence: If You increase it, the table will be adjusted to
    include more numbers in a row, but only every three times it's
    increased. It really is behaving as a limit before which the
    =|~%|= string is added.

    #+begin_src lisp :results output
      (format t "|~{~<|~%|~,33:;~2d ~>~}|" (loop for x below 100 collect x))
    #+end_src

    #+RESULTS:
    #+begin_example
    | 0  1  2  3  4  5  6  7  8  9 |
    |10 11 12 13 14 15 16 17 18 19 |
    |20 21 22 23 24 25 26 27 28 29 |
    |30 31 32 33 34 35 36 37 38 39 |
    |40 41 42 43 44 45 46 47 48 49 |
    |50 51 52 53 54 55 56 57 58 59 |
    |60 61 62 63 64 65 66 67 68 69 |
    |70 71 72 73 74 75 76 77 78 79 |
    |80 81 82 83 84 85 86 87 88 89 |
    |90 91 92 93 94 95 96 97 98 99 |
    #+end_example

*** Attack of the Robots!
    This is the game for this chapter. And interestingly, it is the
    first game that is not built using prose. I'm expected to read the
    code and type it in, like in the old days.

    This time we are building that PC Console Classic, =robots=.

    My biggest complaint is the size of the text in the image. It is
    teeny tiny.

    Interestingly, this looks like a single function? Odd.

    #+begin_src lisp :tangle robots.lisp
      (defun robots ()
        (loop named main ; By naming our loop "main", we can use "return
                                              ; from" to exit the loop early.
              with directions = '((q . -65) (w . -64) (e . -63)
                                  (a . -1)            (d . 1)
                                  (z . 63)  (x . 64)  (e . 65)) ; These are
                                              ; apparently the offsets for a
                                              ; 64-wide board; I've arranged
                                              ; them according to the keys
                                              ; they are assigned to.
              for pos = 544
              then (progn (format t "~%(qwe/asd/zxc) to move, (t)eleport, (l)eave:")
                          (force-output)
                          (let* ((c (read))
                                 (d (assoc c directions))); Perform a lookup
                                              ; of the input
                                              ; with assoc.
                            (cond (d (+ pos (cdr d)))
                                  ((eq 't c) (random 1024))
                                  ((eq 'l c) (return-from main 'bye)); Player
                                              ; wants to leave.
                                  (t pos))))
              for monsters = (loop repeat 10
                                   collect (random 1024)) ;; 10 robots,
              ;; random places.
              then (loop for mpos in monsters
                         collect (if (> (count mpos monsters) 1)
                                     mpos
                                     (cdar (sort (loop for (k . d) in directions
                                                       for new-mpos = (+ mpos d)
                                                       ; This is to
                                                       ; calculate something
                                                       ; called the
                                                       ; "Manhattan
                                                       ; Distance" to the
                                                       ; player. I will need
                                                       ; to look this up for
                                                       ; future reference.
                                                       collect (cons (+ (abs (- (mod new-mpos 64)
                                                                                (mod pos 64)))
                                                                        (abs (- (ash new-mpos -6)
                                                                                (ash pos -6))))
                                                                     new-mpos))
                                                 '<
                                                 :key #'car))))
              when (loop for mpos in monsters
                         always (> (count mpos monsters) 1))
              return 'player-wins
              do (format t
                         "~%|~{~<|~%|~,65:;~A~>~}|"; Was told not to worry
                                              ; about this yet; it looks
                                              ; very similar to the table
                                              ; formula above, will probably
                                              ; dissect when done typing
                                              ; this in.

                         (loop for p
                               below 1024 ; Loop through board positions.
                               collect (cond ((member p monsters)
                                              (cond ((= p pos) (return-from main 'player-loses))
                                                    ((> (count p monsters) 1) #\#)
                                                    (t #\A)))
                                              ((= p pos) #\@)
                                              (t #\ ))))))
    #+end_src

    #+RESULTS:
    : ROBOTS

*** What You've Learned
    This was a short-ish chapter! Even the game was only one big
    function.

    - Function =format= has 3 main paramters, in order: output,
      control string, value(s).
    - To embed lisp values in =format= strings, use =~s= or =~a=.
    - There are a lot of other control sequences, including loops and
      justifications.

** Chapter 12: Working with Streams


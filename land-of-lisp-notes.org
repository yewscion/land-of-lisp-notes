* Chapter 2
  These are my notes while working through the LoL book, interpersed
  with all of the code I copied during that work.

  Here's the example on the second page.

  #+begin_src lisp
    (+ 3 (* 2 4 ))
  #+end_src

  #+RESULTS:
  : 11

  The brief history outlines LISP as coming from a more mathematical
  background than a necessarily compsci background. John McCarthy
  created LISP in 1959. The goal was to make a programming language
  that was completely theoretical, but could produce elegant programs.

  It was apparently a fun project, nothing serious. Haha.


  #+begin_src lisp :results output
    (print "This File Contains")
    (print "Two Lines of Lisp")
  #+end_src

  #+RESULTS:
  : 
  : "This File Contains" 
  : "Two Lines of Lisp" 


  #+begin_src lisp 
    (defparameter *small* 1)
    (defparameter *big* 100)
  #+end_src

  #+RESULTS:
  : *BIG*

  #+begin_src lisp :results output
    (print *small*)
    (print *big*)
  #+end_src

  #+RESULTS:
  : 
  : 1 
  : 100 

  The book goes on to talk about global variables, and the differences
  between defparameter (overwrites old value if it exists) and defvar
  (does not overwrite existing values).

  #+begin_src lisp
    (defun guess-my-number ()
      (ash (+ *small* *big*) -1))
  #+end_src

  #+RESULTS:
  : GUESS-MY-NUMBER

  We've defined our first function.

  The ash fuction used here is for (a)rithmetic (s)hifting. We're
  using it because we are limiting our scope to whole numbers, and
  want to take the shortened average of our limits.

  This will take the binary representation of that sum and shift it
  right by one. This, in effect, halves the value: All of the bits
  move right, and we are in base 2.

  More generally, this operation can be mathematically expressed as
  floor(input*2^shift), with input being the first argument and shift
  being the second. (Note that we used a negative value here, and
  therefore took 2^-1, or 1/2: Halving the number.


  #+begin_src lisp
    (guess-my-number)
  #+end_src

  #+RESULTS:
  : 50


  This was the expected output.

  #+begin_src lisp
    (defun smaller ()
      (setf *big* (1- (guess-my-number)))
      (guess-my-number))
    
    (defun bigger ()
      (setf *small* (1+ (guess-my-number)))
      (guess-my-number))
  #+end_src

  #+RESULTS:
  : BIGGER

  Let's finish playing this round, now. My number will be 37.

  #+begin_src lisp
    (guess-my-number)
    (smaller)
    (bigger)
  #+end_src

  #+RESULTS:
  : 37

  Not bad. Now, to reset it, we'll need a function that sets those
  global variables back to their starting values. I'm going to try to
  write it without looking at the book, and then compare.

  #+begin_src lisp
    (defun my-reset (small big)
      (setf *small* small)
      (setf *big* big)
      (guess-my-number))
  #+end_src

  #+RESULTS:
  : MY-RESET

  Let's keep playing. New Number: 92.

  #+begin_src lisp
    (my-reset 1 100)
    (bigger)
    (bigger)
    (bigger)
    (smaller)
    (bigger)
    
  #+end_src

  #+RESULTS:
  : 92

  We've done it! Time to review the book; I wonder how different it
  will be?

  #+begin_src lisp
    (defun start-over ()
      (defparameter *small* 1)
      (defparameter *big* 100)
      (guess-my-number))
  #+end_src

  I like mine better, since it lets You pick new bounds. But I
  understand why they kept it simple here.

  To end off this chapter, we are discussing scope. Local variables
  use the `let` function.

  #+begin_src lisp
    (let ((a 5)
	  (b 6))
      (+ a b))
  #+end_src

  #+RESULTS:
  : 11

  Once the let function ends, we can no longer reference those
  variables as they were defined. (+ a b) will no longer work.

  There are two similar functions for local functions, flet and
  labels.
  
  #+begin_src lisp
    (flet ((f (n)
	     (+ n 10))
	   (g (n)
	     (- n 6)))
      (g (f 5)))
    
  #+end_src

  #+RESULTS:
  : 9

  flet is the simpler one, which behaves much the way let does. It's
  big limitation is that it cannot define multiple functions that
  reference each other, or a function that calls itself. For either of
  those, we need to use labels.

  #+begin_src lisp
    (labels ((a (n)
	       (+ n 5))
	     (b (n)
	       (+ (a n) 6)))
      (b 10))
  #+end_src

  #+RESULTS:
  : 21

  One reason to use flet over labels would be to use a global function
  of the same name: In labels, it would instead refer to itself.
* Chapter 3
  This chapter starts off by explaining the difference (and
  connection) between syntax and semantics in both human and
  programming languages.

  /Syntax/ is the rules a piece of text needs to follow to be valid in
  whatever language it is written in.

  /Semantics/ is the underlying thought or action present in a piece
  of text.

  Two pieces of text can have the /different/ syntax, but /identical/
  semantics, if they are in different languages.
  
  *Having a simple syntax is a defining feature of the Lisp language.*

  A /Reader/ is the part of a Lisp compiler or interpreter that reads
  in the code. In Lisp, this is simpler than in any other major
  programming language.

  #+begin_src lisp
    (defun square (n)
      (* n n))
  #+end_src

  #+RESULTS:
  : SQUARE

  The above function, =square=, is used to examine this further.

  This is a /function declaration/, which creates a new function that
  takes a number and returns its square. It consists of exactly two
  parts: /Parentheses/, and /symbols/. These two parts are arranged in
  a set of /nested lists/ that create the function.

  This is important, because *Lisp only has one way of organizing bits
  of code: it uses /parentheses/ to organize /symbols/ into /lists/.*

  We are going to examine these ideas further.
** Symbols

   In Lisp, a symbol is any stand alone word.

   They can be made up of letters ([A-Za-z]), numbers([0-9]), and
   symbols (+ - / * = < > ? ! _). They are case insensitive, though
   convention avoids typing in upper case.

   #+begin_src lisp
     (eq 'fooo 'FoOo)
   #+end_src

   #+RESULTS:
   : T
   
** Numbers
   
   Lisp supports both integers and floating point numbers.

   #+begin_src lisp :results output
     (print (+ 1 1.0))
     (print (expt 53 53))
     (print (/ 2 3))
   #+end_src

   #+RESULTS:
   : 
   : 2.0 
   : 24356848165022712132477606520104725518533453128685640844505130879576720609150223301256150373 
   : 2/3 

   If You work with both integers and floating point numbers, the
   integers will become "poisoned" and a floating point number will be
   returned.

   Lisp is good with big numbers.

   Lisp also can return ratios (dividing integers) as well as decimal
   numbers (dividing floating point numbers).

** Strings

   To indicate a string in Lisp, surround it with double quotes (").


   #+begin_src lisp
     (princ "Tutti Frutti")
   #+end_src

   #+RESULTS:
   : Tutti Frutti
   
   (The =princ= function does /not/ output a newline, and is therefore
   less READable than the =print= function.)
   
   You can also include /escaped characters/ using standard backslash
   notation.


** Code and Data Modes

There are two modes in Lisp: /Code Mode/ and /Data Mode/.

In /Code Mode/, lists need to be structured as a /form/: with the
first item in the list being a /command/ and the rest being the
/parameters/. For the form =(expt 2 3)=, =expt= is the command, and
the parameters are the list =(2 3)=. It therefore results in =8=.

#+begin_src lisp
  (expt 2 3)
#+end_src

#+RESULTS:
: 8

When lisp reads the parameters, it stays in /Code Mode/. This way, You
can nest forms indefinitely, as You may need to.

#+begin_src lisp
  (expt 2 (+ 3 4))
#+end_src

#+RESULTS:
: 128

*Inner forms are always executed before outer forms.*

You can engage /Data Mode/ by placing a single quote (') in front of
the leading parenthesis (like this: ='(expt 2 3)=). This tells Lisp to
treat the enclosed data as a plain list: do /not/ evaluate any
functions that may be inside.

** Cons Cells
Lists hold the program together, but what is the mortar that ties the
bricks of symbols into a list? Cons Cells.

[ ][ ]
 V  V

Think of a Cons cell as a pair of boxes that can point to other
things. Cons cells can point to numbers, strings, lists, or other cons
cells; they are the true building blocks of the language. Everything
else is an abstraction built on top of them.

In brief, a cons cell can be thought of as similar to a linked list
item.

** Cons Function

There are three basic functions for interacting with lists in Lisp:
=cons=, =car=, and =cdr=.

=cons= is how You link items together. It can link any two
symbols. The second item is usually a list.

#+begin_src lisp
  (cons 'chicken 'pork)
#+end_src

#+RESULTS:
: (CHICKEN . CAT)

It returns the Cons cell it creates, printing it in the dotted pair
notation: =(CHICKEN . CAT)=.

If the second item is =nil=, then the list is a one-symbol list like
=(CHICKEN)=. This is really still a cons cell in the form of =(CHICKEN
. nil)=, but =nil= is used to end lists in Lisp. It's a special use.

The result is shown as a list because Lisp always goes out of its way
to hide the Cons cells if it can. Since a Cons cell with =nil= at the
end is a list, it shows the list.

The /empty list/, =()= is synonymous with =nil=.

This is incidently why the second item in a call to =cons= is usually
a list: This, in effect, adds the first item to the front of the
already-properly-constructed list.

#+begin_src lisp :results value list
  (cons 'pork (cons 'beef (cons 'chicken ())))
#+end_src

#+RESULTS:
- PORK
- BEEF
- CHICKEN

In short: *A chain of cons cells and a list are the same thing in
Lisp*.


** Car and Cdr
Lists are just long chains of two item cells.

The =car= function returns the first thing, and the =cdr= function
returns the last thing.

There are extension functions up to four deep, that allow for pulling
specific data out of a list.

#+begin_src lisp
  (cadadr '((perl c cpp) (lisp clojure haskell) scheme)) 
#+end_src

#+RESULTS:
: CLOJURE

In short, we've learned:

- Parentheses are there to keep syntax down.
- Lists are just groups of connected cons cells.
- You can create lists using =cons=.
- You can inspect parts of a list using =car= and =cdr=.


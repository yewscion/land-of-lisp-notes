#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: land-of-lisp-notes
#+date: <2021-08-12 Thu>
#+author: rodnchr
#+email: rodnchr@ua6ff97dd3b1950.ant.amazon.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.50 (Org mode 9.4.6)
#+PROPERTY: header-args :results replace verbatim value
#+PROPERTY: header-args dot :cmd neato
These are my notes while working through the LoL book, interpersed
with all of the code I copied during that work.

* Part I - Lisp is Power
** Chapter 1 - Getting Started with Lisp
   I mostly read through this chapter before taking notes. However, it
   mostly focuses on Common Lisp as a concept and the installation
   progress. I may come back at the end and take real notes, but for
   now I am comfortable leaving it as is.
   Here's the example on the second page.

   #+begin_src lisp
     (+ 3 (* 2 4 ))
   #+end_src

   The brief history outlines LISP as coming from a more mathematical
   background than a necessarily compsci background. John McCarthy
   created LISP in 1959. The goal was to make a programming language
   that was completely theoretical, but could produce elegant programs.

   It was apparently a fun project, nothing serious. Haha.


   #+begin_src lisp :results output
     (print "This File Contains")
     (print "Two Lines of Lisp")
   #+end_src

** Chapter 2 - Creating Your First Lisp Program
   We're going to be developing a guess-my-number game.
*** Defining Global Variables
   #+begin_src lisp 
     (defparameter *small* 1)
     (defparameter *big* 100)
   #+end_src

   #+begin_src lisp :results output
     (print *small*)
     (print *big*)
   #+end_src

   The book goes on to talk about global variables, and the differences
   between defparameter (overwrites old value if it exists) and defvar
   (does not overwrite existing values).
*** Defining Global Functions
   #+begin_src lisp
     (defun guess-my-number ()
       (ash (+ *small* *big*) -1))
   #+end_src

   We've defined our first function.

   The ash fuction used here is for (a)rithmetic (s)hifting. We're
   using it because we are limiting our scope to whole numbers, and
   want to take the shortened average of our limits.

   This will take the binary representation of that sum and shift it
   right by one. This, in effect, halves the value: All of the bits
   move right, and we are in base 2.

   More generally, this operation can be mathematically expressed as
   floor(input*2^shift), with input being the first argument and shift
   being the second. (Note that we used a negative value here, and
   therefore took 2^-1, or 1/2: Halving the number.


   #+begin_src lisp
     (guess-my-number)
   #+end_src

*** Subfunctions
   This was the expected output.

   #+begin_src lisp
     (defun smaller ()
       (setf *big* (1- (guess-my-number)))
       (guess-my-number))
    
     (defun bigger ()
       (setf *small* (1+ (guess-my-number)))
       (guess-my-number))
   #+end_src

   Let's finish playing this round, now. My number will be 37.

   #+begin_src lisp
     (guess-my-number)
     (smaller)
     (bigger)
   #+end_src

   Not bad. Now, to reset it, we'll need a function that sets those
   global variables back to their starting values. I'm going to try to
   write it without looking at the book, and then compare.

   #+begin_src lisp
     (defun my-reset (small big)
       (setf *small* small)
       (setf *big* big)
       (guess-my-number))
   #+end_src

   Let's keep playing. New Number: 92.

   #+begin_src lisp
     (my-reset 1 100)
     (bigger)
     (bigger)
     (bigger)
     (smaller)
     (bigger)
    
   #+end_src

   We've done it! Time to review the book; I wonder how different it
   will be?

   #+begin_src lisp
     (defun start-over ()
       (defparameter *small* 1)
       (defparameter *big* 100)
       (guess-my-number))
   #+end_src

   I like mine better, since it lets You pick new bounds. But I
   understand why they kept it simple here.
*** Scope
   To end off this chapter, we are discussing scope. Local variables
   use the `let` function.

   #+begin_src lisp
     (let ((a 5)
	   (b 6))
       (+ a b))
   #+end_src

   Once the let function ends, we can no longer reference those
   variables as they were defined. (+ a b) will no longer work.

   There are two similar functions for local functions, flet and
   labels.
  
   #+begin_src lisp
     (flet ((f (n)
	      (+ n 10))
	    (g (n)
	      (- n 6)))
       (g (f 5)))
    
   #+end_src

   flet is the simpler one, which behaves much the way let does. It's
   big limitation is that it cannot define multiple functions that
   reference each other, or a function that calls itself. For either of
   those, we need to use labels.

   #+begin_src lisp
     (labels ((a (n)
		(+ n 5))
	      (b (n)
		(+ (a n) 6)))
       (b 10))
   #+end_src

   One reason to use flet over labels would be to use a global function
   of the same name: In labels, it would instead refer to itself.
** Chapter 3 - Exploring the Syntax of Lisp Code
   This chapter starts off by explaining the difference (and
   connection) between syntax and semantics in both human and
   programming languages.
*** Syntax and Semantics
   /Syntax/ is the rules a piece of text needs to follow to be valid in
   whatever language it is written in.

   /Semantics/ is the underlying thought or action present in a piece
   of text.

   Two pieces of text can have the /different/ syntax, but /identical/
   semantics, if they are in different languages.
  
   *Having a simple syntax is a defining feature of the Lisp language.*

   A /Reader/ is the part of a Lisp compiler or interpreter that reads
   in the code. In Lisp, this is simpler than in any other major
   programming language.

   #+begin_src lisp
     (defun square (n)
       (* n n))
   #+end_src

   The above function, =square=, is used to examine this further.

   This is a /function declaration/, which creates a new function that
   takes a number and returns its square. It consists of exactly two
   parts: /Parentheses/, and /symbols/. These two parts are arranged in
   a set of /nested lists/ that create the function.

   This is important, because *Lisp only has one way of organizing bits
   of code: it uses /parentheses/ to organize /symbols/ into /lists/.*

   We are going to examine these ideas further.
*** Symbols

    In Lisp, a symbol is any stand alone word.

    They can be made up of letters ([A-Za-z]), numbers([0-9]), and
    symbols (+ - / * = < > ? ! _). They are case insensitive, though
    convention avoids typing in upper case.

    #+begin_src lisp
      (eq 'fooo 'FoOo)
    #+end_src
   
*** Numbers
   
    Lisp supports both integers and floating point numbers.

    #+begin_src lisp :results output
      (print (+ 1 1.0))
      (print (expt 53 53))
      (print (/ 2 3))
    #+end_src

    If You work with both integers and floating point numbers, the
    integers will become "poisoned" and a floating point number will be
    returned.

    Lisp is good with big numbers.

    Lisp also can return ratios (dividing integers) as well as decimal
    numbers (dividing floating point numbers).

*** Strings

    To indicate a string in Lisp, surround it with double quotes (").


    #+begin_src lisp
      (princ "Tutti Frutti")
    #+end_src
   
    (The =princ= function does /not/ output a newline, and is therefore
    less READable than the =print= function.)
   
    You can also include /escaped characters/ using standard backslash
    notation.

*** Code and Data Modes

 There are two modes in Lisp: /Code Mode/ and /Data Mode/.

 In /Code Mode/, lists need to be structured as a /form/: with the
 first item in the list being a /command/ and the rest being the
 /parameters/. For the form =(expt 2 3)=, =expt= is the command, and
 the parameters are the list =(2 3)=. It therefore results in =8=.

 #+begin_src lisp
   (expt 2 3)
 #+end_src

 When lisp reads the parameters, it stays in /Code Mode/. This way, You
 can nest forms indefinitely, as You may need to.

 #+begin_src lisp
   (expt 2 (+ 3 4))
 #+end_src

 *Inner forms are always executed before outer forms.*

 You can engage /Data Mode/ by placing a single quote (') in front of
 the leading parenthesis (like this: ='(expt 2 3)=). This tells Lisp to
 treat the enclosed data as a plain list: do /not/ evaluate any
 functions that may be inside.

*** Cons Cells
 Lists hold the program together, but what is the mortar that ties the
 bricks of symbols into a list? Cons Cells.

 [ ][ ]
  V  V

 Think of a Cons cell as a pair of boxes that can point to other
 things. Cons cells can point to numbers, strings, lists, or other cons
 cells; they are the true building blocks of the language. Everything
 else is an abstraction built on top of them.

 In brief, a cons cell can be thought of as similar to a linked list
 item.

*** Cons Function

 There are three basic functions for interacting with lists in Lisp:
 =cons=, =car=, and =cdr=.

 =cons= is how You link items together. It can link any two
 symbols. The second item is usually a list.

 #+begin_src lisp
   (cons 'chicken 'pork)
 #+end_src

 It returns the Cons cell it creates, printing it in the dotted pair
 notation: =(CHICKEN . CAT)=.

 If the second item is =nil=, then the list is a one-symbol list like
 =(CHICKEN)=. This is really still a cons cell in the form of =(CHICKEN
 . nil)=, but =nil= is used to end lists in Lisp. It's a special use.

 The result is shown as a list because Lisp always goes out of its way
 to hide the Cons cells if it can. Since a Cons cell with =nil= at the
 end is a list, it shows the list.

 The /empty list/, =()= is synonymous with =nil=.

 This is incidently why the second item in a call to =cons= is usually
 a list: This, in effect, adds the first item to the front of the
 already-properly-constructed list.

 #+begin_src lisp :results value list
   (cons 'pork (cons 'beef (cons 'chicken ())))
 #+end_src

 In short: *A chain of cons cells and a list are the same thing in
 Lisp*.

*** Car and Cdr
 Lists are just long chains of two item cells.

 The =car= function returns the first thing, and the =cdr= function
 returns the last thing.

 There are extension functions up to four deep, that allow for pulling
 specific data out of a list.

 #+begin_src lisp
   (cadadr '((perl c cpp) (lisp clojure haskell) scheme)) 
 #+end_src

 In short, we've learned:

 - Parentheses are there to keep syntax down.
 - Lists are just groups of connected cons cells.
 - You can create lists using =cons=.
 - You can inspect parts of a list using =car= and =cdr=.


*** List
    Common Lisp has many functions built on top of the basic three
    (=cons=, =car=, and =cdr=).

    One convenient one is =list=. It does all of the work to build a
    list at once, as that is a common pattern.

    #+begin_src lisp
      (list 'pork 'beef 'chicken)
    #+end_src

*** Nested Lists
    Lists can contain other lists.

    The first two commands are equivalent to each of the last two
    commands, in that they all isolate the first nested list and then
    return a list consisting of the final two elements of the first
    list.
    #+begin_src lisp :results output
      (print (car '((peas carrots tomatoes) (pork beef chicken))))
      (print (cdr '(peas carrots tomatoes)))
      (print (cdr (car '((peas carrots tomatoes) (pork beef chicken)))))
      (print (cdar '((peas carrots tomatoes) (pork beef chicken))))
    #+end_src

    You can also create the initial list from above using /solely/
    =cons=, which is really what the above is doing behind the scenes.

    #+begin_src lisp
      (cons
       (cons 'peas
	     (cons 'carrots
		   (cons 'tomatoes
			 ())))
       (cons
	(cons 'pork
	      (cons 'beef
		    (cons 'chicken
			  ())))
	()))
    #+end_src

    Here are some c*r functions operating on the list: ='((peas carrots
    tomatoes) (pork beef chicken) duck)=. Note that these only go 4
    levels deep: Anything deeper than that will need to be written by
    hand.
    #+begin_src lisp :results output
      (print (cddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (caddr '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cddar '((peas carrots tomatoes) (pork beef chicken) duck)))
      (print (cadadr '((peas carrots tomatoes) (pork beef chicken) duck)))
    #+end_src

*** What we've Learned
    We discussed basic Lisp syntax, including the benefits of
    parentheses, lists, and cons/car/cdr.
* Part II - Lisp is Symmetry
** Chapter 4 - Making Decisions with Conditions
   Now we're finally learning some flow control.
*** Symmetry of nil and ()
    *Lisp commands and data structures are imbued with symmetry in
    every conceivable way.*
*** Empty Equals False
    Lisp philosophy strongly emphasizes lists. Empty Lists are treated
    as a false value when evaluating a condition.

    #+begin_src lisp
      (if '()
	  'i-am-true
	  'i-am-false)
    #+end_src

    Any non-empty list will evaluate to true.

    #+begin_src lisp
      (if '(1)
	  'i-am-true
	  'i-am-false)
    #+end_src

    This allows us to process /recursion/ very easily, by taking items
    from the front of a list and sending the rest back to the function
    in the tail call.

    Here's a classic lisp function that returns the length of a list
    using the recursion process above.

    #+begin_src lisp
      (defun my-length (list)
	(if list
	    (1+ (my-length (cdr list)))
	    0))
      
      (my-length '(list with four symbols))
    #+end_src

    Lists in Lisp are recursive to begin with (conses of conses of
    conses) so consuming a list this way is a natural and efficient
    progression. However, calling Yourself recursively can sometime
    impact the speed of a fuction. There is a special kind of
    recursion to mitigate this problem that will be discussed in
    *Chapter 14*.
*** The Four Disguises of ()
    The empty list is not only /something/ that evaluates to
    false. =()= is the *only* false value in Common Lisp. *Any value
    not equivalent to an empty list will be considered a true value.*

    #+begin_src lisp :results output
      (print (eq '() nil))
      (print (eq '() ()))
      (print (eq '() 'nil))
    #+end_src

    ='()=, =()=, ='nil=, and =nil= are all equavalent, and all
    represent an empty list. =()= and =nil= are special forms, because
    they seem to violate the rules of Lisp syntax. However, they are
    all in the Common Lisp spec: ='()= is a basic, empty list. ='nil=
    exists due to the requirements of the Common Lisp spec to provide
    a common target for falsity. =nil= evaluates to itself, or rather
    ='nil=, which is treated as an empty list. =()= evaluates
    evaluates to ='nil= due to a requirement in the spec for =()= and
    =nil= to be treated the same.

    This is different from Scheme. In Scheme, empty lists are simply
    empty lists, and are not treated as values with falsity. However,
    in Common Lisp, they are.
*** The Conditionals: if and Beyond
    The standard =if= command exists in lisp.

    The format of the function is basically:

    (if <condition> <then statement> <else statement>)

    However, the else statement is optional. In the case of an omitted
    else statement being lead to, then nothing is executed and the
    value =nil= is returned.
    #+begin_src lisp :results output
      (if (= (+ 1 2) 3)
	  (print "yup")
	  (print "nope"))
      (if (= (+ 1 2) 4)
	  (print "yup")
	  (print "nope"))
      (if (= (+ 1 2) 3)
	  (print "yup"))
      (if (= (+ 1 2) 4)
	  (print "yup"))
    #+end_src

    As =nil= is equivalent to an empty list, it then becomes obvious
    that testing for an empty list is important. And, because an empty
    list is treated as =false=, it is trivial to test for one.

    #+begin_src lisp :results output
      (if '(1)
	  (print "Not Empty")
	  (print "Empty"))
      (if '()
	  (print "Not Empty")
	  (print "Empty"))
      (if (if (= (+ 1 2) 4)
	      (print "yup"))
	  (print "This won't happen.")
	  (print "The original value was nil."))
    #+end_src

    Usually, when a function is executed in lisp, all of the
    expressions after a function are evaluated before the function
    itself is. However, =if= doesn't follow that rule. This makes
    things like the following possible, which includes an illegal
    command (dividing by zero).

    #+begin_src lisp
      (if (oddp 5)
	  'odd-number
	  (/ 1 0))
    #+end_src

    Since only the chosen expression is evaluated, the =(/ 1 0)= else
    statement is never touched, and therefore does not cause an error.

    This rulebreaking behavior is possible because the =if= function
    is considered a /special form/, which gives it special privileges
    (like not preevaluating all of its arguments). *Conditional
    Statements in Lisp are Typically Special Forms.* Special forms are
    usually commands that are baked into a language.

    Note: /Macros,/ which we'll learn about in Chapter 16, are
    something like user-created special forms.

    The other important thing to note about =if= is that it is only
    capable of doing one thing, since only one expression (either
    =then= or =else=) is ever evaluated. It is impossible to do two
    things with a single =if=.

    This is considered a good thing in Functional Programming, though
    in other paradigms is a limitation that may be fairly prominent.

    Of course, there is a way around it. There's another special form,
    =progn=, that allows You to wedge in more commands to that single
    expression that gets evaluated. Per the definition in the
    [[http://clhs.lisp.se/Body/s_progn.htm][HyperSpec]], as each form is evaluated, all return values are
    ignored aside from the final form's. Per the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/progn.html][Elisp Equivalent]], the
    preceding forms are evaluated primarily for their side effects
    (hence why functional programming may not make much use of
    =progn=.

    #+begin_src lisp :results output
      (defvar *number-was-odd* nil)
      (if (oddp 5)
	  (progn (setf *number-was-odd* t)
		 (print *number-was-odd*)
		 (print "odd number"))
	  'even-number)
    #+end_src

*** Beyond if: when and unless
    There are a number of commands that include an /implicit
    progn/. We'll look at two here, =when= and =unless=.

    With =when=, all enclosed expressions are evaluated /when/ the
    condition is true. With =unless=, all enclosed expressions are
    evaluated /unless/ the condition is true.

    The trade off with these two functions is they will only return
    =nil= and do nothing when the condition is the opposite of their
    expected state: That is, when =when= has a false condition and
    when =unless= has a true condition, nothing will happen and the
    statement will return =nil=.

    #+begin_src lisp :results output
      (when (oddp 5)
	(print "Yup")
	(print "5 is indeed Odd."))
      (unless (oddp 4)
	(print "Yup")
	(print "4 is not Odd."))
      (when (oddp 4)
	(print "Yup")
	(print "5 is indeed Odd."))
      (unless (oddp 5)
	(print "Yup")
	(print "4 is not Odd."))
    #+end_src

*** The Command that Does it All: cond
    If You don't want to compromise, and want the greatest degree of
    control over Your flow, =cond= does not have any
    trade-offs... Aside from its complexity.

    *The =cond= form is the classic way to do branching in Lisp.*

    It allows implicit progns, can handle more than one branch, and
    can even evaluate multiple conditions.

    The body of a =cond= statement uses a layer of parentheses to
    separate its branches. The first expression in each parantesized
    part contains the conditional statement for making that branch
    active. The conditions are always checked from the top down, so
    *the first successful branch defines the behavior of a =cond=
    statement.*

    To define a base case, it is a common idiom to include =t= as the
    final conditional statement, so that if that branch is reached it
    is always executed.

    This reminds me a lot of a switch-case statement from C++. Or
    rather, how I wish the switch-case statement from C++ behaved.

    Here's an example, where the supplied person's name is compared to
    two defined names and a base case before the branch is
    chosen. Note that the branches can contain more than one
    expression, due to the implicit =progn=.
    #+begin_src lisp :results output
      (defvar *arch-enemy* nil)n
      (defun pudding-eater (person)
	(cond
	  (
	   (eq person 'henry)
	   (setf *arch-enemy* 'stupid-lisp-alien)
	   (print "Curse You Lisp alien - You ate my pudding!")
	   )
	  (
	   (eq person 'johnny)
	   (setf *arch-enemy* 'useless-old-johnny)
	   (print "I hope You choked on my Pudding, Johnny.")
	   )
	  (
	   t
	   (print "Why'd You eat my pudding, stranger?")
	   )))
      (pudding-eater 'johnny)
      (print *arch-enemy*)
      (pudding-eater 'george-clooney)
    #+end_src

*** Branching with case
    As I noted myself, the =cond= example reminded me of switch-case
    in C++. It is so commonly used to simply compare a single input to
    a variety of cases, that there is a special form for that specific
    use case: the =case= form.

    The benefits to using the =case= form are mostly to reduce the
    syntactic complexity in a program. There are also (depending on
    the implementation used) a variety of efficiency optimizations
    that may come with using =case= over =cond=.

    *Warning:* Because the =case= command uses =eq= internally to
     compare values, =case= is usually only used for branching on
     symbol values. It cannot be used to branch on string values,
     among other things. The next section goes over this in more
     detail.

     Below is the same program as in the =cond= section, but edited to
     use =case= instead.

     #+begin_src lisp :results output
      (defun pudding-eater-case (person)
	(case person
	  (
	   (henry)
	   (setf *arch-enemy* 'stupid-lisp-alien)
	   (print "Curse You Lisp alien - You ate my pudding!")
	   )
	  (
	   'johnny
	   (setf *arch-enemy* 'useless-old-johnny)
	   (print "I hope You choked on my Pudding, Johnny.")
	   )
	  (
	   otherwise
	   (print "Why'd You eat my pudding, stranger?")
	   )))
      (pudding-eater-case 'johnny)
      (print *arch-enemy*)
      (pudding-eater-case 'george-clooney)
     #+end_src
*** Using the Stealth Conditionals: and and or
    The conditionals =and= and =or= are simple mathematical
    operators. They let You chain conditionals together.

    The =and= form lets You check multiple conditionals at the same
    time, and only returns true if they are all true.

    The =or= form lets You check multiple conditionals at the same
    time, and only returns false if none of them are true.
    
    #+begin_src lisp
      (print (and (oddp 7) (oddp 5) (oddp 3)))
      (print (and (oddp 6) (oddp 5) (oddp 3)))
      (print (or (oddp 8) (oddp 7) (oddp 6)))
      (print (or (oddp 8) (oddp 6) (oddp 4)))
    #+end_src

    However, due to the way Common Lisp handles =true= and =false=, we
    can use =and= and =or= for conditional behavior.

    Here is an example of how we can do this with =or=. We define a
    global variable =*is-it-even*= and =or= the command to set it to
    =t= with the numbers we are checking.

    #+begin_src lisp
      (defparameter *is-it-even* nil)
      (print (or (oddp 4) (setf *is-it-even* t)))
      (print *is-it-even*)
    #+end_src

    However, if we do the same with an odd number, the global variable
    remains unchanged.

    #+begin_src lisp
      (defparameter *is-it-even-2* nil)
      (print (or (oddp 5) (setf *is-it-even-2* t)))
      (print *is-it-even-2*)
    #+end_src

    This is because Common Lisp uses /Shortcut Boolean Evaluation/,
    which basically means that once Lisp determines an earlier
    statement in a list of =or= values is true, it returns and leaves
    the rest unevaluated. In short, *You can use =or= to run a command
    /only/ if all prior conditionals were false.*

    You can use =and= similarly, however the shortcut for =and= is the
    opposite: *You can use =and= to run a command /only/ if all prior
    conditionals were true.*

    It is considered clean code to avoid this, however. If You want
    the cleanest, most maintainable code possible, only use these
    functions on expressions that are designed to return a Boolean
    value.
*** Using Functions that Return More than Just the Truth
    Let's take a look at another function: the =member= command can be
    used to check if an item exists in a list.

    #+begin_src lisp
      (if (member 1 '(3 4 1 5))
		  (print "One is in the List")
		  (print "One is not in the List"))
    #+end_src
    

    However, the /way/ it returns true is unconventional and
    Lisp-driven:

    #+begin_src lisp
      (print (member 1 '(3 4 1 5)))
    #+end_src

    The main question for any Lisper when they write a function that
    returns true or false is: *Is there anything else I could return
    other than just t?*

    This is because *all non-nil values evaluate to true*. Returning
    more than t is essentially free.

    The main reason the function =member= returns the tail of the
    original list and not just the found value on a true result is a
    specific edge case: looking for /nil/ in a list (which would
    evaluate to false if it returned just /nil/.

    There is another notable fuction for how it uses a rich return
    value: =find-if=.

    #+begin_src lisp
      (print (find-if #'oddp '(2 4 5 6)))
      (if (find-if #'oddp '(2 4 5 6))
	  (print "There is an odd number.")
	  (print "There is no odd number."))
      
    #+end_src

    The =find-if= function takes another function as an argument (as
    it is a higher-order function, to be discussed in greater depth in
    chapters 7 and 14) and returns the first (if any) member that
    causes the supplied function to evaluate to true from the supplied
    list.

    Note, however, that the edge case mentioned above (returning
    /nil/) is not accounted for here.

    #+begin_src lisp
      (print (find-if #'null '(2 4 nil 6)))
    #+end_src

    If used as a conditional statement, a true result will evaluate to
    false as well as a false result. This is bad, but a necessary evil
    for =find-if= to work consistently.
*** Comparing Stuff: eq, equal, and More
    Asymmetry is present when comparing things, unfortunately.

    There are a number of functions to compare things; the most
    commonly used ones are: =equal=, =eq=, ===, =string-equal=, and
    =equalp=. Knowing when to use each is important.
**** Conrad's Rule of Thumb for Comparing Stuff
     When in doubt, following these two steps will usually get You by.

     1. Use =eq= when comparing symbols.
     2. Use =equal= for everything else.
**** Eq
     The =eq= function is the simplest comparison function, which
     makes it very fast. However, it struggles with items that are not
     symbols.

     That said, using =eq= is a must if the values being compared are
     known to be symbols.
     
     #+begin_src lisp
       (defparameter *fruit* 'apple)
       (cond ((eq *fruit* 'apple) (print "It's an Apple"))
	     ((eq *fruit* 'orange) (print "It's an Orange")))
     #+end_src

     It's worth noting that =eq= can be used to compare conses as
     well, though it will only return true for the *exact same call*
     to cons. Even if the cons looks similar after the fact, it will
     return /nil/.
**** Equal
     If You aren't dealing with two symbols, or such a case cannot be
     guaranteed by the function You are writing, it is better to use
     =equal=. It tells You when two things are /isomorphic/, meaning
     that they look the same. It works for all basic Lisp datatypes.

     #+begin_src lisp
       (print (equal 'apple 'apple))
       (print (equal (list 1 2 3) (list 1 2 3)))
       (print (equal '(1 2 3) (cons 1 (cons 2 (cons 3 ())))))
       (print (equal 5 5))
       (print (equal 2.5 2.5))
       (print (equal "foo" "foo"))
       (print (equal #\a #\a))
     #+end_src

     The =equal= function can compare most things, so it is a safe
     choice, if an inefficient one.
**** Eql
     The =eql= command is very similar to =eq=, but it also handles
     the comparison of numbers and characters (leaving out things like
     strings and lists).

     #+begin_src lisp
       (print (eql 'foo 'foo))
       (print (eql 3.4 3.4))
       (print (eql #\a #\a))
     #+end_src
**** Equalp
     The =equalp= command is very similar to =equal=, except it can
     handle more difficult comparisons, like strings with varying
     capitalizations or integers to floats.

     #+begin_src lisp
       (print (equalp "Bob Smith" "bob smith"))
       (print (equalp 0 0.0))
     #+end_src
**** Others
     The === function handles numbers only. The =string-equal= handles
     strings only. The =char-equal= function handles characters only.

     There are others as well, but they are not common. There are a
     bunch of different function.
*** What We've Learned
    This chapter was all about branching through conditionals: How
    =nil=, ='nil=, =()=, and ='()= are all the same, and all treated
    as false. List Eaters are really easy to make. Lisp uses lazy
    evaluation. Using =cond= lets You do really cool conditionals. And
    comparing things is complicated.
** Chapter 5 - Building a Text Game Engine
   This is interesting: This chapter begins by stressing that handling
   text is not a computer's strength. As someone who has grown up
   belly-deep in ASCII and UTF, this is an interesting statement to
   wrestle with. I live my life through plaintext, for the most part,
   and yet this chapter considers text to be a necessary evil best
   kept to a minimum.
*** The Wizard's Adventure Game
    As is obvious by the Chapter title, we are making a game here. In
    this game, You are a wizard's apprentice, exploring that wizard's
    house. The game will not be complete until Chapter 17, but when it
    is You will be able to solve puzzles and win a magical donut.
**** Basic Requirements
     
    There is a picture that describes the world we are creating. Three
    areas (rooms): a living room, an attic, and a garden. There is a
    ladder connecting the living room to the attic, and a door
    connecting the garden to the living room. There is no immediate
    path between the garden and the attic.

    We'll need a few actions as well as the world around us: Looking,
    Moving, Taking Objects, and Performing Actions on Objects Held. In
    this chapter, we are going over the first three of these.

    When Looking Around (the first action), there are three kinds of
    things to see in any location:

    - Scenery
    - Exits
    - Objects
*** Describing the Scenery with an Association List
    As our world is simple, we can describe the scenery using one
    global variable.

    Below, we define this variable: =*nodes*=. It contains the list
    and description of our three places. In essence, it gives us a way
    to look up a piece of data (the description) attached to a
    specific /key/ (in this case, the room name). This is called an
    /Association List/, or an /alist/, and will be discussed more in
    Chapter 7.

    One thing to note is the absence of strings. The data below is
    encoded entirely in more fundamental datatypes: Only Symbols and
    Lists. This is to illustrate that *by keeping Your source data
    structures free from assumptions regarding the output format from
    the start, Your coding can take full advantage of Your programming
    language.* We'll be formatting these lists and symbols into text
    in the next chapter.

    Note however that this is not a limitation of Lisp—You can work
    directly with strings if You prefer (and will be, in Chapter 11).
    #+begin_src lisp :results value
      (defparameter *nodes* '((living-room (You are in the living-room. A
      wizard is snoring loudly on the couch.))
			     (garden (You are in a beautiful garden. There
			     is a well in front of You.))
			     (attic (You are in the attic. There is a giant
			     welding torch in the corner.))))
    #+end_src

*** Describing the Location
    The way to look up data in an /alist/ is the =assoc= function.

    #+begin_src lisp :results value
      (assoc 'garden *nodes*)
    #+end_src

    We can define a wrapper function around =assoc= that will return
    the requested information only. Note the use of =cadr=.

    #+begin_src lisp :results value
      (defun describe-location (location nodes)
	(cadr (assoc location nodes)))
    #+end_src

    And now we can use it to return /only/ the description.

    Note that this function is /referentially transparent/: With the
    same input, it will produce the same output, and it does nothing
    outside of its scope and does not have side effects.

    This book does not use those words, merely relating this to the
    functional programming style.
    #+begin_src lisp :results value
      (describe-location 'living-room *nodes*)
    #+end_src

*** Describing the Paths
    We're going to store the paths in a separate global variable
    (another /alist/).

    #+begin_src lisp :results value
      (defparameter *edges* '((living-room (garden west door)
			       (attic upstairs ladder))
			      (garden (living-room east door))
			      (attic (living-room downstairs ladder))))
    #+end_src

    With this structure, we can now access things using a standard
    phrase.

    Note the use of a backtick to enable data mode here. This is
    necessary, because we are using something called /quasiquoting/,
    where we can flip back and forth between data mode and code mode.

    I personally think it's cool how it looks like a little lever on
    the outside of the parens, with up (not active) being in data mode
    and down (active) being in code mode.

    This flipping is one of the many benefits to working in symbols
    instead of directly in strings.
    
    #+begin_src lisp :results value
      (defun describe-path (edge)
	`(there is a ,(caddr edge) going ,(cadr edge) from here.))
    #+end_src

    We are then going to compose this function into one that lets us
    describe all the paths in a single location. That function will be
    =describe-paths=.

    It will do the following:

    1. Find the relevant edges.
    2. Convert the edges to descriptions.
    3. Join the descriptions.
       
    #+begin_src lisp :results value
      (defun describe-paths (location edges)
	(apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))
    #+end_src

    Let's test that right away.

    #+begin_src lisp :results value
      (describe-paths 'living-room *edges*)
    #+end_src

    Let's step through the above-mentioned steps.
**** Find the Relevant Edges
     The inner part, =(cdr (assoc location edges))=, is the focus
     here.

     Because of our data structure (an /alist/), we can get the full
     list of edges for a specific room using =assoc=. And because of
     the structure of lists and the /way/ we stored the data in our
     /alist/, we can simply call =cdr= to extract the list of edges.
**** Convert the Edges to Descriptions
     Stepping out a bit, we'll now focus on =(mapcar #'describe-path
     result-from-step-1)=.

     The =mapcar= function takes a function and a list, and applies
     that function to each member of the list. According the the
     documentation, it can actually take more than one list, as well.

     #+begin_src lisp :results value
       (mapcar #'sqrt '(1 2 3 4 5))
     #+end_src

     =mapcar= is a /higher-order function/, which is a function that
     can take other functions as parameters.

     The =#'x= notation is a shorthand for =(function x)=. Calling
     functions as values in Common Lisp requires this, as Common Lisp
     is a /Lisp-2/ language: functions are in a different namespace
     than variables, and thus can have the same names. We'll discuss
     this difference, and namespaces in general, in depth in
     Chapter 16. Scheme, in contrast to Common Lisp, is a /Lisp-1/,
     which basically means there is only one namespace, and therefore
     only one instance of each name, function or otherwise.

     We are using =mapcar= to apply our =describe-path= function to
     each list of relevant edges.
**** Join the Descriptions
     Finally, we'll discuss the outmost part of the =describe-paths=
     function: =(apply #'append (result-from-step-2))=.

     We are joining all of the generated lists together, here. The
     =append= function does this, and we use it easily with another
     function, =apply=. The =apply= function passes each item in a
     supplied list to the target function, as opposed to =mapcar=,
     which applies a function to each item in a list in turn.

     Note, however, that for very large lists implementing aggregation
     this way may be inefficient, as =apply= passes each element in a
     separate call.
**** Wrapping Up
     This basic style, passing complicated data through several
     functions in turn, is a very common practice in Common Lisp, and
     Lisp in general. /Composability/ is core to the Lisp mindset.
*** Describing Objects at a Specific Location
    Similarly to above, we are going to use a global list to store the
    objects, and then store the locations of those objects in an
    /alist/.

    #+begin_src lisp :results value
      (defparameter *objects* '(whiskey bucket frog chain))
      (defparameter *object-locations* '((whiskey living-room)
					 (bucket living-room)
					 (chain garden)
					 (frog garden)))
    #+end_src

    To identify the objects in a current location, we are going to
    compose a big function chain again; this one will be called
    =objects-at=.

    Inside =objects-at=, we declare a local function using the
    =labels= function. It seems we've used the =labels= function
    before, but I failed to remember it. =labels= basically allows You
    to define local functions. Declaring functions locally here is
    useful because we will definitely not be using the functions
    outside of that scope, and therefore keep our environment cleaner.

    The =at-loc-p= function is just such a function, and that's why we
    declare it using =labels=. It will take the symbol for an object
    and return =t= or =nil= (using =eq=, as we are comparing symbols)
    regarding the objects presence at a location =loc=.

    The naming of the function =at-loc-p= ends with "-p" due to a
    naming convention in Lisp. Predicates (functions that return true
    or false) are usually named with a "p" suffix to make them easy to
    identify. This is also done in emacs, as I am aware.

    There is another function introduced here: =remove-if-not=. It
    returns a sequence of values without any that do not satisfy a
    specific predicate. Here, we are using our =at-loc-p= predicate on
    all of the objects =objs= supplied to the =objects-at= function.

    It's interesting to me the way that our local function =at-loc-p=
    uses the scope-wide available variable =obj-locs=. I would likely
    not allow this in my own code, as it makes =at-loc-p= less
    /referentially transparent/.

    #+begin_src lisp :results value
      (defun objects-at (loc objs obj-locs)
	(labels ((at-loc-p (obj)
		   (eq (cadr (assoc obj obj-locs)) loc)))
	  (remove-if-not #'at-loc-p objs)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (objects-at 'living-room *objects* *object-locations*)
    #+end_src

    We can then compose =objects-at= into a new function that is not
    dissimilar to the previous function =describe-paths=. This one
    will be called =describe-objects=.

    In this listing, We define a local function using =labels= again
    (kind of like a =let= for functions) called =describe-obj=, which
    forms a sentence describing the object's presence. We use
    /quasiquoting/ again for this. Then we call =objects-at= in the
    exact same way as we called =describe-path= in the other.

    #+begin_src lisp :results value
      (defun describe-objects (loc objs obj-loc)
	(labels ((describe-obj (obj)
		   `(you see a ,obj on the floor.)))
	  (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))
    #+end_src

    Let's test this too.

    #+begin_src lisp :results value
      (describe-objects 'living-room *objects* *object-locations*)
    #+end_src

    Woo!
*** Describing it All
    We're gonna put it all together now, and make a =look= function.

    We're going to track the player's current location using a global
    variable again. This one will be called, creatively, =*location*=.

    We'll initialize it to the living-room, as this will be the
    location of the player at the start of the game.
    
    #+begin_src lisp :results value
      (defparameter *location* 'living-room)
    #+end_src

    Now we can write the =look= function.

    Because of the use of global variables (i.e. variables outside of
    the scope of the function that are changed), this implementation
    is not functional. The choice here was to easily facilitate the
    player simply typing =look=.

    The components of the =look= function (the =describe-= functions,
    for instance) were all written in the functional style. I presume
    this one wasn't because it illustrates the difference between a
    functional approach and a non-functional approach.
    #+begin_src lisp :results value
      (defun look ()
	(append (describe-location *location* *nodes*)
		(describe-paths *location* *edges*)
		(describe-objects *location* *objects* *object-locations*)))
    #+end_src

    Let's test it.

    #+begin_src lisp :results value
      (look)
    #+end_src

*** Walking Around in Our World
    We're going to make another non-functional function to walk around
    using our global variables.

    We first look up the available directions in the =*edges*=
    alist. We then feed this to the =find= function to locate the
    matching path. The =find= function searches a list for a matching
    item, and returns that item. This becomes the variable =next= (and
    =next= is =nil= if not found).

    The new part here is a /keyword parameter/, which lets You access
    special features a function can have in Common Lisp by passing in
    parameters to the end of the call. Here, we are using the /keyword
    parameter/ =:key=, which we use to ensure =find= matches the path
    (direction) with the =cadr= of the available paths, which it so
    happens will be our directions.

    We'll discuss the =:= prefix more in Chapter 7, but it seems right
    now to indicate /keyword parameters/. But the syntax for /keyword
    parameters/ is a name with a =:= prefix (like =:key=) followed by
    a value (like =#'cadr=).

    We then check =next= using =if= and Common Lisp's special handling
    of =false= and =nil=. If =next= has a value, then =if= moves the
    player. If not, that means the direction is impossible, and it
    tells the player as much.
    
    #+begin_src lisp :results value
      (defun walk (direction)
	(let ((next (find direction
			  (cdr (assoc *location* *edges*))
			  :key #'cadr)))
	  (if next
	      (progn (setf *location* (car next))
		     (look))
	      '(you cannot go that way.))))
    #+end_src

    Let's test it out.

    #+begin_src lisp :results value
      (walk 'west)
    #+end_src

    Right now, our program has a pretty big wart: You have to enter in
    the direction with a preceding quote. We're going to address this
    in the next chapter, by making a custom REPL specifically for
    playing text adventures.

    We could also use /macros/ to accomplish this in an unflavored
    Lisp REPL. We'll learn about htis approach in Chapter 16.
*** Picking up Objects
    Next, we're gonna enable picking up items.

    Basically, the concept will be that when You pick something up it
    will modify =*object-locations*= by pushing a new item to it,
    which will associate the object with a ='body= symbol. First,
    we'll check to ensure that the object is there to pick up by using
    =member= on the output of =objects-at=. If it isn't, we'll tell
    the user they can't do that. Our if structure will be =cond=,
    since it is the most versatile.

    #+begin_src lisp
      (defun pickup (object)
	(cond ((member object
		       (objects-at *location* *objects* *object-locations*))
	       (push (list object 'body) *object-locations*)
	       `(you are now carrying the ,object))
	      (t '(you cannot get that.))))
    #+end_src

    I'm honestly not a huge fan of this design, at least for now.. The
    global variables are not only a hotbed for unforeseen errors, but
    they seem as though they will only grow over time. Alists are only
    really efficient when small, and also, there is no utility I can
    see added to the program by maintaining a history like this.

    But, I understand the purpose pedagogically. We're using a new
    function, =push=, which inserts an item at the front of an
    existing list. I'm familiar with pushing and popping, so that
    makes sense to me. The interesting thing is that it dives into the
    implementation; =(push x *list*)= is described as identical to
    =(setf *list* (cons x *list*))=. The =setf= function here is like
    =setq=, but works with more structures than simply symbols.

    The growing alist of historical associations is apparently a
    common Lisp idiom. Because the =assoc= function returns the first
    result it finds, so long as You push new items to the front of the
    list it will appear to be a mutable value when it really is
    not. Interesting, and fairly functional, now that I've thought
    through it.

    We're now going to try out our =pickup= function.

    #+begin_src lisp
      (walk 'east)
      (pickup 'whiskey)
    #+end_src

    It worked!
*** Checking our Inventory
    Checking our inventory is basically going to be a utility function
    to describe "objects at the 'body location".

    #+begin_src lisp
      (defun inventory ()
	(cons 'items- (objects-at 'body *objects* *object-locations*)))
    #+end_src

    Let's try it out.

    #+begin_src lisp
      (inventory)
    #+end_src

    This ends our exploration of a basic text adventure engine, for
    now. We will be adding a mechanism for actually manipulating
    objects (not just changing their locations) in Chapter 17.

    In the next chapter, we are going to improving the UI by
    implementing an actual parser instead of relying on plain lisp
    code.
*** What I've Learned
    We made a simple game engine.

    We can represent a world as a graph, with nodes and edges. You can
    store these items in an alist, which allows You to look up
    properties of symbols using =assoc=. You can use /Quasiquoting/ to
    insert bits of code into data, as opposed to the other way around
    (Quoting to insert small bits of data in code). We learned about
    /Higher Order Functions/ which accept functions as arguments, like
    =mapcar=. You can simulate mutation in an alist using =push= to
    add a redundant key with a new value, since =assoc= will always
    return the first result it finds.
** Chapter 6 - Interacting with the World: Reading and Printing in Lisp
   We begin by calling out that all of the code we've learned so far
   is self contained. We're specifically going to focus on UI, and
   make a command line for our game engine from Chapter 5. To do that,
   we need to print text to the screen, and read it from the user. The
   functions to accomplish this are =print= and =read=.
*** Printing to the Screen
    The =print= function prints things to the output, usually the
    screen.

    #+begin_src lisp :results output verbatim
      (print "foo")
      (progn (print "this")
	     (print "is")
	     (print "a")
	     (print "test"))
    #+end_src
    
    They mention that, if You run the =print= command in a REPL, the
    result is shown twice: Once for the return value of the =print=
    command, and once for its side effect, which is printing the text
    that follows it with a newline *before* it and a space *after* it.

    If You don't want these other characters, You can instead use
    =prin1= (which is "prin" followed by the number 1, not the letter
    l) to print the arguments on one line.

    #+begin_src lisp :results output verbatim
      (prin1 "foo")
      (progn (prin1 "this")
	     (prin1 "is")
	     (prin1 "a")
	     (prin1 "test"))
      
    #+end_src


    The =prin1= command is used a lot in more serious Lisp code,
    because it is simpler and does less, giving You more control. The
    =print= function is used more in this book due to its more
    intuitive use.
*** Saying Hello to the User
    This is a classic. We're going to greet the user.

    Our =say-hello= function will ask for the user's name and then
    respond by greating them.

    The =print= is executed first, and gives the user a prompt. Then,
    we set up a local variable (=name=) and =read= into it. It waits
    for a Return, and then sets the variable equal to what was
    input. Finally, we use the variable to print a greeting.
    
    #+begin_src lisp :results output
      (defun say-hello ()
	(print "Please type Your name:")
	(let ((name (read)))
	  (print "Nice to meet You, ")
	  (print name)))
    #+end_src

    Now, because we are asking for user input, =org-babel= doesn't
    actually complete the command for You (since it is waiting to read
    Your input.

    I was able to get this one working by interrupting the execution
    (C-g) and switching to the =*slime-repl sbcl*= buffer to type my
    name.

    This may be a road block w/r/t using =org-babel= for literate
    programming. I'll have to dive this futher in the future.

    The above did make me pause for a week or so. However, eventually
    I reasoned out that input (that is, for the purposes of the above)
    is going to be a rare instance in this book outside of actually
    running the finished program. And /that/ I can do from the REPL.

    So, we are good to continue.

    However, we need to address something: Everything is currently
    surrounded by ="=. This is fine for now, but eventually I would
    like that not to be the case.
*** Starting with print and read
    I'm advised that, when I have an IO task in Lisp, I should start
    by asking myself if =print= or =read= can do the job. It will save
    a lot of trouble if I can use these two instead of any others.

    I'm also warned that =read= can be *dangerous* if used wrong. I'm
    assuming we'll come to those details soon, though there are some
    hyperlinks here I could follow.

    The following example is given to show how =read= and =print= can
    work almost identically when working with numbers as with strings.

    #+begin_src lisp :results output
      (defun add-five ()
	(print "Enter a Number: ")
	(let ((number (read)))
	  (print "When I add 5 I get:")
	  (print (+ number 5))))
    #+end_src

    Here are some examples of printing various types of values.

    Note that the types of output are:
    - An Integer
    - A Float
    - A Symbol (all caps due to case-blindness)
    - A String
    - A character

    Also note the quoting. We could omit the quoting in each case
    aside from the symbol (since it could refer to a function or
    value).
    
    #+begin_src lisp :results output
      (print '3)
      (print '3.4)
      (print 'foo)
      (print '"foo")
      (print '#\a)
    #+end_src

    But there are of course a few special cases here. First, with
    symbols, You can create case sensitive symbols using the =|=
    character, =|LikeThis|=. Piped symbols can even have punctuation
    in them: =|So, this is a VERY valid symbol, too!|= is a good
    example.

    And finally, we can print single characters using the =#\=
    prefix. There are three common non-visible characters mentioned in
    the book: =#\newline=, =#\tab= and =#\space=. They are pretty
    self-explanatory.

    As for =read=, it behaves exactly the same way, except instead of
    printing them, it reads them.
*** Reading and Printing Stuff the Way Humans Like It
    The =say-hello= function defined above is pretty bad at what it
    actually is supposed to do.

    We're shown the following table:

    | For       | Printing | Reading |
    |-----------+----------+---------|
    | Computers | =print=  | =read=  |
    | Humans    | =princ=  | =???=   |

    Remember our problem from earlier: All strings were double-quoted,
    and it looked very stilted when used. The =princ= function behaves
    as humans might expect, as opposed to the more "correct" way a
    computer might prefer it to. Strings are unquoted. Characters are
    unprefixed.

    #+begin_src lisp :results output
      (print '3)
      (princ '3)
      (print '3.4)
      (princ '3.4)
      (print 'foo)
      (princ 'foo)
      (print '"foo")
      (princ '"foo")
      (print '#\a)
      (princ '#\a)
      (progn (princ #\newline)
	     (princ "This Sentence will be interrupted")
	     (princ #\newline)
	     (princ "by an annoying newline character."))
    #+end_src

    The thing to note here is that while =print= prints anything in a
    way unique to its internal representation (and therefore, it can
    be =read= back /into/ that internal representation easily),
    =princ= is a one-way street: It cannot easily be stored again, and
    breaks the symmetry this Part is focusing on.

    The obvious course of action is to come up with arbitrary rules
    for how the computer should interpret input. One (fairly naive,
    but still useful) approach would be: "Let the user type whatever
    they want until they hit enter, then treat everything they typed
    as a string." The function that does this is called =read-line=,
    and we can use it to complete our refinement of the =say-hello=
    function.

    The below =say-hello= implementation allows the user to enter
    /any/ name, including whitespace and punctuation, up to a
    newline. It also doesn't print needless quotes around everything,
    nor does it isolate the name on a line by itself.

    #+begin_src lisp
      (defun say-hello()
	(princ "Please type Your name: ")
	(let ((name (read-line)))
	  (princ "Nice to meet You, ")
	  (princ name)
	  (princ '#\newline)))
    #+end_src
*** The Symmetry Between Code and Data in Lisp
    Lisp can also treat program code and data interchangeablly. A
    language that uses the same data structures to store both data and
    program code is said to be /Homoiconic/.

    We discussed these two modes briefly in Chapter 3. Here's that
    example again.

    #+begin_src lisp :results output
      (princ '(+ 1 2))  ; data mode
      (princ #\newline) ; \n
      (princ (+ 1 2))   ; code mode
    #+end_src

    In Chapter 5, we used a /quasiquote/ when defining the
    =describe-path= function. This was another example.

    But these features are fairly limited in their abilities. If we
    want to execute arbitrarily generated/collected code (as in a
    parser), we need another function. This function is =eval=.

    #+begin_src lisp
      (defparameter *foo* '(+ 1 2))
      (eval *foo*)
    #+end_src

    The =eval= command is powerful and simple, but easy to cause
    problems with, like a vorpal sword or midas ring. Improper use can
    easily pose a security risk. Experienced Lispers will only rarely
    use =eval=; many of the things inexperienced Lispers might use
    =eval= for can be done with Macros instead, which we'll discuss
    further in Chapter 16.

    The bottom line is that *Quoting, Quasiquoting, =eval=, and Macros
    allow You to take advantage of Lisp's Homoiconicity in Your code.*
*** Adding a Custom Interface to Our Game Engine
    Thus far, we've been using the Lisp REPL to enter our game
    commands. It's amazing how well this works for prototyping our
    game.

    Now we are going to make our own interface.
**** Setting up a custom REPL
     Defining a REPL in Lisp is very easy. This will work exactly as
     the standard REPL:

     #+begin_src lisp
       (defun game-repl ()
	 (loop (print (eval (read)))))
     #+end_src

     That's not the most useful REPL, though. Let's try harder.

     In this version, we capture the player input using =game-read=
     into a variable called =cmd=. This lets us handle quit. So long
     as the user did not type "quit", it evals and prints using
     =game-eval= and =game-print= the command in =cmd=. Finally, it
     recurses.
     
     #+begin_src lisp
       (defun game-repl ()
	 (let ((cmd (game-read)))
	   (unless (eq (car cmd) 'quit)
	     (game-print (game-eval cmd))
	     (game-repl))))
     #+end_src
**** game-read
     We'll need to define our "game-" prefixed functions. Let's start
     with =game-read=.

     Our =game-read= function starts by using =read-from-string=,
     which is similar to =read= but works from a string instead of
     input, to assign the typed commands to the variable =cmd= as a
     list (so "walk east" becomes "(walk east)" and is assigned to
     =cmd=). Then, we define a simple local function with =flet= (not
     =labels=, since we aren't recursing or anything) that will quote
     all parameters in our new list. It does this by =cons= -ing the
     =car= of =cmd= with a =mapcar= of the =cdr= of =cmd= using
     =quote-it=, our local function.
     
     #+begin_src lisp
       (defun game-read ()
	 (let ((cmd (read-from-string
		     (concatenate 'string "(" (read-line) ")"))))
	   (flet ((quote-it (x)
		    (list 'quote x)))
	     (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
     #+end_src

     That is a lot of functions, but I understood them all!

     And upon testing, it indeed works.

     It should probably have exception handling, because it is
     accepting input from the user (Mismatched parens is the situation
     referenced in the book). We'll go over that in Chapter 13.
**** game-eval
     Now, we need to define how we're going to actually /run/ the
     input.

     Our main goal here is limiting the functions that the user can
     call with their input. We'll do this by use of a global variable
     =*allowed-commands*=.

     Before reading the explanation, I want to take a crack at
     explaining how this works.

     Basically, it takes an S-Expression in the form of a list. It
     checks the =car= of that list to see if it is an Allowed Command
     (that is, if it is a member of the =*allowed-commands*=
     global). If it is, it runs =eval= on it. Otherwise, it tells the
     user it does not know the command supplied.
     
     #+begin_src lisp
       (defparameter *allowed-commands* '(look walk pickup inventory))
       (defun game-eval (sexp)
	 (if (member (car sexp) *allowed-commands*)
	     (eval sexp)
	     '(i do not know that command.)))
     #+end_src

     I got the explanation correct!
     
     This is fairly basic protection. There is more to learn in the
     section called "The Dangers of read and eval".
**** game-print
     Finally, we need a way to print things in a normal,
     human-readable way. The most obvious thing we can do to work
     towards this goal is to print the correct case of each letter
     (uppercase the start of sentances, lowercase everything else).

     The =game-print= function should take a list of symbols, and
     print a properly-formatted string. The same technique used here
     can be used to generate any kind of text, such as HTML Code
     (we'll be doing something similar in Chapter 17).

     These functions are kind of intimidating. Here we go.

     I am not confident enough to parse this on my own, I don't
     think. But I'll try.

     So, first, =tweak-text=. Takes three arguments, =lst=, =caps=,
     and =lit=. So long as =list= is not =nil=, it assigns the =car=
     of =lst= to =item=, and stores the rest of =lst= in =rest=.

     We then enter a =cond= which always ends with us recursing, using
     =rest= as the new =lst= (in other words, popping off =item=).

     The =cond= has a number of branches; I'm not sure what most of
     them do.

     The first takes a " " input and =cons= es it with the
     rest of the text.

     The second checks to see if the text is punctuation, and if so,
     =cons= es it with the rest, but passing =t= to the variable
     =caps= (which would otherwise be =nil=).

     If the text is a double-quote, it does /not/ =cons= it to the
     list and recurses, flipping =lit=, whatever that variable means
     (literal?).

     The next branch checks =lit=. If it is not =nil=, it conses
     whatever the current item is to the list and then recurses,
     turning =caps= nil.

     It then checks both =caps= and =lit=. If either are true, it
     conses the item after upcasing it, recursing with =caps= as nil.

     Finally, the default case =t= will always run if nothing else
     does. It will conse the /downcased/ item with the list, and
     recurse passing =nil= to both =caps= and =lit=.

     Logically, I don't see a case where =lit= can be true for the
     =or= condition, so I don't know why that's included.

     As this is a recursive function, it will continue to recurse
     until there is only an empty list left (which is the same as
     =nil=).

     Now, =game-print=. Takes a list.

     I don't know what =coerce= does. Sounds ominous. Looking it up in
     the Hyperspec, it seems to create a new symbol of a specific type
     from some other symbol.

     Using that definition:

     We start by printing the list out as a string. We then cut off
     the leading and following "(", ")", and " " that might be
     present, giving us just the string itself.

     We then turn /that/ string into a list. Which is odd, since it
     may have started as a list? Maybe this is for safety.

     We feed this list to =tweak-text= as =lst=, with =t= for =caps=
     and =nil= for =lit=. So, =caps= starts as =t=.

     After that, we =coerce= the resulting list into a string, and
     =princ= that for the user.

     Finally, we call =fresh-line=, which is one of the functions that
     will output a '\n'.

     #+begin_src lisp
       (defun tweak-text (lst caps lit)
	 (when lst
	   (let ((item (car lst))
		 (rest (cdr lst)))
	     (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
		   ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
		   ((eq item #\") (tweak-text rest caps (not lit)))
		   (lit (cons item (tweak-text rest nil lit)))
		   ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
		   (t (cons (char-downcase item) (tweak-text rest nil nil)))))))
       
       (defun game-print (lst)
	 (princ (coerce (tweak-text (coerce (string-trim "() "
							 (prin1-to-string lst))
					    'list)
				    t
				    nil)
			'string))
	 (fresh-line))
     #+end_src

     Okay, there were a few things I got somewhat wrong, but that's
     because I'm new.

     First, the =lit= flag is so we can /escape/ parts of a string
     with quotes! This lets us use things that Lisp might not like,
     like non-standard caps or commas.

     Next, the list -> string -> list is so we can using =string-trim=
     on the sentence before processing it.

     Finally, we are working /character-by-character/ here. I did not
     realize the delimiter was only a single character; I wonder how
     we got that way. Maybe this is another benefit of =coerce=?
*** Try Out Our Fancy New Game Interface
    Let's try it out. Make sure to run the subtrees for both Chapter 5
    and Chapter 6, then switch to the connected SLIME buffer.

    It's difficult to say how happy it made me to walk around in that
    little world I built.

    And even better, I understood so much of the tools I used to do
    so.

    We'll expand this game out again in Chapter 17. But for now, it
    may be time to move on to something else for a while.
*** The Dangers of read and eval
    Avoid these two commands. You can never be sure that a Lisp
    program using =eval= or =read= is completely safe from a malicious
    hacker. One method of attack we did not even touch on here is
    /reader macros/, which will work and let the user execute
    arbitrary code in our Lisp REPL.

    Just avoid them if You can.
*** What I've Learned
    Created a Custom Text Adventure REPL to use with our engine.

    =print= and =read= let You directly communicate with the user.

    Other IO functions are not as elegant, but are friendlier for
    humans.

    /Homoiconic/ programming languages store program code and data in
    a similar format. In Lisp, the main features that provide
    /Homoiconicity/ are /Quoting/, /Quasiquoting/, =eval=, and
    /Macros/.

    It's easy to write Your own REPL.

    It's simple to transform Your internal Lisp data into new
    forms. This makes it easy to encapsulate presentation from the
    details of the data.
** Chapter 6.5 - Lambda: A Function So Important It Deserves Its Own Chapter
   The =lambda= function is the most important function in Lisp.

   It lets You create functions without giving them a name. This is
   possible since functions are /first class values/ in Lisp, and can
   be passed around the same way values can.
** Chapter 7 - Going Beyond Basic Lists
   In this chapter, we're going to expand our knowledge of Lists and
   List Manipulation passed the basics.
*** Exotic Lists
    Lists are built using /cons cells/, which are small data
    structures that allow You to link together two pieces of data. The
    right slot of the last item in the chain should contain =nil=.

    Here is how to use cons cells to make a list of the numbers 1, 2,
    and 3.

    Note how the =cons= cells are absent from the printed list. This
    is a convenience feature for humans, they are still there.
    
    #+begin_src lisp
      (cons 1 (cons 2 (cons 3 nil)))
    #+end_src
    
**** Dotted Lists
    Suppose when we build a list we don't use a consistent string of
    =cons= cells. What happens then?

    This is a /dotted list/, which is a list that does not end with
    the expected =nil=, but instead ends with some other value.
    
    #+begin_src lisp
      (cons 1 (cons 2 3))
    #+end_src

    /Dotted Lists/ aren't useful in and of themselves, and shouldn't
    be used to store data in a normal program. However, they may
    appear emergently in code, as a side effect of using =cons= cells
    directly.

    The dot notation used in /dotted lists/ is actually an alternative
    syntax for =cons=, but only in /data mode/. We could make lists
    like this if we wanted:

    #+begin_src lisp
      `(1 . (2 . (3 . nil)))
    #+end_src
    
**** Pairs
     A common use for /dotted lists/ in Lisp is /pairs/. This is
     convenient (because You can now use =car= and =cdr= to interact
     with the pair members) and efficient (only one =cons= cell is
     needed to store the pair). I have heard the term /dotted pair/
     before, but it isn't used in this book, at least yet. It /is/
     mentioned, however, that You can use these for storing x/y
     coordinates or a key/value pair. Here's a pair of numbers:

     #+begin_src lisp
       (cons 2 3)
     #+end_src

     We'll revisit pairs when we discuss /Association Lists/ again.
**** Circular Lists
     What if, instead of =nil=, the last cell in a list pointed to the
     first cell?

     This creates a /Circular List/. It's important to set
     =*print-circle*= to =t= before using a circular list, or You may
     get stuck in an infinite loop during printing.

     We can easily make a circular list using =setf=. The ability to
     do things like this will be explored more in Chapter 9. For now,
     here is a circular list of 1, 2, 3, 1, 2, 3 repeating forever.
     
     #+begin_src lisp
       (setf *print-circle* t)
       (defparameter foo '(1 2 3))
       (setf (cdddr foo) foo)
     #+end_src

     This notation denotes /self-referential/ values, and is a clever
     but esoteric way to print an infinite loop to screen. However,
     the more complex the notation, the harder it is to grok, so try
     to keep these to a minimum.
**** Association Lists
     There is a particularly useful data structure called an
     /association list/, where key-value pairs are stored in a single
     list. These can be built out of =cons= cells in a simple way:
     Note the use of /dotted pairs/.

     #+begin_src lisp
       (defparameter *drink-order* '((bill . double-espresso)
				     (lisa . small-drip-coffee)
				     (john . medium-latte)))
     #+end_src

     This is so common in Lisp that the function =assoc= is named for
     it. Use it to look up information: Alone, it gives the pair. With
     =car=, the key. With =cdr=, the value. It searches the whole
     list, from the beginning, for the first match.

     #+begin_src lisp
       (cdr (assoc 'lisa *drink-order*))
     #+end_src

     The fact that it goes for the first match means that, to update a
     value, it is common to simply push a new value with an identical
     key onto the list. This is beneficial because it gives the full
     histogram of the variable's state over time, and is therefore
     more immutable than simply updating the value would be. The
     drawback is that, as list sizes grow, /alists/ are impractical
     and slow: The more pairs You have, the more items of the list
     need to be processed on each lookup, and the longer it will take
     to do so. The book recommends keeping /alists/ under 12 keys, and
     using them for prototyping (and replacing them once a program
     matures).

     #+begin_src lisp
       (push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
     #+end_src

     #+begin_src lisp
       (cdr (assoc 'lisa *drink-order*))
     #+end_src

     We'll discuss in Chapter 9 the perfomance limitations of
     list-based data structures.
*** Coping with Complicated Data
    =Cons= cells are great for list-like data structures, and are many
    Lispers go-to when performance isn't the main constraint. If
    compiling Your program, structures made of =cons= cells may still
    be a good choice: *Lisp compilers can often reduce a change to a
    cons cell to a single assembly instruction.*
**** Visualizing Tree-Like Data
     *As discussed in Chapter 3, the data and code of a Lisp program
     is represented with syntax expressions.* These are nested lists
     with hierarchical symbols in their =car=.

     Here is how we might use them to represent a house.

     #+begin_src lisp
       (defparameter *house* '((walls
				(mortar
				 (cement)
				 (water)
				 (sand))
				(bricks))
			       (windows
				(glass)
				(frame)
				(curtains))
			       (roof
				(shingles)
				(chimney))))
     #+end_src

     The fact that it is made up of nested lists makes it easy to
     visualize the hierarchy, here: Walls are made of bricks and
     mortar, which is made up of cement, water, and sand.

     Tree-Like data can naturally be expressed this way. XML is a
     reinvention of this concept, from a Lisp perspective.

     However, non-Tree-Like data is harder to visualize. The example
     specifically given is a Mathematical Graph.
**** Visualizing Graphs
     In mathematics, a graph is nodes connected by edges. Each item
     may have more data involved, too.

     We used something similar to this in Chapter 5: The wizard's
     house was a /directed graph/. We chose to store it in two
     /alists/: one for the nodes, and one for the edges. I believe I
     commented on how this was unmaintainable and sloppy code, which
     is nice to hear that the book agrees. Here they are again,
     renamed to new, unique variables. We're going to use a tool to
     make visualizing this data easier next.

     #+begin_src lisp
       (defparameter *wizard-nodes* '((living-room (you are in the
				      living-room. a wizard is snoring loudly
				      on the couch.))
				      (garden (you are in a beautiful
				      garden. there is a well in front of
				      you.))
				      (attic (you are in the attic. there is
				      a giant welding torch in the
				      corner.))))
       (defparameter *wizard-edges* '((living-room (garden west door)
				       (attic upstairs ladder))
				       (garden (living-room east door))
				      (attic (living-room downstairs
				      ladder))))
     #+end_src

*** Creating a Graph
    We are going to be using =graphviz= [[https://graphviz.org/][Link]] to make graphs from our
    data. I'm warned that =clisp= is the implementation used in this
    book, and therefore I may need to alter the commands used for
    =sbcl=.
**** Testing Graphviz
    The =graphviz= program is one I toyed around with in the past, but
    I'm glad that we are using it here. I always wanted to use it to
    help in planning my software, and I am happy to find that we're
    doing that in Lisp. Yet another things that points me towards this
    wonderful language.

    Below is a /digraph/, or a /directed graph/, that points from a to
    b to c. We're using the =neato= command from graphviz to turn the
    below markup into a visual graph. The =neato= command is described
    as, "the default tool to use if the graph is not too large (about
    100 nodes) and you don’t know anything else about it" on the
    =graphviz= website.

    #+begin_src dot :file ./imgs/example-of-dot.png
      digraph {
	      a->b->c;
      }
    #+end_src

  
    I also note that, due to =org-babel=, my workflow is greatly
    simplified: It will compile the code into a named image in the
    repo and then embed it in the file itself, so long as I have
    =(org-toggle-inline-images)= set to true.
**** Creating Graphs with Lisp
     Now we are going to create graphs with and from Lisp.

     We will need to:

     1. Convert the identifiers of all /nodes/ to dot format.
     2. Convert the /edges/ connecting these /nodes/.
     3. Generate the labels for every /node/ and /edge/.
***** Converting Node Identifiers
      First we need to convert the node identifers into dot
      identifiers. We'll write a function called =dot-name= for this.

      Looking at this before reading the explanation: We are taking an
      expression, substituting all non-alphanumerics characters with
      =#\_=, which I believe is a literal underscore, and then =prin1=
      ing that as a return. On second glance, I think I have the order
      reversed there: We are calling =prin1-to-string= first, to
      convert the symbol into a string, and then subbing out
      non-alphanumeric characters before returning.

      This was correct!

      For the reasoning behind it: DOT format identifiers can only
      contain letters, numbers, and underscores. This is a naive way
      to ensure that the names are created safely. It's brought up
      that this will assume that no nodes will differ only by
      non-alphanumberic characters (e.g. =foo!= and =foo?= would both
      be =foo_= here, causing a collision).

      We are using a few new functions here, =substitute-if=,
      =complement=, and =alphanumericp=.

      The =substitute-if= function substitues values based on the
      result of a test (or /predicate/) function (it also works on
      lists!). The =alphanumericp= function is one such /predicate/
      function (note the -p suffix) that tests for whether a value is
      alphanumeric. However, we want to replace all values that are
      /not/ alphanumeric, which is where the =complement= function
      comes in: it takes a function and returns its opposite (probably
      limited to /predicate/ functions, then).

      NOTE: There is also a =substitute-if-not= function, but all
      =-not= functions are considered deprecated, and should not be
      used.

      #+begin_src lisp :noweb-ref graph-util
	(defun dot-name (exp)
	  (substitute-if
	   #\_
	   (complement #'alphanumericp)
	   (prin1-to-string exp)))
      #+end_src

      Here are some examples of how the =dot-name= function works.
      
      #+begin_src lisp :results output verbatim
	(print (dot-name 'living-room))
	(print (dot-name 'foo!))
	(print (dot-name 24))
      #+end_src
***** Adding Labels to Graph Nodes
      We'll now focus on convering the labels for the nodes.

      The label will consist of two parts:

      1. The name of the /node/.
      2. The data linked to the /node/ from the =*node*= /alist/.


      The main issue here is avoiding label overflow (too much text in
      the label).

      We're going to use a global variable =*max-label-length*= to
      ensure that the text doesn't get too long. If the text /is/ too
      long, we'll display 27 characters of it with a "..."
      suffix. And, if there is no input, we'll return "".

      We're also using a new function, =write-to-string=. It is very
      similar to =prin1-to-string=. The main difference seems to be
      the /keyword parameters/ that =write-to-string= supports.

      /Keyword parameters/ are flags supported by certain Lisp
      functions to let You choose specific parameters to pass in
      (instead of setting them all every time). =:pretty nil= means to
      /not/ clean up the string before writing it. Without that
      /keyword parameter/, =write-to-string= would do things like
      placing new-lines in the string, or indentation.

      #+begin_src lisp :noweb-ref graph-util
	(defparameter *max-label-length* 30)
	
	(defun dot-label (exp)
	  (if exp
	      (let ((s (write-to-string exp :pretty nil)))
		(if (> (length s) *max-label-length*)
		    (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
		    s))
	      ""))
      #+end_src
***** Generating DOT Information for the Nodes
      Now that we have both identifiers and labels for nodes handled,
      let's compose them into a single function that works with our
      data as it already is.

      Our function will take our /alist/ of nodes, and output the DOT
      information to encode them.

      It uses =mapc= to go through every node in =nodes= and =princ=
      prints the dot format to the screen. The main difference between
      =mapcar= and =mapc= is that =mapc= does /not/ return the
      transformed list.

      We're using the console as an intermediary here, which is a
      common paradigm in Lisp. It lets You easily debug issues in the
      code, as You can see the output on the screen in the REPL (or in
      org-babel).

      #+begin_src lisp :noweb-ref graph-util
	(defun nodes->dot (nodes)
	  (mapc (lambda (node)
		  (fresh-line)
		  (princ (dot-name (car node)))
		  (princ "[label=\"")
		  (princ (dot-label node))
		  (princ "\"];"))
		nodes))
      #+end_src


      We can use this function on our =*wizard-nodes*= /alist/, as a
      test.

      Note how we are not interested in the return value of the
      function, here, but only its output. *Lispers would say we are
      only interested in the /side effects/ of this function.*
      

      #+begin_src lisp :results output verbatim
	(nodes->dot *wizard-nodes*)
      #+end_src

      It works!
***** Converting Edges into DOT Format
      This will be strikingly similar to the former function
      =node->dot=, but for the =edges= data.

      #+begin_src lisp :noweb-ref graph-util
	(defun edges->dot (edges)
	  (mapc (lambda (node)
		  (mapc (lambda (edge)
			  (fresh-line)
			  (princ (dot-name (car node)))
			  (princ "->")
			  (princ (dot-name (car edge)))
			  (princ "[label=\"")
			  (princ (dot-label (cdr edge)))
			  (princ "\"];"))
			(cdr node)))
		edges))
      #+end_src

      And here's an example:

      #+begin_src lisp :results output verbatim
	(edges->dot *wizard-edges*)
      #+end_src

      It's already easier to visualize the data, but let's continue.
***** Tying it all together
      The last step is composing the above functions into a single
      function that will output the DOT info for the entire structure.

      #+begin_src lisp :noweb-ref graph-util
	(defun graph->dot (nodes edges)
	  (princ "digraph{")
	  (nodes->dot nodes)
	  (edges->dot edges)
	  (princ "}"))
      #+end_src

      Note how only the most top-level markup is saved for the above
      function. All else is within one of the other functions, which
      are purely functional (aside from outputting their data to the
      screen, I suppose).

      Let's use it on our /alists/!

      #+name: wizard-dot-info
      #+begin_src lisp :results output verbatim
	(graph->dot *wizard-nodes* *wizard-edges*)
      #+end_src

      Woo! This is *amazing*, as my focus is text manipulation. That
      was understandable and easy.
**** Turning the DOT Info Into a Picture
***** Org Babel Aside
      This is an aside, not part of the book.

      My main workflow in Common Lisp will be Emacs and SLIME, using
      Org-Babel as the main way I execute code. I want to test how
      this will work for me before using the example in the book to
      learn about system calls and stuff.

      We can use the =:var= header for this.

      #+begin_src dot :var input=wizard-dot-info :file ./imgs/wizard-info.png 
	$input
      #+end_src
***** Using Lisp
      Now we will do it the way the book wants, by saving the output
      to a file and then running the command on that file.

      This is where the differences between [[https://clisp.sourceforge.io/][CLISP]] and [[http://www.sbcl.org/][SBCL]] began. I
      worked around them by looking online; a [[https://www.reddit.com/r/learnlisp/comments/9dxa80/package_ext_doesnt_exist_w_extshell/][Reddit thread]] pointed me
      to a [[https://kofno.github.io/2012/11/20/land-of-lisp-sbcl.html][website]] which pointed to a [[https://github.com/kofno/land-of-lisp][repo]] that had a [[https://github.com/kofno/land-of-lisp/blob/master/chapter-7/graph-util.lisp][file]] with the
      answer.

      The main difference here was the call to =ext:shell=, which had
      to be replaced as it was CLISP-specific. SBCL has a few options
      for this, but as IO is not needed apart from running the
      command, the repo used =sb-ext:run-program=. I think that that
      is a good choice.

      #+begin_src lisp :noweb-ref graph-util
	(defun dot->png (fname thunk)
	  (with-open-file (*standard-output*
			   fname
			   :direction :output
			   :if-exists :supersede)
	    (funcall thunk))
	  (sb-ext:run-program "dot" `("-Tpng" "-O" ,fname) :search T))
	
      #+end_src

      This is also our introduction to something called /thunks/.
***** Using Thunks
      A /thunk/ or /suspension/ is a /nullary function/ (small
      function with zero arguments) that holds a computations we don't
      want to run until later.

      In =dot->png=, we use the function which will generate our DOT
      info as a /thunk/ that will be run when we are ready.

      This is a common technique in non-functional Lisp: Print stuff
      to the console, wrap it in a /thunk/, and then redirect the
      output from the console to where it needs to be. However, as
      we'll discuss in Chapter 14, this is eschewed by Functional
      Lispers due to it relying on side effects.
***** Writing to a file
      We're using the =with-open-file= function to write data to a
      file.

      The first item passed to =with-open-file= will become the name
      of a /stream/, which is a special datatype in Common Lisp. The
      second is a string, which will be the filename. The others are
      all keyword parameters: We are specifying that it is an output
      stream, and that we don't care if there is already a file,
      overwrite it with only the data specified.

      #+begin_src lisp
	(with-open-file (my-stream
			 "text/testfile.txt"
			 :direction :output
			 :if-exists :supersede)
	  (princ "Hello File!" my-stream))
      #+end_src

      And we can see that it worked.
      
      #+begin_src bash :results output verbatim
	cat text/testfile.txt
      #+end_src
***** Creating a Stream
      All printing functions can accept a stream as an optional
      parameter. If supplied, the functions print to the stream
      instead of the console.

     The scope of the streams created by =with-open-file= is the block
     within =with-open-file=, much like the variables defined with
     =let=.

     We'll be looking at streams more closely in Chapter 12.
***** Understanding Keyword Parameters
      The name of a /keyword parameter/ is always a symbol beginning
      with a colon. This is because they are /keyword symbols/, which
      are symbols which always refer to themselves. In other words,
      they are immutable and self-referential.

      They make a funny reference to a cigar being just a cigar, which
      I appreciated.
***** Capturing the Console Output
      In =dot->png= we send data to the file using
      =*standard-output*=, which is a dynamic variable referring to
      stdout.

      Basically, if anything prints to stdout in the thunk, that
      output is redirected to the file we've opened. It does this by
      overriding the global variable =*standard-output*=, which
      directs output to stdout, to the stream we define /under the
      same name/.

      This is not unlike using =let= to redefine a global variable in
      a smaller scope. We're just doing it with output targets. And
      because we are redefining the target for standard output, /all/
      output is routed to the file by default, with no other changes.
**** Creating a Picture of Our Graph
     We need to finally compose everything into one neat function.

     Our function will take a filename, an /alist/ of nodes, and an
     /alist/ of edges, write the DOT info to a file of that filename,
     and then run =neato= on that file to create the image.

     #+begin_src lisp :noweb-ref graph-util
       (defun graph->png (fname nodes edges)
	 (dot->png fname
		   (lambda ()
		     (graph->dot nodes edges))))
     #+end_src

     
     Calling the =graph-dot= function as a lambda in the thunk is an
     example of /delayed computation/. Such a thing allows us to call
     a function after a stream has been opened, for instance. It
     allows us to ensure everything is set up before we move forward.

     Let's create our file!

     #+begin_src lisp
       (graph->png "imgs/wizard.dot" *wizard-nodes* *wizard-edges*)
     #+end_src

     To see it, I've referenced where the image (wizard.dot.png)
     should have been created here.

     [[./imgs/wizard.dot.png]]
     

     It worked!

     It's mentioned that this can be very valuable for debugging, but
     it also will be good for data modeling as well as other aspects
     of my programming life.
*** Creating Undirected Graphs
    A graph with arrows on its edges is called a /directed graph/.

    It is useful for visualizing flow and responsibility.

    However, sometimes we need to travel between edges in a
    disorganized way, for instance when back and forth motion is
    common. This is when /undirected graphs/ are better, as they are
    less busy and easier to understand.

    We're going to add undirected versions of each of the above
    functions.

    While these are very similar to the directed functions, there are
    a few key differences:

    1. We only need to establish an edge between two nodes once. So,
       we are using =maplist= (a function like =mapcar=, except it
       acts on the entirety of the list instead of just the =car= of
       the list before popping off the first element and repeating) to
       check if the edge's destination appears later in the list. If
       so, it skips the first connection, and just writes the last
       one. It checks this using =(assoc (car edge) (cdr lst))=.

    2. In =ugraph->dot=, we use "graph" instead of "digraph", as this
       is not a directional graph. Otherwise it is identical to
       =graph->dot=.

    3. Because we designed =dot->png= to accept different functions as
       the /thunk/, we don't need to rewrite it for this change. So,
       we'll just make a new wrapper function that automatically plugs
       our new function in as the /thunk/.

    #+begin_src lisp :noweb-ref graph-util
      (defun uedges->dot (edges)
	(maplist (lambda (lst)
		   (mapc (lambda (edge)
			   (unless (assoc (car edge) (cdr lst))
			     (fresh-line)
			     (princ (dot-name (caar lst)))
			     (princ "--")
			     (princ (dot-name (car edge)))
			     (princ "[label=\"")
			     (princ (dot-label (cdr edge)))
			     (princ "\"];")))
			 (cdar lst)))
		 edges))
      (defun ugraph->dot (nodes edges)
	(princ "graph{")
	(nodes->dot nodes)
	(uedges->dot edges)
	(princ "}"))
      (defun ugraph->png (fname nodes edges)
	(dot->png fname
		  (lambda ()
		    (ugraph->dot nodes edges))))
    #+end_src

    Finally, let's use it to generate our undirected graph!

    #+begin_src lisp
      (ugraph->png "./imgs/uwizard.dot" *wizard-nodes* *wizard-edges*)
    #+end_src

    [[./imgs/uwizard.dot.png]]
*** What I've Learned

    We've discussed odd lists and created a drawing library for
    mathematical graphs.

    - Lists can end in other things than =nil= (dotted lists).
    - Pairs are what You get when You cons two non-lists (dotted
      pair).
    - Circular Lists are possible, where the last cell points to the
      first.
    - Association Lists are lists of pairs, and are good for small
      amounts of data and for prototyping (alists).
    - Lisp syntax expression are great at list or tree like data, but
      are opaque for more complex data.
    - If Your data is in the form of a mathematical graph, visualize
      it with =graphviz=.
    - Common Technique: Print output to console, wrap in thunk,
      redirect =*standard-output*=.

** Chapter 8 - This Ain't Your Daddy's Wumpus
   
*** Concept of Grand Theft Wumpus
   We're reminded that we've just built a simple game with
   mathematical graphs.

   Then, we're reminded of "Hunt the Wumpus", which is a game I've
   played before. It was in the =bsd-games= package on Slackware back
   when I used it as my main OS.

   That said, we are not making "Hunt the Wumpus". Instead we're going
   to make something the author calls "Grand Theft Wumpus".

   The premise is quite different: You are the Lisp Alien, and You've
   just robbed a liquor store with the Wumpus. The Wumpus, of course,
   double crosses You and makes off with the money in Your car. You
   shot him in the kidney as he got away, though, which will
   presumably leave a trail for us to follow.

   Nope, instead we are hoping it makes him lay low in the current
   city (Congestion City) long enough for us to find him. Of course,
   much like the original game, the roads in Congestion City are very
   convoluted, and it will be difficult to get around. However, we
   have a pocket computer and our graphing utilities with which to
   conquer this maze.

   The Wumpus will always scout out a new hiding place before he uses
   it. And, since he is injured, any location 1 or 2 blocks away with
   have blood stains. We have a single bullet with which to kill him,
   so we need to be very sure he is in the spot we will target before
   shooting.

   Of course, if it were just You two in the city, it would be too
   easy. So, there are also three other teams (The Gruesome Glowworm
   Gang) hunting around, that will kidnap You and drop You off
   somewhere else in the town if they catch You. However, they are
   Glowbugs: So, if You see blinking lights, You know that they are
   one street away.

   And of course of course, the cops have set up some roadblocks
   (edges where they will catch You if You travel that way), but You
   don't know how many or where they are.

   

*** Defining the Edges of Congestion City

**** The =load= Function
    First thing's first: We have to actually make the file
    =graph-util.lisp= that it expects us to have made in a previous
    chapter.

    Not too difficult; Let's just pull each block into a new source
    block (which will make unexecutable but exportable) using /noweb
    style/ references. We'll go back and assign some names to the
    needed code blocks.

    Actually, per the [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][manual]], we can just assign all the relevant
    codeblocks the same =:noweb-ref= header argument, and it will pull
    them all (in order) into the same reference.
    
    #+begin_src lisp :eval never :noweb yes :tangle ./lib/graph-util.lisp
      <<graph-util>>
    #+end_src

    It worked!

    Now, let's see if it lets us load it.

    #+begin_src lisp
      (load "./lib/graph-util.lisp")
    #+end_src

    #+RESULTS:
    : T

    It does!

    
**** Preamble and explanation
     We're obviously going to be calling a new function here: =load=
     takes the location of a file on disk that is full of Lisp code,
     and evaluates it all in the current session (basically allowing
     You to load libraries and packages, etc). This allows us to
     ensure that our graphing utilities are available without having
     to manually go back and rerun previous code blocks.

     As for the other declarations:
     
     - **node-num** is the number of locations (nodes) in the city.
     - **edge-num** is the number of streets connecting those
       locations (edges).
     - **worm-num** is the number of glowworm teams.
     - **cop-odds** is used for the roadblocks (odds of 1 in
       **cop-odds**).

     #+begin_src lisp
       (load "./lib/graph-util.lisp")
       (defparameter *congestion-city-nodes* nil)
       (defparameter *congestion-city-edges* nil)
       (defparameter *visited-nodes* nil)
       (defparameter *node-num* 30)
       (defparameter *edge-num* 45)
       (defparameter *worm-num* 3)
       (defparameter *cop-odds* 15)
     #+end_src

     #+RESULTS:
     : *COP-ODDS*

     Now, we're going to make a random list of edges to connect all of
     the nodes.

     We'll start with the =random-node= function, which simply returns
     a random number between 1 and *node-num* inclusive (we are using
     the =1+= function here to achieve this; normally it's 0 and
     target exclusive).

     Then we create the =edge-pair= function, which will take two
     numbers as input. Unless the two numbers are equal, it will
     return a list connecting them to one another (and back
     again!). This is because we're using an /undirected graph/ for
     our city, as opposed to a /directed graph/.

     Finally, we compose these two functions into a bigger function
     called =make-edge-list= that will create our final list of
     edges. It does this using a new function, =loop=, which we'll
     look at closer in the next section.

     Reading from the inside out, we have our =edge-pair= function
     being collected on repeat, up until we've done so the same number
     of times as *edge-num*.

     We are them applying the =append= function (using /sharp-quoting/
     and =apply=).

     #+begin_src lisp
       (defun random-node ()
	 (1+ (random *node-num*)))
       (defun edge-pair (a b)
	 (unless (eql a b)
	   (list (cons a b) (cons b a))))
       (defun make-edge-list ()
	 (apply #'append (loop repeat *edge-num*
			       collect (edge-pair (random-node) (random-node)))))
     #+end_src

     #+RESULTS:
     : MAKE-EDGE-LIST

     Let's give this function a try.

     #+begin_src lisp
       (make-edge-list)
     #+end_src

     #+RESULTS:
     : ((29 . 23) (23 . 29) (15 . 26) (26 . 15) (13 . 6) (6 . 13) (2 . 27)
     : (27 . 2) (12 . 4) (4 . 12) (6 . 5) (5 . 6) (27 . 17) (17 . 27) (8 . 5)
     : (5 . 8) (26 . 27) (27 . 26) (2 . 18) (18 . 2) (20 . 24) (24 . 20) (11
     : . 19) (19 . 11) (25 . 26) (26 . 25) (29 . 28) (28 . 29) (29 . 14) (14
     : . 29) (18 . 27) (27 . 18) (15 . 8) (8 . 15) (10 . 14) (14 . 10) (12
     : . 9) (9 . 12) (13 . 27) (27 . 13) (16 . 1) (1 . 16) (6 . 13) (13 . 6)
     : (14 . 7) (7 . 14) (28 . 7) (7 . 28) (3 . 14) (14 . 3) (29 . 15) (15
     : . 29) (15 . 19) (19 . 15) (21 . 12) (12 . 21) (19 . 8) (8 . 19) (26
     : . 3) (3 . 26) (3 . 5) (5 . 3) (5 . 10) (10 . 5) (26 . 10) (10 . 26)
     : (27 . 2) (2 . 27) (8 . 20) (20 . 8) (15 . 2) (2 . 15) (9 . 21) (21
     : . 9) (9 . 7) (7 . 9) (4 . 12) (12 . 4) (13 . 19) (19 . 13) (10 . 15)
     : (15 . 10) (9 . 26) (26 . 9) (12 . 29) (29 . 12) (11 . 20) (20 . 11))

     
**** Looping with the =loop= Command
     The =loop= function loops over data, and is fairly powerful.

     We'll be examining it in greater detail in Chapter 10, but we're
     introducing it now. Here's a simple example.

     #+begin_src lisp
       (loop repeat 10
	     collect 1)
     #+end_src

     #+RESULTS:
     | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

     We can also keep a running count with a different form.

     #+begin_src lisp
       (loop for n from 1 to 10
	     collect n)
     #+end_src

     #+RESULTS:
     | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

     You can put any Lisp code in the =collect= part of the loop.

     #+begin_src lisp
       (loop for n from 1 to 10
	     collect (+ 100 n))
     #+end_src

     #+RESULTS:
     | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 |


     
**** Preventing Islands
     If a node doesn't receive at least one edge, it is an island (and
     inaccessible to the rest of the map.)

     Instead of fixing our algorithm above to prevent this, we are
     going to simply find all islands at the end of generation and
     connect them somewhere.

     #+begin_src lisp
       (defun direct-edges (node edge-list)
	 (remove-if-not (lambda (x)
			  (eql (car x) node))
			edge-list))
     #+end_src
